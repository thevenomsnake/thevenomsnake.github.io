<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[初识布隆过滤器(Bloom Filiter)]]></title>
    <url>%2F2019%2F03%2F%E5%88%9D%E8%AF%86%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8-Bloom-Filiter%2F</url>
    <content type="text"><![CDATA[一个网站有 100 亿 url 存在一个黑名单中，每条 url 平均 64 字节。这个黑名单要怎么存？若此时随便输入一个 url，你如何快速判断该 url 是否在这个黑名单中？ 问题解析这是一道经常在面试中出现的算法题。凭借着题目极其容易描述，电面的时候也出现过。 不考虑细节的话，此题就是一个简单的查找问题。对于查找问题而言，使用散列表来处理往往是一种效率比较高的方案。 但是，如果你在面试中回答使用散列表，接下来面试官肯定会问你：然后呢？如果你不能回答个所以然，面试官就会面无表情的通知你：今天的面试到此结束，我们会在一周内给你答复，然后你就gg了。 为什么不能用散列表100 亿是一个很大的数量级，这里每条 url 平均 64 字节，全部存储的话需要 640G 的内存空间。又因为使用了散列表这种数据结构，而散列表是会出现散列冲突的。为了让散列表维持较小的装载因子，避免出现过多的散列冲突，需要使用链表法来处理，这里就要存储链表指针。因此最后的内存空间可能超过 1000G 了。在实际生产环境中，用1000G来存储 url 显然不太现实。 位图（BitMap）这个时候就需要拓展一下思路。首先，先来考虑一个类似但更简单的问题：现在有一个非常庞大的数据，比如有 1 千万个整数，并且整数的范围在 1 到 1 亿之间。那么如何快速查找某个整数是否在这 1 千万个整数中呢？ 需要判断该数是否存在，也就是说这个数存在两种状态：存在（ True ）或者不存在（False）。 因此这里可以使用一个存储了状态的数组来处理。这个数组特点是大小为 1 亿，并且数据类型为布尔类型（ True 或者 False ）。然后将这 1 千万个整数作为数组下标，将对应的数组值设置成 True，比如，整数 233 对应下标为 233 的数组值设置为 True，也就是 array [233] = True。 这种操作就是位图法：就是用每一位来存放某种状态，适用于大规模数据，但数据状态又不是很多的情况。 另外，位图法有一个优势就是空间不随集合内元素个数的增加而增加。它的存储空间计算方式是找到所有元素里面最大的元素（假设为 N ），因此所占空间为： $$S = \frac{N}{8}Byte$$ 因此，当 N 为 1 亿的时候需要 12MB 的存储空间。当 N 为 10 亿的时候需要 120MB 的存储空间了。也就是说：位图法的所占空间随集合内最大元素的增大而增大。这就会带来一个问题，如果查找的元素数量少但其中某个元素的值很大，比如数字范围是 1 到 1000 亿，那消耗的空间不容乐观。 因此，出于性能和内存占用的考虑，在这里使用布隆过滤器才是最好的解决方案：布隆过滤器是对位图的一种改进。 布隆过滤器(Bloom Filter)简介* 看不太懂的建议看完后再返回看本部分 布隆过滤器（Bloom Filter）是 1970 年由 Burton Bloom 提出的。 布隆过滤器本质上是一个固定长度的位向量，一个位数组。 布隆过滤器是一种节省空间的数据结构，可以用来判断一个元素是否在一个集合中。它的优势是只需要占用很小的内存空间以及有着高效的查询效率。 对于布隆过滤器而言，它的本质是一个固定长度的位向量，位数组。 位数组就是数组的每个元素都只占用 1 bit ，并且每个元素只能是 0 或者 1。 布隆过滤器除了一个位数组，还有 K 个哈希函数。当一个元素加入布隆过滤器中的时候，会进行如下操作： 使用 K 个哈希函数对元素值进行 K 次计算，得到 K 个哈希值。 根据得到的哈希值，在位数组中把对应下标的值置为 1。 举个例子，假设布隆过滤器有 3 个哈希函数：f1, f2, f3 和一个位数组 arr。现在要把 2333 插入布隆过滤器中： 对值进行三次哈希计算，得到三个值 n1, n2, n3。 把位数组中三个元素 arr [n1], arr [n2], arr [3] 都置为 1。 当要判断一个值是否在布隆过滤器中，对元素进行三次哈希计算，得到值之后判断位数组中的每个元素是否都为 1，如果值都为 1，那么说明这个值在布隆过滤器中，如果存在一个值不为 1，说明该元素不在布隆过滤器中。 很明显，数组的容量即使再大，也是有限的。那么随着元素的增加，插入的元素就会越多，位数组中被置为 1 的位置因此也越多，这就会造成一种情况：当一个不在布隆过滤器中的元素，经过同样规则的哈希计算之后，得到的值在位数组中查询，有可能这些位置因为之前其它元素的操作先被置为 1 了。 所以，有可能一个不存在布隆过滤器中的会被误判成在布隆过滤器中。这就是布隆过滤器的一个缺陷。但是，如果布隆过滤器判断某个元素不在布隆过滤器中，那么这个值就一定不在布隆过滤器中。总结就是： 布隆过滤器说某个元素在，可能会被误判 布隆过滤器说某个元素不在，那么一定不在 注意: 与哈希表不同，布隆过滤器不存储实际对象。 它只会记住你看过的物体（有一定程度的不确定性）以及你没有看过的物体。 将对象插入集合中布隆过滤器本质上是一个固定长度的位向量，一个位数组。 当我们插入对象时，我们将其中一些位设置为 1，当我们查询对象时，我们检查某些位是 0 还是 1。 两个操作都使用哈希函数。要在过滤器中插入元素，可以使用多个不同的哈希函数对元素进行哈希。 每个哈希函数返回一个我们映射到数组中索引的值。 然后，我们将这些索引处的位设置为 1 。 例如，假设这是我们的位数组。 我们有 17 位，最初它们都是 0 ： 1[ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 ] 现在我们要在布隆过滤器中插入字符串 &quot;Hello world!&quot;。 我们对此字符串应用两个自定义哈希函数。第一个给出值 1999532104120917762。我们通过取数组长度的模数将此哈希值映射到数组的索引：1999532104120917762 % 17 = 4。 这意味着我们将索引 4 处的位设置为 1 ： 1[ 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 ] 然后我们再次散列原始字符串，但这次使用不同的散列函数。 它给出哈希值 9211818684948223801。模数 17 为 12，我们也将索引 12 处的位设置为 1： 1[ 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0 ] 这两个 1 位足以告诉布隆过滤器它现在包含字符串 &quot;Hello world!&quot;。 当然，它不包含实际的字符串，所以你不能要求布隆过滤器，“给我一个你包含的所有对象的列表”。 所有它都是一堆零和零。 查询集合类似于插入，查询是通过首先对期望值进行哈希来实现的，该期望值给出几个数组索引，然后检查这些索引处的所有位是否为 1。 如果其中一个位不是 1，则无法插入该元素，并且查询返回 false。 如果所有位都是 1，则查询返回 true。 例如，如果我们查询字符串 &quot;Hello WORLD&quot;，那么第一个哈希函数返回 5383892684077141175，其中模 17 是 12. 该位是 1。但是第二个哈希函数给出 5625257205398334446，它映射到数组索引 9. 该位为 0。 这意味着字符串 &quot;Hello WORLD&quot; 不在过滤器中，查询返回 false。 第一个哈希函数映射到 1 位的事实是巧合（它与两个字符串以 &quot;Hello &quot; 开头的事实无关）。 太多这样的巧合可能导致 “碰撞”。 如果存在冲突，即使未插入元素，查询也可能错误地返回 true 。 假设我们插入了一些其他元素，&quot;Bloom Filterz&quot;，它设置了第 7 位和第 9 位。现在数组看起来像这样： 1[ 0, 0, 0, 0, 1, 0, 0, 1, 0, 1, 0, 0, 1, 0, 0, 0, 0 ] 如果再次查询 &quot;Hello WORLD&quot;，则过滤器会看到第 12 位为真，第 9 位现在也为真。 它报告说 &quot;Hello WORLD&quot; 确实出现在集合中，即使它不是…… 因为我们从未插入过那个特定的字符串。这是误报。这个例子说明了为什么布隆过滤器永远不会说 “绝对是”，只有“可能是”。 您可以通过使用具有更多位的数组并使用其他哈希函数来解决此类问题。 当然，使用的哈希函数越多，布隆过滤器就越慢。 所以你必须取得平衡。 使用布隆过滤器无法删除，因为任何一个位都可能属于多个元素。 一旦你添加了一个元素，它就在那里。 布隆过滤器的性能是 O (k) 其中 k 是哈希函数的数量。 代码代码非常简单。 内部位数组在初始化时设置为固定长度，初始化后不能进行突变。 1234public init(size: Int = 1024, hashFunctions: [(T) -&gt; Int]) &#123; self.array = [Bool](repeating: false, count: size) self.hashFunctions = hashFunctions&#125; 应在初始化时指定几个哈希函数。 你使用哪些哈希函数将取决于您将添加到集合的元素的数据类型。 你可以在测试中看到一些例子 ———字符串的 djb2 和 sdbm 哈希函数。 insert只是将所需的位翻转为 true： 12345public func insert(_ element: T) &#123; for hashValue in computeHashes(element) &#123; array[hashValue] = true &#125;&#125; 这使用 computeHashes() 函数，它循环遍历指定的 hashFunctions 并返回索引数组： 123private func computeHashes(_ value: T) -&gt; [Int] &#123; return hashFunctions.map() &#123; hashFunc in abs(hashFunc(value) % array.count) &#125;&#125; 并查询检查以确保哈希值处的位为 true： 123456public func query(_ value: T) -&gt; Bool &#123; let hashValues = computeHashes(value) let results = hashValues.map() &#123; hashValue in array[hashValue] &#125; let exists = results.reduce(true, &#123; $0 &amp;&amp; $1 &#125;) return exists&#125; 如果你来自另一种命令式语言，你可能会注意到 exists 赋值中的不寻常语法。 当 Swift 使代码更加简洁和可读时，Swift 使用函数范例，在这种情况下，reduce 是一种更加简洁的方法来检查所有必需的位是否为 true 而不是 for 循环。 另一种方法通过上面的例子，您了解了如何使用多个不同的哈希函数来帮助减少布隆过滤器中发生冲突的可能性。但是，良好的散列函数是很难设计的。多个散列函数的简单替代方法是使用一组随机数。 举个例子，假设一个布隆过滤器想要在插入过程中对每个元素进行 15 次哈希处理。您可以只使用一个哈希函数，而不是使用 15 种不同的哈希函数。然后可以将散列值与 15 个不同的值组合以形成用于翻转的索引。此布隆过滤器将提前初始化一组 15 个随机数，并在每次插入期间使用这些值。 12hash("Hello world!") &gt;&gt; hash(987654321) // would flip bit 8hash("Hello world!") &gt;&gt; hash(123456789) // would flip bit 2 自 Swift 4.2 以来，Hasher现在包含在标准库中，该库旨在以有效的方式将多个哈希值减少到单个哈希值。这使得哈希的组合变得微不足道。 123456789private func computeHashes(_ value: T) -&gt; [Int] &#123; return randomSeeds.map() &#123; seed in let hasher = Hasher() hasher.combine(seed) hasher.combine(value) let hashValue = hasher.finalize() return abs(hashValue % array.count) &#125;&#125; 如果您想了解有关此方法的更多信息，可以阅读Hasher 文档或 Soroush Khanlou 的Swift 4.2 Bloom 过滤器实现。 BloomFilter.swift123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354public class BloomFilter&lt;T&gt; &#123; fileprivate var array: [Bool] private var hashFunctions: [(T) -&gt; Int] public init(size: Int = 1024, hashFunctions: [(T) -&gt; Int]) &#123; self.array = [Bool](repeating: false, count: size) self.hashFunctions = hashFunctions &#125; private func computeHashes(_ value: T) -&gt; [Int] &#123; return hashFunctions.map &#123; hashFunc in abs(hashFunc(value) % array.count) &#125; &#125; public func insert(_ element: T) &#123; for hashValue in computeHashes(element) &#123; array[hashValue] = true &#125; &#125; public func insert(_ values: [T]) &#123; for value in values &#123; insert(value) &#125; &#125; public func query(_ value: T) -&gt; Bool &#123; let hashValues = computeHashes(value) let results = hashValues.map &#123; hashValue in array[hashValue] &#125; let exists = results.reduce(true, &#123; $0 &amp;&amp; $1 &#125;) return exists &#125; public func isEmpty() -&gt; Bool &#123; return array.reduce(true, &#123; prev, next in prev &amp;&amp; !next&#125; ) &#125;&#125;func djb2(x: String) -&gt; Int &#123; var hash = 5381 for char in x &#123; hash = ((hash &lt;&lt; 5) &amp;+ hash) &amp;+ char.hashValue &#125; return Int(hash)&#125;func sdbm(x: String) -&gt; Int &#123; var hash = 0 for char in x &#123; hash = char.hashValue &amp;+ (hash &lt;&lt; 6) &amp;+ (hash &lt;&lt; 16) &amp;- hash &#125; return Int(hash)&#125; 使用场景布隆过滤器的最大的用处就是，能够迅速判断一个元素是否在一个集合中。因此它有如下三个使用场景: 网页爬虫对 URL 的去重，避免爬取相同的 URL 地址 进行垃圾邮件过滤：反垃圾邮件，从数十亿个垃圾邮件列表中判断某邮箱是否垃圾邮箱（同理，垃圾短信） 有的黑客为了让服务宕机，他们会构建大量不存在于缓存中的 key 向服务器发起请求，在数据量足够大的情况下，频繁的数据库查询可能导致 DB 挂掉。布隆过滤器很好的解决了缓存击穿的问题。 引用拜托，面试官别问我「布隆」了 swift-algorithm-club/Bloom Filter]]></content>
      <tags>
        <tag>algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Red-Black Tree (ZH && EN)]]></title>
    <url>%2F2019%2F03%2FRed-Black-Tree-ZH-EN%2F</url>
    <content type="text"><![CDATA[或许你需要同时打开两份此文章，上下对照理解 || Maybe you need to open two copies of this article at the same time. Introduction || 介绍A red-black tree (RBT) is a balanced version of a Binary Search Tree guaranteeing that the basic operations (search, predecessor, successor, minimum, maximum, insert and delete) have a logarithmic worst case performance.红黑树（RBT）是二叉搜索树的平衡版本，能保证基本操作（搜索，前驱，后继，最小，最大，插入和删除）具有对数最坏情况的性能。 Binary search trees (BSTs) have the disadvantage that they can become unbalanced after some insert or delete operations. In the worst case, this could lead to a tree where the nodes build a linked list as shown in the following example: 二叉搜索树（BST）的缺点是它们在一些插入或删除操作之后可能变得不平衡。 在最坏的情况下，这可能会变成链接列表的树，如以下示例所示： 1234567a \ b \ c \ d To prevent this issue, RBTs perform rebalancing operations after an insert or delete and store an additional color property at each node which can either be red or black. After each operation a RBT satisfies the following properties: 为了防止出现此问题，RBT在插入或删除后执行重新平衡操作，并在每个节点上存储其他颜色属性，可以是红色或黑色。 每次操作后，RBT都满足以下属性： Properties || 属性 Every node is either red or black The root is black Every leaf (nullLeaf) is black If a node is red, then both its children are black For each node, all paths from the node to descendant leaves contain the same number of black nodes 每个节点都是红色或黑色 根是黑色的 叶节点（nullLeaf）都是黑色的 如果节点为红色，则其子节点均为黑色 对于每个节点，从节点到后代叶子的所有路径都包含相同数量的黑色节点 Property 5 includes the definition of the black-height of a node x, bh(x), which is the number of black nodes on a path from this node down to a leaf not counting the node itself.From [CLRS]属性5包括节点x的黑色高度的定义，bh(x)，它是从该节点到不计算节点本身的叶子的路径上的黑色节点的数量。（来自 [CLRS]） 译注： CLRS 是指《算法导论》 Methods || 方法Nodes: nodeX.getSuccessor() Returns the inorder successor of nodeX nodeX.minimum() Returns the node with the minimum key of the subtree of nodeX nodeX.maximum() Returns the node with the maximum key of the subtree of nodeXTree: search(input:) Returns the node with the given key value minValue() Returns the minimum key value of the whole tree maxValue() Returns the maximum key value of the whole tree insert(key:) Inserts the key value into the tree delete(key:) Delete the node with the respective key value from the tree verify() Verifies that the given tree fulfills the red-black tree properties The rotation, insertion and deletion algorithms are implemented based on the pseudo-code provided in [CLRS] 节点： nodeX.getSuccessor() 返回nodeX的inorder后继 nodeX.minimum() 返回具有nodeX子树最小键的节点 nodeX.maximum() 返回具有nodeX子树的最大键的节点树： search(input:) 返回具有给定键值的节点 minValue() 返回整个树的最小键值 maxValue()返回整个树的最大键值 insert(key:) 将键值插入树中 delete(key:) 使用树中相应的键值删除节点 verify() 验证给定的树是否满足红黑树属性 旋转，插入和删除算法基于[CLRS]中提供的伪代码实现 Implementation Details || 实施细节For convenience, all nil-pointers to children or the parent (except the parent of the root) of a node are exchanged with a nullLeaf. This is an ordinary node object, like all other nodes in the tree, but with a black color, and in this case a nil value for its children, parent and key. Therefore, an empty tree consists of exactly one nullLeaf at the root.为方便起见，所有指向子节点的nil指针或节点的父节点（根节点的父节点）都与nullLeaf交换。 这是一个普通的节点对象，就像树中的所有其他节点一样，但是使用黑色，在这种情况下，它的子节点是父节点和键的nil值。 因此，空树在根处只包含一个nullLeaf。 Rotation || 旋转Left rotation (around x):Assumes that x.rightChild y is not a nullLeaf, rotates around the link from x to y, makes y the new root of the subtree with x as y’s left child and y’s left child as x’s right child, where n = a node, [n] = a subtree 左旋（围绕x）：假设x.rightChild y不是nullLeaf，围绕从x到y的链接旋转，使y成为子树的新根，x为y的左子，y的左子为x的右子，其中 n = a node, [n] = a subtree 123456 | | x y / \ ~&gt; / \[A] y x [C] / \ / \ [B] [C] [A] [B] Right rotation (around y):Assumes that y.leftChild x is not a nullLeaf, rotates around the link from y to x, makes x the new root of the subtree with y as x’s right child and x’s right child as y’s left child, where n = a node, [n] = a subtree 右旋（围绕y）：假设y.leftChild x不是nullLeaf，围绕从y到x的链接旋转，使x成为子树的新根，其中y为x的右子，x的右子为y的左子，其中 n = a node, [n] = a subtree 123456 | | x y / \ &lt;~ / \[A] y x [C] / \ / \ [B] [C] [A] [B] As rotation is a local operation only exchanging pointers it’s runtime is O(1).由于旋转是仅交换指针的本地操作，因此它的运行时为O(1)。 Insertion || 插入We create a node with the given key and set its color to red. Then we insert it into the the tree by performing a standard insert into a BST. After this, the tree might not be a valid RBT anymore, so we fix the red-black properties by calling the insertFixup algorithm.The only violation of the red-black properties occurs at the inserted node z and its parent. Either both are red, or the parent does not exist (so there is a violation since the root must be black). 我们用给定的键创建一个节点，并将其颜色设置为红色。 然后我们通过在BST中执行标准插入将其插入树中。 在此之后，树可能不再是有效的RBT，因此我们通过调用insertFixup算法来修复红黑属性。唯一违反红黑属性的情况发生在插入的节点z及其父节点上。 两者都是红色，或者父级不存在（因此存在违规，因为根必须是黑色）。 We have three distinct cases:Case 1: The uncle of z is red. If z.parent is left child, z’s uncle is z.grandparent’s right child. If this is the case, we recolor and move z to z.grandparent, then we check again for this new z. In the following cases, we denote a red node with (x) and a black node with {x}, p = parent, gp = grandparent and u = uncle 我们有三个不同的案例：案例1： z的叔叔是红色的。 如果z.parent留给孩子，z的叔叔是z.grandparent的右孩子。 如果是这种情况，我们重新着色并将z移动到z.grandparent，然后我们再次检查这个新z。 在下面的例子中，我们用（x）表示红色节点，用{x}表示黑色节点，p =父，gp =祖父母，u =叔叔 12345678 | | &#123;gp&#125; (newZ) / \ ~&gt; / \ (p) (u) &#123;p&#125; &#123;u&#125; / \ / \ / \ / \ (z) [C] [D] [E] (z) [C] [D] [E] / \ / \[A] [B] [A] [B] Case 2a: The uncle of z is black and z is right child. Here, we move z upwards, so z’s parent is the newZ and then we rotate around this newZ. After this, we have Case 2b.案例2a： z的叔叔是黑人，z是右孩子。 在这里，我们将z向上移动，因此z的父级是newZ，然后我们围绕这个newZ旋转。 在此之后，我们有案例2b。 12345678 | | &#123;gp&#125; &#123;gp&#125; / \ ~&gt; / \ (p) &#123;u&#125; (z) &#123;u&#125; / \ / \ / \ / \[A] (z) [D] [E] (newZ) [C] [D] [E] / \ / \ [B] [C] [A] [B] Case 2b: The uncle of z is black and z is left child. In this case, we recolor z.parent to black and z.grandparent to red. Then we rotate around z’s grandparent. Afterwards we have valid red-black tree.案例2b： z的叔叔是黑人而z是小孩子。 在这种情况下，我们将z.parent重新着色为黑色，将z.grandparent重新着色为红色。 然后我们围绕z的祖父母转动。 之后我们有了有效的红黑树。 12345678 | | &#123;gp&#125; &#123;p&#125; / \ ~&gt; / \ (p) &#123;u&#125; (z) (gp) / \ / \ / \ / \ (z) [C] [D] [E] [A] [B] [C] &#123;u&#125; / \ / \[A] [B] [D] [E] Running time of this algorithm: Only case 1 may repeat, but this only h/2 steps, where h is the height of the tree Case 2a -&gt; Case 2b -&gt; red-black tree Case 2b -&gt; red-black treeAs we perform case 1 at most O(log n) times and all other cases at most once, we have O(log n) recolorings and at most 2 rotations.The overall runtime of insert is O(log n).该算法的运行时间： 只有案例1可以重复，但这只有h / 2步，其中h是树的高度 案例2a -&gt; 案例2b -&gt; 红黑树 案例2b -&gt; 红黑树由于我们在最多O(log n)次执行情况1并且所有其他情况最多执行一次，我们有O(log n)重新着色并且最多2次旋转。insert的整个运行时为O(log n)。 Deletion || 删除We search for the node with the given key, and if it exists we delete it by performing a standard delete from a BST. If the deleted nodes’ color was red everything is fine, otherwise red-black properties may be violated so we call the fixup procedure deleteFixup.Violations can be that the parent and child of the deleted node x where red, so we now have two adjacent red nodes, or if we deleted the root, the root could now be red, or the black height property is violated.We have 4 cases: We call deleteFixup on node xCase 1: The sibling of x is red. The sibling is the other child of x’s parent, which is not x itself. In this case, we recolor the parent of x and x.sibling then we left rotate around x’s parent. In the following cases s = sibling of x, (x) = red, {x} = black, |x| = red/black. 我们使用给定密钥搜索节点，如果存在，我们通过从BST执行标准删除来删除它。 如果删除的节点的颜色为红色，则一切正常，否则可能会违反红黑属性，因此我们调用修复程序deleteFixup。违规可以是已删除节点x的父节点和子节点为红色，因此我们现在有两个相邻的红色节点，或者如果我们删除了根节点，则根目录可能是红色，或者违反了黑色高度属性。我们有4种情况：我们在节点x上调用deleteFixup案例1： x的兄弟是红色的。 兄弟姐妹是x的父母的另一个孩子，而不是x本身。 在这种情况下，我们重新着色x和x.sibling的父级，然后我们围绕x的父级旋转。 在下列情况下，s = x的兄弟，（x）=红色，{x} =黑色，| x | =红色/黑色。 12345678 | | &#123;p&#125; &#123;s&#125; / \ ~&gt; / \ &#123;x&#125; (s) (p) [D] / \ / \ / \ [A] [B] [C] [D] &#123;x&#125; [C] / \ [A] [B] Case 2: The sibling of x is black and has two black children. Here, we recolor x.sibling to red, move x upwards to x.parent and check again for this newX. 案例2： x的兄弟是黑人，有两个黑人孩子。 在这里，我们将x.sibling重新着色为红色，将x向上移动到x.parent并再次检查此newX。 12345678 | | |p| |newX| / \ ~&gt; / \ &#123;x&#125; &#123;s&#125; &#123;x&#125; (s) / \ / \ / \ / \[A] [B] &#123;l&#125; &#123;r&#125; [A] [B] &#123;l&#125; &#123;r&#125; / \ / \ / \ / \ [C][D][E][F] [C][D][E][F] Case 3: The sibling of x is black with one black child to the right. In this case, we recolor the sibling to red and sibling.leftChild to black, then we right rotate around the sibling. After this we have case 4. 案例3： x的兄弟是黑色，右边有一个黑人孩子。 在这种情况下，我们将兄弟重新着色为红色和sibling.leftChild为黑色，然后我们右旋转兄弟。 在此之后我们有案例4。 12345678910 | | |p| |p| / \ ~&gt; / \ &#123;x&#125; &#123;s&#125; &#123;x&#125; &#123;l&#125; / \ / \ / \ / \[A] [B] (l) &#123;r&#125; [A] [B] [C] (s) / \ / \ / \ [C][D][E][F] [D]&#123;e&#125; / \ [E] [F] Case 4: The sibling of x is black with one red child to the right. Here, we recolor the sibling to the color of x.parent and x.parent and sibling.rightChild to black. Then we left rotate around x.parent. After this operation we have a valid red-black tree. Here, ||x|| denotes that x can have either color red or black, but that this can be different to |x| color. This is important, as s gets the same color as p. 案例4： x的兄弟是黑色的，右边是一个红色的孩子。 在这里，我们将兄弟重新着色为x.parent和x.parent以及sibling.rightChild的颜色为黑色。 然后我们左右旋转x.parent。 在此操作之后，我们有一个有效的红黑树。 这里，|| x || 表示x可以有红色或黑色，但这可能与| x |不同 颜色。 这很重要，因为s与p具有相同的颜色。 12345678 | | ||p|| ||s|| / \ ~&gt; / \ &#123;x&#125; &#123;s&#125; &#123;p&#125; &#123;r&#125; / \ / \ / \ / \[A] [B] |l| (r) &#123;x&#125; |l| [E] [F] / \ / \ / \ / \ [C][D][E][F] [A][B][C][D] Running time of this algorithm: Only case 2 can repeat, but this only h many times, where h is the height of the tree Case 1 -&gt; case 2 -&gt; red-black treeCase 1 -&gt; case 3 -&gt; case 4 -&gt; red-black treeCase 1 -&gt; case 4 -&gt; red-black tree Case 3 -&gt; case 4 -&gt; red-black tree Case 4 -&gt; red-black treeAs we perform case 2 at most O(log n) times and all other steps at most once, we have O(log n) recolorings and at most 3 rotations.The overall runtime of delete is O(log n). 该算法的运行时间： 只有情况2可以重复，但这只有很多次，其中h是树的高度 案例1 -&gt; 案例2 -&gt; 红黑树案例1 -&gt; 案例3 -&gt; 案例4 -&gt; 红黑树案例1 -&gt; 案例4 -&gt; 红黑树 案例3 -&gt; 案例4 -&gt; 红黑树 案例4 -&gt; 红黑树由于我们在最多O(log n)次执行情况2并且所有其他步骤最多执行一次，因此我们有O(log n)重新着色并且最多3次旋转。删除的总体运行时间是O(log n)。 Code || 代码Basic || 基本12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879import Foundationprivate enum RBTreeColor &#123; case red case black&#125;private enum RotationDirection &#123; case left case right&#125;// MARK: - RBNode// 标记： - RBNodepublic class RBTreeNode&lt;T: Comparable&gt;: Equatable &#123; public typealias RBNode = RBTreeNode&lt;T&gt; fileprivate var color: RBTreeColor = .black fileprivate var key: T? var leftChild: RBNode? var rightChild: RBNode? fileprivate weak var parent: RBNode? public init(key: T?, leftChild: RBNode?, rightChild: RBNode?, parent: RBNode?) &#123; self.key = key self.leftChild = leftChild self.rightChild = rightChild self.parent = parent self.leftChild?.parent = self self.rightChild?.parent = self &#125; // nullleaf initialization // 初始化nullleaf public convenience init(key: T?) &#123; self.init(key: key, leftChild: nil, rightChild: nil, parent: nil) self.color = .black &#125; var isRoot: Bool &#123; return parent == nil &#125; var isLeaf: Bool &#123; return rightChild == nil &amp;&amp; leftChild == nil &#125; var isNullLeaf: Bool &#123; return key == nil &amp;&amp; isLeaf &amp;&amp; color == .black &#125; var isRightChild: Bool &#123; return parent?.rightChild == self &#125; var isLeftChild: Bool &#123; return parent?.leftChild == self &#125; // Parent node of the parent node // 父节点的父节点 var grandparent: RBNode? &#123; return parent?.parent &#125; var sibling: RBNode? &#123; if isLeftChild &#123; return parent?.rightChild &#125; else &#123; return parent?.leftChild &#125; &#125; var uncle: RBNode? &#123; return parent?.sibling &#125; &#125; RedBlackTree || 红黑树1234567891011public class RedBlackTree&lt;T: Comparable&gt; &#123; public typealias RBNode = RBTreeNode&lt;T&gt; fileprivate(set) var root: RBNode fileprivate(set) var size = 0 fileprivate let nullLeaf = RBNode() public init() &#123; root = nullLeaf &#125;&#125; Equatable Protocol|| Equatable 协议12345extension RBTreeNode &#123; static public func == &lt;T&gt;(lhs: RBTreeNode&lt;T&gt;, rhs: RBTreeNode&lt;T&gt;) -&gt; Bool &#123; return lhs.key == rhs.key &#125;&#125; Get the precursor node || 获取前驱节点.getSuccessor()12345678910111213141516171819extension RBTreeNode &#123; public func getSuccessor() -&gt; RBNode? &#123; if let rightChild = self.rightChild &#123; if !rightChild.isNullLeaf &#123; return rightChild.minimun() &#125; &#125; var currentNode = self var parent = currentNode.parent while currentNode.isRightChild &#123; if let parent = parent &#123; currentNode = parent &#125; parent = currentNode.parent &#125; return parent &#125;&#125; Searching || 搜索.minimun() &amp;&amp; .maximum()12345678910111213141516171819202122extension RBTreeNode &#123; public func minimun() -&gt; RBNode? &#123; if let leftChild = leftChild &#123; if !leftChild.isNullLeaf &#123; return leftChild.minimun() &#125; return self &#125; return self &#125; public func maximum() -&gt; RBNode? &#123; if let rightChild = rightChild &#123; if !rightChild.isNullLeaf &#123; return rightChild.maximum() &#125; return self &#125; return self &#125;&#125; .search(input:)12345678910111213141516171819202122232425extension RedBlackTree &#123; public func search(input: T) -&gt; RBNode? &#123; return search(key: input, node: root) &#125; fileprivate func search(key: T, node: RBNode?) -&gt; RBNode? &#123; guard let node = node else &#123; return nil &#125; if !node.isNullLeaf &#123; if let nodeKey = node.key &#123; if key == nodeKey &#123; return node &#125; else if key &lt; nodeKey &#123; return search(key: key, node: node.leftChild) &#125; else &#123; return search(key: key, node: node.rightChild) &#125; &#125; &#125; return nil &#125;&#125; .minValue()12345678910111213141516extension RedBlackTree &#123; public func minValue() -&gt; T? &#123; guard let minNode = root.minimun() else &#123; return nil &#125; return minNode.key &#125; public func maxValue() -&gt; T? &#123; guard let maxNode = root.maximum() else &#123; return nil &#125; return maxNode.key &#125;&#125; Insertion || 插入.insert(key:)123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106extension RedBlackTree &#123; public func insert(key: T) &#123; if root.isNullLeaf &#123; root = RBNode(key: key) &#125; else &#123; insert(input: RBNode(key: key), node: root) &#125; &#125; private func insert(input: RBNode, node: RBNode) &#123; guard let inputKey = input.key, let nodeKey = node.key else &#123; return &#125; if inputKey &lt; nodeKey &#123; guard let child = node.leftChild else &#123; addAsLeftChild(child: input, parent: node) return &#125; if child.isNullLeaf &#123; addAsLeftChild(child: input, parent: node) &#125; else &#123; insert(input: input, node: child) &#125; &#125; else &#123; guard let child = node.rightChild else &#123; addAsRightChild(child: input, parent: node) return &#125; if child.isNullLeaf &#123; addAsRightChild(child: input, parent: node) &#125; else &#123; insert(input: input, node: child) &#125; &#125; &#125; private func addAsLeftChild(child: RBNode, parent: RBNode) &#123; parent.leftChild = child child.parent = parent child.color = .red insertFixup(node: child) &#125; private func addAsRightChild(child: RBNode, parent: RBNode) &#123; parent.rightChild = child child.parent = parent child.color = .red insertFixup(node: child) &#125; private func insertFixup(node z: RBNode) &#123; if !z.isNullLeaf &#123; guard let parentZ = z.parent else &#123; return &#125; // If both |z| and his parent are red -&gt; violation of red-black property -&gt; need to fix it // 如果两个 | z | 且而他的父母是红色的 - &gt; 违反红黑属性 - &gt; 需要修复它 if parentZ.color == .red &#123; guard let uncle = z.uncle else &#123; return &#125; // Case 1: Uncle red -&gt; recolor + move z // 案例1: 叔叔是红色 -&gt; 重写着色 + 移动z if uncle.color == .red &#123; parentZ.color = .black uncle.color = .black if let grandparentZ = parentZ.parent &#123; grandparentZ.color = .red // Move z to grandparent and check again // 将 z 移至祖父母并再次检查 insertFixup(node: grandparentZ) &#125; &#125; // Case 2: Uncle black // 案例 2: 叔叔是黑色 else &#123; var zNew = z // Case 2.a: z right child -&gt; rotate // 案例 2.a: z 左边的孩子 -&gt; 回转 if parentZ.isLeftChild &amp;&amp; z.isRightChild &#123; zNew = parentZ leftRotate(node: zNew) &#125; else if parentZ.isRightChild &amp;&amp; z.isLeftChild &#123; zNew = parentZ rightRotate(node: zNew) &#125; // Case 2.b: z left child -&gt; recolor + rotate // 案例 2.a: z 左边的孩子 -&gt; 回转 zNew.parent?.color = .black if let grandparentZnew = zNew.grandparent &#123; grandparentZnew.color = .red if z.isLeftChild &#123; rightRotate(node: grandparentZnew) &#125; else &#123; leftRotate(node: grandparentZnew) &#125; // We have a valid red-black-tree // 我们有一个有效的红黑树 &#125; &#125; &#125; &#125; root.color = .black &#125;&#125; Deletion || 删除.delete() &amp;&amp; .deleteFixup()123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142extension RedBlackTree &#123; public func delete(key: T) &#123; if size == 1 &#123; root = nullLeaf size -= 1 &#125; else if let node = search(key: key, node: root) &#123; if !node.isNullLeaf &#123; delete(node: node) size -= 1 &#125; &#125; &#125; private func delete(node z: RBNode) &#123; var nodeY = RBNode() var nodeX = RBNode() if let leftChild = z.leftChild, let rightChild = z.rightChild &#123; if leftChild.isNullLeaf || rightChild.isNullLeaf &#123; nodeY = z &#125; else &#123; if let successor = z.getSuccessor() &#123; nodeY = successor &#125; &#125; &#125; if let leftChild = nodeY.leftChild &#123; if !leftChild.isNullLeaf &#123; nodeX = leftChild &#125; else if let rightChild = nodeY.rightChild &#123; nodeX = rightChild &#125; &#125; nodeX.parent = nodeY.parent if let parentY = nodeY.parent &#123; // Should never be the case, as parent of root = nil // if parentY.isNullLeaf &#123; root = nodeX &#125; else &#123; if nodeY.isLeftChild &#123; parentY.leftChild = nodeX &#125; else &#123; parentY.rightChild = nodeX &#125; &#125; &#125; else &#123; root = nodeX &#125; if nodeY != z &#123; z.key = nodeY.key &#125; // If sliced out node was red -&gt; nothing to do as red-black-property holds // If it was black -&gt; fix red-black-property if nodeY.color == .black &#123; deleteFixup(node: nodeX) &#125; &#125; private func deleteFixup(node x: RBNode) &#123; var xTmp = x if !x.isRoot &amp;&amp; x.color == .black &#123; guard var sibling = x.sibling else &#123; return &#125; // Case 1: Sibling of x is red if sibling.color == .red &#123; // Recolor sibling.color = .black if let parentX = x.parent &#123; parentX.color = .red // Rotation if x.isLeftChild &#123; leftRotate(node: parentX) &#125; else &#123; rightRotate(node: parentX) &#125; // Update sibling if let sibl = x.sibling &#123; sibling = sibl &#125; &#125; &#125; // Case 2: Sibling is black with two black children if sibling.leftChild?.color == .black &amp;&amp; sibling.rightChild?.color == .black &#123; // Recolor sibling.color = .red // Move fake black unit upwards if let parentX = x.parent &#123; deleteFixup(node: parentX) &#125; // We have a valid red-black-tree &#125; else &#123; // Case 3: a. Sibling black with one black child to the right if x.isLeftChild &amp;&amp; sibling.rightChild?.color == .black &#123; // Recolor sibling.leftChild?.color = .black sibling.color = .red // Rotate rightRotate(node: sibling) // Update sibling of x if let sibl = x.sibling &#123; sibling = sibl &#125; &#125; // Still case 3: b. One black child to the left else if x.isRightChild &amp;&amp; sibling.leftChild?.color == .black &#123; // Recolor sibling.rightChild?.color = .black sibling.color = .red // Rotate leftRotate(node: sibling) // Update sibling of x if let sibl = x.sibling &#123; sibling = sibl &#125; &#125; // Case 4: Sibling is black with red right child // Recolor if let parentX = x.parent &#123; sibling.color = parentX.color parentX.color = .black // a. x left and sibling with red right child if x.isLeftChild &#123; sibling.rightChild?.color = .black // Rotate leftRotate(node: parentX) &#125; // b. x right and sibling with red left child else &#123; sibling.leftChild?.color = .black //Rotate rightRotate(node: parentX) &#125; // We have a valid red-black-tree xTmp = root &#125; &#125; &#125; xTmp.color = .black &#125;&#125; Rotation || 旋转.rotate()12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091extension RedBlackTree &#123; /* * Left rotation around node x * Assumes that x.rightChild y is not a nullLeaf, rotates around the link from x to y, * makes y the new root of the subtree with x as y's left child and y's left child as x's right * child, where n = a node, [n] = a subtree * 左旋（围绕x）： *假设x.rightChild y不是nullLeaf，围绕从x到y的链接旋转，使y成为子树的新根 *x为y的左子，y的左子为x的右子，其中 n = a node, [n] = a subtree * | | * x y * / \ ~&gt; / \ * [A] y x [C] * / \ / \ * [B] [C] [A] [B] */ fileprivate func leftRotate(node x: RBNode) &#123; rotate(node: x, direction: .left) &#125; /* * Right rotation around node y * Assumes that y.leftChild x is not a nullLeaf, rotates around the link from y to x, * makes x the new root of the subtree with y as x's right child and x's right child as y's left * child, where n = a node, [n] = a subtree *右旋（围绕y）： *假设y.leftChild x不是nullLeaf，围绕从y到x的链接旋转，使x成为子树的新根 *其中y为x的右子，x的右子为y的左子，其中 n = a node, [n] = a subtree * | | * x y * / \ &lt;~ / \ * [A] y x [C] * / \ / \ * [B] [C] [A] [B] */ fileprivate func rightRotate(node x: RBNode) &#123; rotate(node: x, direction: .right) &#125; /* * Rotation around a node x * Is a local operation preserving the binary-search-tree property that only exchanges pointers. * Runntime: O(1) * 绕节点 x 旋转 * 本地操作是否保留仅交换指针的 binary-search-tree 属性。 * 运行时间：O（1） */ private func rotate(node x: RBNode, direction: RotationDirection) &#123; var nodeY: RBNode? = RBNode() // Set |nodeY| and turn |nodeY|'s left/right subtree into |x|'s right/left subtree // 设置 | nodeY | 并将 | nodeY | 的左 / 右子树转换为 | x | 的右 / 左子树 switch direction &#123; case .left: nodeY = x.rightChild x.rightChild = nodeY?.leftChild x.rightChild?.parent = x case .right: nodeY = x.leftChild x.leftChild = nodeY?.rightChild x.leftChild?.parent = x &#125; // Link |x|'s parent to nodeY // 链接 | x | 的父节点到 nodeY nodeY?.parent = x.parent if x.isRoot &#123; if let node = nodeY &#123; root = node &#125; &#125; else if x.isLeftChild &#123; x.parent?.leftChild = nodeY &#125; else if x.isRightChild &#123; x.parent?.rightChild = nodeY &#125; // Put |x| on |nodeY|'s left // 把 | x | on | nodeY | 的左边 switch direction &#123; case .left: nodeY?.leftChild = x case .right: nodeY?.rightChild = x &#125; x.parent = nodeY &#125;&#125; Verification || 核查.verify()123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899extension RedBlackTree &#123; /* * Verifies that the existing tree fulfills all red-black properties * Returns true if the tree is a valid red-black tree, false otherwise */ /* * 验证现有树是否满足所有红黑属性 * 如果树是有效的红黑树，则返回 true，否则返回 false */ public func verify() -&gt; Bool &#123; if root.isNullLeaf &#123; print("The tree is empty") return true &#125; return property2() &amp;&amp; property4() &amp;&amp; property5() &#125; // Property 1: Every node is either red or black -&gt; fullfilled through setting node.color of type // 属性 1：每个节点都是红色或黑色 - &gt; 通过设置类型的 node.color 来填充 // RBTreeColor // Property 2: The root is black // 属性 2：根是黑色的 private func property2() -&gt; Bool &#123; if root.color == .red &#123; print("Property-Error: Root is red") return false &#125; return true &#125; // Property 3: Every nullLeaf is black -&gt; fullfilled through initialising nullLeafs with color = black // 属性 3：每个 null Leaf 都是黑色的 - &gt; 通过初始化带有 color = black 的 null Leafs 来实现 // Property 4: If a node is red, then both its children are black // 属性 4：如果节点为红色，则其子节点均为黑色 private func property4() -&gt; Bool &#123; return property4(node: root) &#125; private func property4(node: RBNode) -&gt; Bool &#123; if node.isNullLeaf &#123; return true &#125; if let leftChild = node.leftChild, let rightChild = node.rightChild &#123; if node.color == .red &#123; if !leftChild.isNullLeaf &amp;&amp; leftChild.color == .red &#123; print("Property-Error: Red node with key \(String(describing: node.key)) has red left child") return false &#125; if !rightChild.isNullLeaf &amp;&amp; rightChild.color == .red &#123; print("Property-Error: Red node with key \(String(describing: node.key)) has red right child") return false &#125; &#125; return property4(node: leftChild) &amp;&amp; property4(node: rightChild) &#125; return false &#125; // Property 5: For each node, all paths from the node to descendant leaves contain the same number // 属性 5：对于每个节点，从节点到后代叶子的所有路径都包含相同的数字 // of black nodes (same blackheight) // 黑色节点（同样黑色高度） private func property5() -&gt; Bool &#123; if property5(node: root) == -1 &#123; return false &#125; else &#123; return true &#125; &#125; private func property5(node: RBNode) -&gt; Int &#123; if node.isNullLeaf &#123; return 0 &#125; guard let leftChild = node.leftChild, let rightChild = node.rightChild else &#123; return -1 &#125; let left = property5(node: leftChild) let right = property5(node: rightChild) if left == -1 || right == -1 &#123; return -1 &#125; else if left == right &#123; let addedHeight = node.color == .black ? 1 : 0 return left + addedHeight &#125; else &#123; print("Property-Error: Black height violated at node with key \(String(describing: node.key))") return -1 &#125; &#125;&#125; Debug || 调试12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364extension RBTreeNode: CustomDebugStringConvertible &#123; public var debugDescription: String &#123; var s = "" if isNullLeaf &#123; s = "nullLeaf" &#125; else &#123; if let key = key &#123; s = "key: \(key)" &#125; else &#123; s = "key: nil" &#125; if let parent = parent &#123; s += ", parent: \(String(describing: parent.key))" &#125; if let left = leftChild &#123; s += ", left = [" + left.debugDescription + "]" &#125; if let right = rightChild &#123; s += ", right = [" + right.debugDescription + "]" &#125; s += ", color = \(color)" &#125; return s &#125;&#125;extension RedBlackTree: CustomDebugStringConvertible &#123; public var debugDescription: String &#123; return root.debugDescription &#125;&#125;extension RBTreeNode: CustomStringConvertible &#123; public var description: String &#123; var s = "" if isNullLeaf &#123; s += "nullLeaf" &#125; else &#123; if let left = leftChild &#123; s += "(\(left.description)) &lt;- " &#125; if let key = key &#123; s += "\(key)" &#125; else &#123; s += "nil" &#125; s += ", \(color)" if let right = rightChild &#123; s += " -&gt; (\(right.description))" &#125; &#125; return s &#125;&#125;extension RedBlackTree: CustomStringConvertible &#123; public var description: String &#123; if root.isNullLeaf &#123; return "[]" &#125; else &#123; return root.description &#125; &#125;&#125; Reference || 引用：[CLRS] T. Cormen, C. Leiserson, R. Rivest, and C. Stein. “Introduction to Algorithms”, Third Edition. 2009 [CLRS] T. Cormen, C. Leiserson, R. Rivest, and C. Stein. 《算法导论》, 第三版. 2009 https://github.com/raywenderlich/swift-algorithm-club/tree/master/Red-Black%20Tree https://github.com/andyRon/swift-algorithm-club-cn]]></content>
      <tags>
        <tag>swift</tag>
        <tag>algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Void]]></title>
    <url>%2F2019%2F03%2FVoid%2F</url>
    <content type="text"><![CDATA[Nothingness has been a regular topic of discussion on NSHipster, from our first article about nil in Objective-C to our recent look at the Never type in Swift. But today’s article is perhaps the most fraught with horror vacui of them all, as we gaze now into the Void of Swift. Clice 2 Origin VoidWhat is Void? In Swift, it’s nothing but an empty tuple. 1typealias Void = () We become aware of the Void as we fill it. 12let void: Void = ()void. // No Completions Void values have no members: no methods, no values, not even a name. It’s a something more nothing than nil. For an empty vessel, Xcode gives us nothing more than empty advice. Something for NothingPerhaps the most prominent and curious use of the Void type in the standard library is found in the ExpressibleByNilLiteral protocol. 123protocol ExpressibleByNilLiteral &#123; init(nilLiteral: ())&#125; Types conforming to ExpressibleByNilLiteral can be initialized with the nil literal. Most types don’t adopt this protocol, as it makes more sense to represent the absence of a specified value using an Optional for that type. But you may encounter it occasionally. The required initializer for ExpressibleByNilLiteral shouldn’t take any real argument. (If it did, what would that even be?) However, the requirement can’t just be an empty initializer init() — that’s already used as the default initializer for many types. You could try to work around this by changing the requirement to a type method that returned a nil instance, but some mandatory internal state may be inaccessible outside of an initializer. But a better solution — and the one used here — is to add a nilLiterallabel by way of a Void argument. It’s an ingenious use of existing functionality to achieve unconventional results. No Things Being EqualTuples, along with metatypes (like Int.Type, the result of calling Int.self), function types (like (String) -&gt; Bool) and existentials (like Encodable &amp; Decodable), comprise non-nominal types. In contrast to the nominal, or named, types that comprise most of Swift, non-nominal types are defined in relation to other types. Non-nominal types cannot be extended. Void is an empty tuple, and because tuples are non-nominal types, you can’t add methods or properties or conformance to protocols. 1extension Void &#123;&#125; // Non-nominal type 'Void' cannot be extended Void doesn’t conform to Equatable — it simply can’t. Yet when we invoke the “is equal to” operator (==), it works as expected. 1void == void // true We reconcile this apparent contradiction with a global free-function, declared outside of any formal protocol. 123func == (lhs: (), rhs: ()) -&gt; Bool &#123; return true&#125; This same treatment is given to the “is less than” operator (&lt;), which acts as a stand-in for the Comparable protocol and its derived comparison operators. 123func &lt; (lhs: (), rhs: ()) -&gt; Bool &#123; return false&#125; The Swift standard library provides implementations of the comparison functions for tuples with arity, or size, up to 6. This is, however, considered a hack. At various times, the Swift core team has expressed interest in adding formal Equatable conformance for tuples, but at the time of writing, no formal proposals are being discussed. Ghost in the ShellVoid, as a non-nominal type, can’t be extended. However, Void is still a type, and can, therefore, be used as a generic constraint. For example, consider this generic container for a single value: 123struct Wrapper&lt;Value&gt; &#123; let value: Value&#125; We can first take advantage of conditional conformance, arguably the killer feature in Swift 4.1, to extend Wrapper to adopt Equatable when it wraps a value that is itself Equatable. 12345extension Wrapper: Equatable where Value: Equatable &#123; static func ==(lhs: Wrapper&lt;Value&gt;, rhs: Wrapper&lt;Value&gt;) -&gt; Bool &#123; return lhs.value == rhs.value &#125;&#125; Using the same trick from before, we can approximate Equatable behavior by implementing a top-level == function that takes Wrapper&lt;Void&gt; arguments. 123func ==(lhs: Wrapper&lt;Void&gt;, rhs: Wrapper&lt;Void&gt;) -&gt; Bool &#123; return true&#125; In doing so, we can now successfully compare two constructed wrappers around Voidvalues. 1Wrapper(value: void) == Wrapper(value: void) // true However, if we attempt to assign such a wrapped value to a variable, the compiler generates a mysterious error. 123let wrapperOfVoid = Wrapper&lt;Void&gt;(value: void)// 👻 error: Couldn't apply expression side effects :// Couldn't dematerialize wrapperOfVoid: corresponding symbol wasn't found The horror of the Void becomes once again its own inverted retort. The Phantom TypeEven when you dare not speak its non-nominal name, there is no escaping Void. Any function declaration with no explicit return value implicitly returns Void 12345func doSomething() &#123; ... &#125;// Is equivalent tofunc doSomething() -&gt; Void &#123; ... &#125; This behavior is curious, but not particularly useful, and the compiler will generate a warning if you attempt to assign a variable to the result of a function that returns Void. 1234doSomething() // no warninglet result = doSomething()// ⚠️ Constant 'result' inferred to have type 'Void', which may be unexpected You can silence this warning by explicitly specifying the Void type. 1let result: Void = doSomething() // () By contrast, functions that return non-Void values generate warnings if you don’t assign their return value. For more details, see SE-0047 “Defaulting non-Void functions so they warn on unused results”. Trying to Return from the VoidIf you squint at Void? long enough, you might start to mistake it for Bool. These types are isometric, both having exactly two states: true / .some(()) and false / .none. But isometry doesn’t imply equivalence. The most glaring difference between the two is that Bool is ExpressibleByBooleanLiteral, whereas Void isn’t — and can’t be, for the same reasons that it’s not Equatable. So you can’t do this: 1(true as Void?) // error Void may be the spookiest type in Swift, but Bool gives it a run for its money when typealias’d to Booooooool 👻. But hard-pressed, Void? can act in the same way as Bool. Consider the following function that randomly throws an error: 1234567struct Failure: Error &#123;&#125;func failsRandomly() throws &#123; if Bool.random() &#123; throw Failure() &#125;&#125; The correct way to use this method is to call it within a do / catch block using a tryexpression. 123456do &#123; try failsRandomly() // executes on success&#125; catch &#123; // executes on failure&#125; The incorrect-but-ostensibly-valid way to do this would be to exploit the fact that failsRandomly() implicitly returns Void. The try? expression transforms the result of a statement that throws into an optional value, which in the case of failsRandomly(), results in Void?. If Void? has .some value (that is, != nil), that means the method returned without throwing an error. If success is nil, then we know that the method produced an error. 123456let success: Void? = try? failsRandomly()if success != nil &#123; // executes on success&#125; else &#123; // executes on failure&#125; As much as you may dislike the ceremony of do / catch blocks, you have to admit that they’re a lot prettier than what’s happening here. It’s a stretch, but this approach might be valid in very particular and peculiar situations. For example, you might use a static property on a class to lazily produce some kind of side effect exactly once using a self-evaluating closure: 123static var oneTimeSideEffect: Void? = &#123; return try? data.write(to: fileURL)&#125;() Even still, an Error or Bool value would probably be more appropriate. Things that go “Clang” in the NightIf, while reading this chilling account you start to shiver, you can channel the necrotic energy of the Void type to conjure immense amounts of heat to warm your spirits. …which is to say, the following code causes lldb-rpc-server to max out your CPU: 12345678910111213extension Optional: ExpressibleByBooleanLiteral where Wrapped == Void &#123; public typealias BooleanLiteralType = Bool public init(booleanLiteral value: Bool) &#123; if value &#123; self.init(())! &#125; else &#123; self.init(nilLiteral: ())! &#125; &#125;&#125;let pseudoBool: Void? = true // we never get to find out Keeping in the Lovecraft-ian tradition, Void has a physical form that the computer is incapable of processing; simply witnessing it renders the process incurably insane. A Hollow VictoryLet’s conclude our hallowed study of Void with a familiar refrain. 1234enum Result&lt;Value, Error&gt; &#123; case success(Value) case failure(Error)&#125; If you recall our article about the Never type, a Result type with its Error type set to Never can be used to represent operations that always succeed. In a similar way, we might use Void as the Value type to represent operations that, when they succeed, don’t produce any meaningful result. For example, apps may implement tell-tale heartbeat by regularly “pinging” a server with a simple network request. 123func ping(_ url: URL, completion: (Result&lt;Void, Error&gt;) -&gt; Void) &#123; // ...&#125; According to HTTP semantics, the correct status code for a hypothetical /ping endpoint would be 204 No Content. In the completion handler of the request, success would be indicated by the following call: 1completion(.success(())) Not enamored with effusive parentheticals (but why not?), you could make thing a bit nicer through a strategic extension on Result. 12345extension Result where Value == Void &#123; static var success: Result &#123; return .success(()) &#125;&#125; Nothing lost; nothing gained. 1completion(.success) Though it may seem like a purely academic exercise — philosophical, even. But an investigation into the Void yields deep insights into the very fabric of reality for the Swift programming language. In ancient times, long before Swift had seen the light of day, tuples played a fundamental role in the language. They represented argument lists and associated enumeration values, fluidly moving between its different contexts. At some point that model broke down. And the language has yet to reconcile the incongruities between these disparate constructs. So according to Swift Mythos, Void would be the paragon of the elder gods: the true singleton, blind nullary at the center of infinity unaware of its role or influence; the compiler unable to behold it. But perhaps this is all just an invention at the periphery of our understanding — a manifestation of our misgivings about the long-term viability of the language. After all, when you stare into the Void, the Void stares back into you.]]></content>
      <tags>
        <tag>swift</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Automatic Reference Counting (ARC)]]></title>
    <url>%2F2019%2F03%2FAutomatic-Reference-Counting-ARC%2F</url>
    <content type="text"><![CDATA[Swift too uses Automatic Reference Counting (ARC) to keep track and manage all the objects created by the application. This signifies that it handles Memory Management itself and we do not need to take care of it. But there are few situations where we as a developer need to provide few other information, in particularly, the relationship between objects, to avoid Memory Leaks. We would be discussing those situations here. Reference Counting applies only to the instances of the Class because it is Reference Type. This means that multiple objects can refer to the same object. Where as Structures and Enumerations are Value Types. Click 2 Origin Part 1How ARC works?Every time we create an instance of a Class, ARC allocates memory that holds information about the Type and Value it holds to. Whenever we assign a class instance to a constant or variable, that particluar constant or variable makes a strong reference to the instance and does not allow it to be deallocated as long as that strong reference exists. ARC keeps track of all the constants and variables currently it is referring to and will not deallocate until the last active reference is released. Once, all the active references are removed, ARC frees up the memory by removing the instance. This ensures that class instances do not take up unnecessary memory when not required. Let’s see with an Example: 1234567891011121314class Employee &#123; let empName: String init(employeeName empName: String) &#123; self.empName = empName print("\(empName) is being initialized") &#125; deinit &#123; print("\(empName) is being deinitialized") &#125;&#125;var emp1: Employee?var emp2: Employee?var emp3: Employee? In the above Class named Employee, we have an initialiser that sets the instance and prints a message to indicate that initialisation is in process. This also has a de-initialiser that prints out a message when an insance of the Class is deallocated. Now, let’s create Employee instance and assign it to the first variable emp1. 12emp1 = Employee(employeeName: "John Appleseed")// Prints "John Appleseed is being initialized" Now that Employee instance is assigned to the emp1. There is a strong reference from **emp1** to the new Employee instance and ARC ensures that this Employee is kept in memory and not deallocated. Retain Count has increased by 1. 12emp2 = emp1emp3 = emp1 Now, there are 3 strong references to Employee instance that we created at the beginning. The Retain Count would now be 3. Now, lets break 2 of these strong references (including the original reference) by assigning nil. The Retain Count would now be 1. Employee instance would not deallocate as there is still exisits 1 last strong reference (emp3).ARC would not deallocate the Employee instance until the 3rd and final strong reference is broken. 12emp1 = nil // Retain Count would decrease by 1emp2 = nil // Retain Count would decrease by 1 As soon as 3rd and final strong reference is set to nil, no further strong reference exisits. ARC is now free to remove the Employee instance from the Memory. Pretty Simple Huh!!. Lets dive deep in. 12emp3 = nil// Prints "John Appleseed is being deinitialized" What are Reference Cycles?There could be a scenario where two class instance holds a strong Reference to each other and there is no way for the system to deallocate them. This means that the Retain Count of both the class insance would never come down to 0. This is known as Strong Refernce Cycle. Let us see this with an example. 12345678910111213141516171819202122232425class Employee &#123; let empName: String var dept: Department? init(employeeName empName: String) &#123; self.empName = empName print("\(empName) is being initialized") &#125; deinit &#123; print("\(empName) is being deinitialized") &#125;&#125;class Department &#123; let deptName: String var emp: Employee? init(departmentName deptName: String) &#123; self.deptName = deptName print("\(deptName) is being initialized") &#125; deinit &#123; print("\(deptName) is being deinitialized") &#125;&#125; In the above code, we have created 2 class. One for Employee and other for Department. Both these classes have strong reference to Department(dept)and Employee(emp) instance respectively. The Retain Count for john and iOS variable would be 1. 1234var john: Employee? = Employee(employeeName: "john")var iOS: Department? = Department(departmentName: "iOS")// Prints "john is being initialized"// Prints "iOS is being initialized" We would create an Employee and Department instance. This in turn would create a strong reference to john and iOS variable (Image 1–1). Now assign the two instances together so that Employee is associated with Department and Department is linked to Employee. This would create a strong reference cycle among each other and the Retain Count for john and iOS variable would increase by 1. Retain Count for john and iOS variable is 2 (Image 1-2). 12john!.dept = iOSiOS!.emp = john If we set the john and iOS variable to nil , there would still exisits a strong reference between the Employee and Department instance which now cannot be broken. Retain Count now would be 1. Since, the Retain Count did not drop to 0, ARC did not deallocate the instances. Such scenarios causes memory leaks in our application (Image 1-3). How to Resolve these Reference Cycles?Swift provides two ways of resolving these Strong Reference Cycles: weakand unowned reference. Weak ReferenceApple Doc states that a weak reference is a reference that does not keep a strong hold on the instance it refers to, and so does not stop ARC from disposing of the referenced instance. This behavior prevents the reference from becoming part of a strong reference cycle. You indicate a weak reference by placing the weak keyword before a property or variable declaration. Weak Reference should be used in cases where other instance can be deallocated first without any issue. Confused!!! Let us see this with an example. Just add weak before emp variable in the Deparment Class. The class would look like the below. 123456789101112class Department &#123; let deptName: String weak var emp: Employee?init(departmentName deptName: String) &#123; self.deptName = deptName print("\(deptName) is being initialized") &#125; deinit &#123; print("\(deptName) is being deinitialized") &#125;&#125; Now, if we create instance variable of Employee and Deparment and assign these instances to each other, Employee instance would hold a strongreference to the Deparment but Department insatance would hold a weakreference to the Employee instance. Retain Count of Employee would be 1where as Retain Count of Department would be 2 (Image 1-4). 1234var john: Employee? = Employee(employeeName: "john")var iOS: Department? = Department(departmentName: "iOS")john!.dept = iOSiOS!.emp = john Since Employee instance has only one strong reference, as soon as we set the Employee instance to nil, the Retain Count would become 0 and it would be deallocated. Also, the emp variable of the Department would be set to nil reducing the Retain Count to 1(Image 1-5). 12john = nil// Prints "john is being deinitialized" Now, the only strong Reference left to the Deparment is from the iOSvariable. Setting nil to the iOS variable would reduce the Retain Count by 1, thus making it 0. Hence, ARC would deallocate the Department instance (Image 1-6). 12iOS = nil// Prints "iOS is being deinitialized" Unowned ReferenceUnowned reference too does not keep a strong hold on the instance it refers to. However, there is one major difference between Week and UnownedReference. It should only be used when we are sure that both the instance has almost same or more life span. A Weak references must be defined using optional whereas Unowned references must be defined using non-optionaltypes. Both do not increase the Retain Count. Lets see an example. Suppose we are creating an application for a car Company where they need to keep track of every vehicle sold to the People. We would have Vehicle and Driver Model class. In the following we have created 2 Class. Owner and Vehicle class. In this Owner may or may not Vehicle but Vehicle to come on Road would need to have a Owner . In such case, the Owner should hold a strong reference to the Vechicle but the Vehicle should just have a unowned reference to the Owner. This is because there is noVehicle which doen’t have an Owner . So, its existence only lies till the Owner owns the Vehicle. But the same doesn’t hold true for Owner. 123456789101112131415161718192021222324class Owner &#123; let ownerName: String var vehicle: Vehicle? init(ownerName name: String) &#123; self.ownerName = name print("\(ownerName) is being initialized") &#125; deinit &#123; print("\(ownerName) is being deinitialized") &#125;&#125;class Vehicle &#123; let vehicleNumber: String unowned let owner: Owner init(vehicleNumber number: String, owner: Owner) &#123; self.vehicleNumber = number self.owner = owner print("\(vehicleNumber) is being initialized") &#125; deinit &#123; print("\(vehicleNumber) is being deinitialized") &#125;&#125; Now, lets create the Owner and Vehicle instance and associate with each other. The Retain Count for the Owner instance is 1 which is held by variable. In case of Vehicle, its just the Owner who is holding the strong reference to it (Image 1–7). 12345var appleseed: Owner?appleseed = Owner(ownerName: "John Appleseed")appleseed?.vehicle = Vehicle(vehicleNumber: "TE 12 MP 5678", owner: appleseed!)// Prints "John Appleseed is being initialized"// Prints "TE 12 MP 5678 is being initialized" Its existence is only till the existence of the Owner. Once, the Owner instance is deallocated, the Vehicle instance would automatically be deallocated as there is no strong reference associated to it (Image 1–8, Image 1–9). 123appleseed = nil// Prints "John Appleseed is being deinitialized"// Prints "TE 12 MP 5678 is being deinitialized" Part 2In the First Part, you learned about some fundamental concepts of ARC such as weak, Unowned and how to resolve Reference Cycle using weak and unowned. In this final part, you’ll learn about one last scenario, where both the properties should have a value and neither property should ever be nilonce the initialization is complete. Also, you would learn how to overcome the Strong Reference Cycle in Closures. Let’s dive straight into it. Suppose we have a Country and President class. Each of these class stores an instance of the other class as a variable. This means that every Countryshould have a President and every President should be associated with a Country. To fulfil this requirement without causing a memory Leak, you would need to declare one property (In our case countryPresident in the Country Class) as an implicitly unwrapped optional Property. This can be done by placing the exclamation mark at the end of its type annotation(President!). While for the other, you would need to declare it as an unowned property (In our case country in the President Class). Suppose we have a Country and President class. Each of these class stores an instance of the other class as a variable. This means that every Countryshould have a President and every President should be associated with a Country. To fulfil this requirement without causing a memory Leak, you would need to declare one property (In our case countryPresident in the Country Class) as an implicitly unwrapped optional Property. This can be done by placing the exclamation mark at the end of its type annotation(President!). While for the other, you would need to declare it as an unowned property (In our case country in the President Class). 12345678910111213141516171819202122232425class Country &#123; let countryName: String var countryPresident: President! init(countryName: String, presidentName: String) &#123; self.countryName = countryName self.countryPresident = President(presidentName: presidentName, country: self) print("Country is being initialised") &#125; deinit &#123; print("Country is being de-initialised") &#125;&#125;class President &#123; let presidentName: String unowned let country: Country init(presidentName: String, country: Country) &#123; self.presidentName = presidentName self.country = country print("President is being initialised") &#125; deinit &#123; print("President is being de-initialised") &#125;&#125; Because countryPresident has a default nil value, a new Country instance is considered fully initialized as soon as the Country instance sets its countryName property within its initializer. This means that the Country initializer can start to reference and pass around the implicit self property as soon as the countryName property is set. The Country initializer can therefore pass self as one of the parameters for the President initializer when the Country initializer is setting its own countryPresident property. Doing so doesn’t create any strong Reference (Image 2–1). 123var country:Country? = Country(countryName: "India", presidentName: "Ram Nath Kovind")// Prints "President is being initialised"// Prints "Country is being initialised" Now, when the country is set to nil, president would also be automatically nullified (Image 2-2). 123country = nil// Prints "President is being de-initialised"// Prints "Country is being de-initialised" Try removing unowned from the President Class’s country property. Observe the leak caused when setting country as nil . Strong Reference Cycle in ClosuresA strong reference cycle can also occur if you assign a closure to a property of a class instance and the body of that closure captures the instance. This capture might occur because the closure’s body accesses a property of the instance, such as self.someProperty, or because the closure called a method on the instance, such as self.someMethod(). In either of the case, these access would cause the closure to “capture” self, creating a strong reference cycle. This strong reference cycle occurs because closures, like classes, are reference types. Lets see how this strong reference cycle is caused. Suppose you have a PersonClass with firstName, lastName property. You also have a lazy closure property which would return you a full name by combining firstName and lastName. Lets name it as fullName of type ()-&gt;String To know more about closure, you can read the Apple Documentation. The Person Class provides a single initializer, which takes a 2 argument (firstName and lastName). The class also defines a deinitializer, which prints a message to show when an Person instance is deallocated. 123456789101112131415class Person &#123; var firstName: String? var lastName: String? lazy var fullName: ()-&gt;String = &#123; return ("\(self.firstName!) \(self.lastName!)") &#125; init(firstName: String, lastName: String) &#123; self.firstName = firstName self.lastName = lastName print("Person Class is being initialised") &#125; deinit &#123; print("Person Class is being de-initialised") &#125;&#125; The person variable above is defined as an optional Person, so that it can be set to nil to demonstrate the presence of a strong reference cycle. The Person instance’s fullName property holds a strong reference to its closure. Also, because the closure refers to self within its body (as a way to reference self.firstName and self.lastName), the closure captures self . This means that it also holds a strong reference to the Person instance. As a result, strong reference cycle is created between the two (Image 2–3). Even though the closure refers to self multiple times, Swift ensures that it only captures one strong reference to the Person instance. 1234var person: Person? = Person(firstName: "Rahul", lastName: "Singh")// Prints "Person Class is being initialised"print(person!.fullName())// Prints "Rahul Singh" No message is logged while setting the person variable to nil . This shows that neither the Person instance nor its closure were deallocated. This is because of the Strong Reference Cycle created between the variable and closure (Image 2–4). 1person = nil How to resolve the Strong Reference between Class and Closure?To solve this problem, Swift has an elegent way called as Closure Capture List. You can define the capture list as a part of closure’s definition. A capture list defines a rule to use when capturing one or more reference types within the closure’s body. The way strong reference cycles between two class instances is resolved, ie, you declare each captured reference either to be a weak or unowned , likewise you can choose theses referneces depending on the relationships between the different parts of your code. Each item in a capture list is a pairing of the weak or unowned keyword with a reference to a class instance (such as self) or a variable initialized with some value (such as delegate = self.delegate!). These pairings are written within a pair of square braces, separated by commas. The implementation of Person Class remains same to the previous implementation, apart from the addition of a capture list within the fullName closure (Image 2–5). The capture list is [unowned self], which means “capture self as an unowned reference rather than a strong reference”. 1234567891011121314151617181920class Person &#123; var firstName: String? var lastName: String? lazy var fullName: ()-&gt; String = &#123;[unowned self] in return ("\(self.firstName!) \(self.lastName!)") &#125; init(firstName: String, lastName: String) &#123; self.firstName = firstName self.lastName = lastName print("Person Class is being initialised") &#125; deinit &#123; print("Person Class is being de-initialised") &#125;&#125;var person: Person? = Person(firstName: "Rahul", lastName: "Singh")// Prints "Person Class is being initialised"print(person!.fullName())// Prints "Rahul Singh" In contrast to earlier, this time setting person variable to nil would deallocate the Person Instance and print the desired message (Image 2-6). 12person = nil// Prints "Person Class is being de-initialised" Source: Apple Docs and of course Internet 😄 The Playground file can be found here. Feel free to play around with it. Now, poke in if we can use weak instead of unowned in the Closure of the Person Class? If yes, how can this be achieved? Hope you have liked my tutorial on Automatic Reference Counting. Do write your comments, if you enjoyed this post. I’d like to grow my readership. Can you help me out by sharing this blog post? LinkedIn Twitter Facebook]]></content>
      <tags>
        <tag>swift</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Write a function that add two numbers A and B]]></title>
    <url>%2F2019%2F02%2FWrite-a-function-that-add-two-numbers-A-and-B%2F</url>
    <content type="text"><![CDATA[Of course you can just return a + b to get accepted. But Can you challenge not do it like that?(You should not use + or any arithmetic operators.) I encountered such a problem when I did the algorithm question today. click me to vist Although it’s not too difficult, this question is quite interesting. ProblemDescriptionWrite a function that add two numbers A and B. Are a and b both 32-bit integers? Yes. Can I use bit operation? Sure you can. Sample12345678910111213Example 1: Input: a = 1, b = 2 Output: 3 Explanation: return the result of a + b.Example 2: Input: a = -1, b = 1 Output: 0 Explanation: return the result of a + b. challengeOf course you can just return a + b to get accepted. But Can you challenge not do it like that?(You should not use + or any arithmetic operators.) AnswerIf we can’t use + or any arithmetic operators, we can only use bit operation. So, we need to understand how the half adder works. Half adderThe half adder adds two single binary digits A and B. It has two outputs, sum (S) and carry (C). The carry signal represents an overflow into the next digit of a multi-digit addition. The value of the sum is 2C + S. The simplest half-adder design, pictured on the right, incorporates an XOR gate for S and an AND gate for C. Here is the Half adder in action: The Boolean logic for the sum (in this case S) will be A′B + AB′ whereas for the carry (C) will be AB. With the addition of an OR gate to combine their carry outputs, two half adders can be combined to make a full adder.[1] The half adder adds two input bits and generates a carry and sum, which are the two outputs of a half adder. The input variables of a half adder are called the augend and addend bits. The output variables are the sum and carry. The truth table for the half adder is: ConversionBefore beginning, let’s divide the decimal A=9 and B=7 into binary A=1001, B=0111. First calculate the number of digits (not carry): 1001 + 0111 = 1110The result is the same as A^B (A XOR B). Then get the carry. If 1001 + 0111 do the carry, the carry will occur only when 1 + 1 is there.So, how do we get the carry signal? 1 + 0, 0 + 0, 0 + 1 will not have a carry signal, it satisfies the truth table of phase and &amp;. We can also see directly from the inside of the half adder , S = A ^ B, C = A &amp; B. Plus the carry. We find that the carry signal appears at 1 + 1 (1&amp;1 = 1), and the previous bit needs to be entered. That is, C can be further expressed as C = (A &amp; B) &lt;&lt; 1. repeat and repeat. Since if the previous bit 0+1 plus the carry symbol 1, it will also be carried. It is necessary to repeat the above process continuously. CodeHere I will use the Swift. 1234567891011func aPlusB(_ a: Int,_ b: Int) -&gt; Int &#123; if (a == 0) &#123; return b &#125; else if (b == 0) &#123; return a &#125; else &#123; let x: Int = a ^ b let y: Int = (a &amp; b) &lt;&lt; 1 return aPlusB(x, y) &#125;&#125;]]></content>
      <tags>
        <tag>study</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[A Study Records]]></title>
    <url>%2F2019%2F02%2FA-Study-Records%2F</url>
    <content type="text"><![CDATA[I am gonna set a post of my learning schedule. 2019MarchThe 1st week Read the new features of Swift5 and review Swift4 Review the basic data structures and algorithms Re-learning the basic OS knowledge The 2nd week Continue to learn the advanced Swift Study software engineering basics knowledge HTTP: The Definitive Guide The 3rd week Continue to learn the advanced Swift Study Core Data HTTP: The Definitive Guide Learning the database basics]]></content>
      <tags>
        <tag>study</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[The Beauty of Swift 5 String Interpolation]]></title>
    <url>%2F2019%2F02%2FThe-Beauty-of-Swift-5-String-Interpolation%2F</url>
    <content type="text"><![CDATA[Thanks to SE-0228, you can control exactly how you want string interpolations to print. Thank you Brent for giving this to us. It’s a doozy! Let me share some examples… The Original Consider printing optionals. You use: 1"There's \(value1) and \(value2)" And get an instant warning: You can click the fixes to suppress the warning but you’ll still get an output that looks like this: “There’s Optional(23) and nil”. 1"There's \(String(describing: value1)) and \(String(describing: value2))" Now you can strip the “Optional” and produce “There’s 23 and nil”, allowing you to print values directly: 1234567891011121314extension String.StringInterpolation &#123; /// Provides `Optional` string interpolation without forcing the /// use of `String(describing:)`. public mutating func appendInterpolation(_ value: T?, default defaultValue: String) &#123; if let value = value &#123; appendInterpolation(value) &#125; else &#123; appendLiteral(defaultValue) &#125; &#125;&#125;// There's 23 and nil"There's \(value1, default: "nil") and \(value2, default: "nil")" You might create a set of styles and custom interpolation to support consistent presentation for optional output: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152extension String.StringInterpolation &#123; /// Optional Interpolation Styles public enum OptionalStyle &#123; /// Includes the word `Optional` for both `some` and `none` cases case descriptive /// Strips the word `Optional` for both `some` and `none` cases case stripped /// Uses system interpolation, which includes the word `Optional` for /// `some` cases but not `none`. case `default` &#125; /// Interpolates optional values using a supplied `optStyle` style public mutating func appendInterpolation(_ value: T?, optStyle style: String.StringInterpolation.OptionalStyle) &#123; switch style &#123; // Includes the word `Optional` for both `some` and `none` cases case .descriptive: if value == nil &#123; appendLiteral("Optional(nil)") &#125; else &#123; appendLiteral(String(describing: value)) &#125; // Strips the word `Optional` for both `some` and `none` cases case .stripped: if let value = value &#123; appendInterpolation(value) &#125; else &#123; appendLiteral("nil") &#125; // Uses system interpolation, which includes the word `Optional` for // `some` cases but not `none`. default: appendLiteral(String(describing: value)) &#125; &#125; /// Interpolates an optional using "stripped" interpolation, omitting /// the word "Optional" from both `.some` and `.none` cases public mutating func appendInterpolation(describing value: T?) &#123; appendInterpolation(value, optStyle: .stripped) &#125;&#125;// "There's Optional(23) and nil""There's \(value1, optStyle: .default) and \(value2, optStyle: .default)"// "There's Optional(23) and Optional(nil)""There's \(value1, optStyle: .descriptive) and \(value2, optStyle: .descriptive)"// "There's 23 and nil""There's \(describing: value1) and \(describing: value2)" Interpolation isn’t limited to tweaking optionals. Say you want to control whether a string is added without having to use a ternary expression with an empty string: 123456789101112131415// Include on success (Thanks, Nate Cook)extension String.StringInterpolation &#123; /// Provides Boolean-guided interpolation that succeeds only when the condition /// evaluates to true. mutating func appendInterpolation(if condition: @autoclosure () -&gt; Bool, _ literal: StringLiteralType) &#123; guard condition() else &#123; return &#125; appendLiteral(literal) &#125;&#125;// Old"Cheese Sandwich \(isStarred ? "(*)" : "")"// New"Cheese Sandwich \(if: isStarred, "(*)")" There’s lots more you can do and it’s all exciting and fun.]]></content>
      <tags>
        <tag>Swift</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Swift 5 新特性预览 (最低支持 Xcode 10.2 beta 版)]]></title>
    <url>%2F2019%2F02%2FSwift-5-%E6%96%B0%E7%89%B9%E6%80%A7%E9%A2%84%E8%A7%88-%E6%9C%80%E4%BD%8E%E6%94%AF%E6%8C%81-Xcode-10-2-beta-%E7%89%88%2F</url>
    <content type="text"><![CDATA[万众期待的 Swift 5 终于来了，苹果爸爸答应的 ABI 稳定也终于来了。 原文链接 App 瘦身新特性Swift 应用程序不再包含用于 Swift 标准库的动态链接库和用于运行 iOS 12.2，watchOS 5.2 和 tvOS 12.2 的设备的构建变体中的 Swift SDK overlays。因此，当为 TestFlight 进行测试部署时，或者在为本地开发分发瘦身应用的 archive 包时，Swift 应用程序可以更小。 要对比 iOS 12.2 和 iOS 12.1 (或更早版本) 瘦身后 App 的文件大小差异，可以设置 App 的 deployment target 为 iOS 12.1 或更早版本，设置 scheme set 为 Generic iOS Device 并生成一个 App 的归档。在构建完成后，在 Archives organizer 选择中 Distribute App，然后选择 Development distribution。确保在 App Thinning 下拉菜单中选择一个特定设备，如 iPhone XS。当分发完成后，在新创建的文件夹下打开 App Thinning Size Report。iOS 12.2 系统的变体将小于 iOS 12.1 及更早的系统的变体。确切的大小差异取决于您的 App 使用的系统框架的数量。 关于 App 瘦身更多的信息，可以查看 Xcode Help 中的 What is app thinning? 有关应用程序文件大小的信息，请参考 App Store Connect Help 中的 View builds and file sizes Swift 语言新特性 @dynamicCallable 允许您使用一个简单的语法糖像调用函数一样来调用命名类型。主要的应用场景是动态语言互操作。(SE-0216) 例如： 123456789101112@dynamicCallable struct ToyCallable &#123; func dynamicCall（withArguments：[Int]）&#123;&#125; func dynamicCall（withKeywordArguments：KeyValuePairs &lt;String，Int&gt;）&#123;&#125;&#125;let x = ToyCallable（）x（1,2,3）// 等价于`x.dynamicallyCall（withArguments：[1,2,3]）`x(label: 1, 2)// 等价于`x.dynamicallyCall(withKeywordArguments: ["label": 1, "": 2])` Key path 现在支持特性 (identity) keypath (\.self)，这是一个引用自身完整输入值的 WritableKeyPath。(SE-0227) 12345let id = \Int.selfvar x = 2print(x[keyPath: id]) // Prints "2"x[keyPath: id] = 3print(x[keyPath: id]) // Prints "3" 在 Swift 5 之前，您可以编写一个带有可变参数的枚举 case： 123456enum X &#123; case foo(bar: Int...) &#125;func baz() -&gt; X &#123; return .foo(bar: 0, 1, 2, 3) &#125; 之前不是特意要支持这个特性，而且现在这样写会报错了。 取而代之的是，让枚举的 case 携带一个数组，并显式传递一个数组 1234567enum X &#123; case foo(bar: [Int]) &#125; func baz() -&gt; X &#123; return .foo(bar: [0, 1, 2, 3]) &#125; 在 Swift 5 中，带有一个可选类型的表达式的 try? 将会展平生成的可选项，而不是返回嵌套的可选项。（SE-0230) 如果类型 T 符合 Initialized with Literals 中的其中一个协议（如 ExpressibleByIntegerLiteral），且 literal 是一个字面量表达示时，则 T(literal) 会使用相应的协议创建一个类型 T 的字面量，而不是使用一个协议的默认字面量类型的值来调用 T 的 initializer。 如，类似于 UInt64(0xffff_ffff_ffff_ffff) 这样的表达式现在是有效的，则之前会由于整型字面量的默认类型是 Int，而导致溢出。(SE-0213) 提高了字符串插值操作的性能、清晰性和效率。(SE-0228) 旧的 _ExpressibleByStringInterpolation 协议被删除；如果您有使用此协议的代码，则需要做相应更新。您可以使用 #if 条件判断来区分 Swift 4.2 和 Swift 5 的代码。例如： 12345#if compiler(&lt;5)extension MyType: _ExpressibleByStringInterpolation &#123; /*...*/ &#125;#elseextension MyType: ExpressibleByStringInterpolation &#123; /*...*/ &#125;#endif Swift 标准库新功能 DictionaryLiteral 类型重命名为 KeyValuePairs。(SE-0214) 桥接到 Objective-C 代码的 Swift 字符串现在可以在适当的时候从 CFStringGetCStringPtr 返回一个 non-nil 值，同时从 -UTF8String 返回的指针与字符串的生命周期相关联，而不是最相近的那个 autorelease pool。如果程序正确，那应该没有任何问题，并且会发现性能显著提高。但是，这也可能会让之前一些未经测试的代码运行，从而暴露一些潜在的问题；例如，如果有一个对 non-nil 值的判断，而相应分支在 Swift 5 之前却从未被执行过。(26236614) Sequence 协议不再具有 SubSequence 关联类型。先前返回 SubSequence 的 Sequence 方法现在会返回具体类型。例如，suffix(_:) 现在会返回一个 Array。(47323459) 使用 SubSequence 的 Sequence 扩展应该修改为类似地使用具体类型，或者修改为 Collection 的扩展，在 Collection 中 SubSequence 仍然可用。(45761817) 例如： 12345extension Sequence &#123; func dropTwo() -&gt; SubSequence &#123; return self.dropFirst(2) &#125;&#125; 需要改为： 12345extension Sequence &#123; func dropTwo() -&gt; DropFirstSequence&lt;Self&gt; &#123; return self.dropFirst(2) &#125;&#125; 或者是： 12345extension Collection &#123; func dropTwo() -&gt; SubSequence &#123; return self.dropFirst(2) &#125;&#125; String 结构的原生编码将从 UTF-16 切换到 UTF-8，与 String.UTF16View 相比，这会提高相关联的 String.UTF8View 的性能。重新对所有代码进行评审以提高性能，尤其是使用了 String.UTF16View 的代码。 Swift 包管理器新功能 现在，在使用 Swift 5 软件包管理器时，Targets 可以声明一些常用的针对特定目标的 build settings 设置。新设置也可以基于平台和构建配置进行条件化处理。包含的构建设置支持 Swift 和 C 语言定义，C 语言头文件搜索路径，链接库和链接框架。(SE-0238)(23270646) 在使用 Swift 5 软件包管理器时，package 现在可以自定义 Apple 平台的最低 deployment target。而如果 package A 依赖于 package B，但 package B 指定的最小 deployment target 高于 package A 的最小 deployment target，则构建 package A 时会抛出错误。(SE-0236)(28253354) 新的依赖镜像功能允许顶层包覆盖依赖 URL。(SE-0219)(42511642) 使用以下命令设置镜像： 12$ swift package config set-mirror \--package-url &lt;original URL&gt; --mirror-url &lt;mirror URL&gt; swift 测试命令可以使用标志 --enable-code-coverage，来生成标准格式的代码覆盖率数据，以便其它代码覆盖工具使用。生成的代码覆盖率数据存储在 &lt;build-dir&gt;/&lt;configuration&gt;/codecov 目录中。 Swift 5 不再支持 Swift 3 版本的软件包管理器。仍然在使用 Swift 3 Package.swift 工具版本（tool-version）上的软件包应该更新到新的工具版本上。 对体积较大的包进行包管理器操作现在明显更快了。 Swift 包管理器有一个新的 --disable-automatic-resolution 标志项，当 Package.resolved 条目不再与 Package.swift 清单文件中指定的依赖项版本兼容时，该标志项强制包解析失败。此功能对于持续集成系统非常有用，可以检查包的 Package.resolved 是否已过期。 swift run 命令有一个新的 --repl 选项，它会启动 Swift REPL，支持导入包的库目标。这使您可以轻松地从包目标中试用 API，而无需构建调用该 API 的可执行文件。 有关使用 Swift 包管理器的更多信息，请访问 swift.org 上的 Using the Package Manager。 Swift 编译器新特性 现在，在优化（-O 和 -Osize）构建中，默认情况下在运行时强制执行独占内存访问。违反排他性的程序将在运行时抛出带有 “重叠访问” 诊断消息错误。您可以使用命令行标志禁用此命令：-enforce-exclusivity = unchecked，但这样做可能会导致未定义的行为。运行时违反排他性通常是由于同时访问类属性，全局变量（包括顶层代码中的变量）或通过 eacaping 闭包捕获的变量。（SR-7139） Swift 3 运行模式已被删除。-swift-version 标志支持的值为 4、4.2 和 5。 在 Swift 5 中，在 switch 语句中使用 Objective-C 中声明的或来自系统框架的枚举时，必须处理未知的 case，这些 case 可能将来会添加，也可能是在 Objective-C 实现文件中私下定义。形式上，Objective-C 允许在枚举中存储任何值，只要它匹配底层类型即可。这些未知的 case 可以使用新的 @unknown default case 来处理，当然如果 switch 中省略了任何已知的 case，编译器仍然会给出警告。它们也可以使用普通的 default case 来处理。 如果您已在 Objective-C 中定义了自己的枚举，并且不需要客户端来处理 unknown case，则可以使用 NS_CLOSED_ENUM 宏而不是 NS_ENUM。Swift 编译器识别出这一点，并且不需求 switch 语句必须带有 default case。 在 Swift 4 和 4.2 模式下，您仍然可以使用 @unknown default。如果省略 @unknown default，而又传递了一个未知的值，则程序在运行时抛出异常，这与 Xcode 10.1 中的 Swift 4.2 上的行为是一致的。(SE-0192)(39367045) 现在在 SourceKit 生成的 Swift 模块接口中会打印默认参数，而不仅仅是使用占位符。 unowned 和 unowned(unsafe) 类型的变量现在支持可选类型。 已知的问题 如果引用了 UIAccessibility 结构的任何成员，则 Swift 编译器会在 “Merge swiftmodule” 构建步骤中崩溃。构建日志包含一条消息： 1234Cross-reference to module 'UIKit'... UIAccessibility... in an extension in module 'UIKit'... GuidedAccessError 包含 NS_ERROR_ENUM 枚举的其他类型也可能出现此问题，但 UIAccessibility 是最常见的。(47152185) 解决方法：在 target 的 Build Setting -&gt; Swift Compiler -&gt; Code Generation 下，设置 Compilation Mode 的值为 Whole Module。这是大多数 Release 配置的默认设置。 为了减小 Swift 元数据的大小，Swift 中定义的 convenience initializers 如果调用了 Objective-C 中定义的一个 designated initializer，那只会提前分配一个对象。在大多数情况下，这对您的程序没有影响，但如果从 Objective-C 调用 convenience initializers，那么 +alloc 分配的初始内存会被释放，而不会调用任何 initializer。对于不希望发生任何类型的对象替换的调用者来说，这可能是有问题的。其中一个例子是 initWithCoder: ：如果 NSKeyedUnarchiver 调用 Swift 实现 init(coder:) 并且存档对象存在循环时，则 NSKeyedUnarchiver 的实现可能会出错。 在将来的版本中，编译器将保证一个 convenience initializer 永远不会丢弃它所调用的对象，只要它通过 self.init 委托给它的初始化程序也暴露给 Objective-C，或者是它在 Objective-C 中定义了，或者是使用 @objc 标记的，或者是重写了一个暴露给 Objective-C 的 initializer，或者是它满足 @objc 协议的要求。(46823518) 如果一个 keypath 字面量引用了 Objective-C 中定义的属性，或者是在 Swift 中使用 @objc 和 dynamic 修饰符定义的属性，则编译可能会失败，并且报 “unsupported relocation of local symbol &#39;L_selector&#39;” 错误，或者 key path 字面量无法在运行时生成正确的哈希值或处理相等比较。 解决方法：您可以定义一个不是 @objc 修饰的包装属性，来引用这个 key path。得到的 key path 与引用原始 Objective-C 属性的 key path 不相等，但使用包装属性效果是相同的。 某些项目可能会遇到以前版本的编译时回归。 Swift 命令行项目在启动时因抛出 “dyld：Library not loaded” 错误而崩溃。 解决方法：添加自定义的构建设置 SWIFT_FORCE_STATIC_LINK_STDLIB=YES。 已解决的问题 扩展绑定现在支持嵌套类型的扩展，这些嵌套类型本身是在扩展内定义的。之前可能会因为一些声明顺序而失败，并产生 “未声明类型” 错误。(SR-631) 在 Swift 5 中，返回 Self 的类方法不能再被使用返回非 final 的具体类类型的方法来覆盖。此类代码不是类型安全的，需要更新。(SR-695) 例如： 1234567class Base &#123; class func factory() -&gt; Self &#123; /*...*/ &#125;&#125; class Derived: Base &#123; class override func factory() -&gt; Derived &#123; /*...*/ &#125; &#125; 在 Swift 5 模式下，现在会明确禁止声明与嵌套类型同名的静态属性。以前，可以在泛型类型的扩展中执行这样的声明。(SR-7251) 例如： 123456789struct Foo&lt;T&gt; &#123;&#125;extension Foo &#123; struct i &#123;&#125; // Error: Invalid redeclaration of 'i'. // (Prior to Swift 5, this didn’t produce an error.) static var i: Int &#123; return 0 &#125;&#125; 现在可以在子类里继承父类中具有可变参数的初始化方法。 在 Swift 5 中，函数中的 @autoclosure 参数不能再作为 @autoclosure 参数传递到另一个函数中调用。相反，您必须使用括号显式调用函数值:()；调用本身包含在一个隐式闭包中，保证了与 Swift 4 相同的行为。（SR-5719） 例如： 12345func foo(_ fn: @autoclosure () -&gt; Int) &#123;&#125;func bar(_ fn: @autoclosure () -&gt; Int) &#123; foo(fn) // Incorrect, `fn` can’t be forwarded and has to be called. foo(fn()) // OK&#125; 现在完全支持在类和泛型中定义复杂的递归类型，而此前可能会导致死锁。 在 Swift 5 中，当将可选值转换为泛型占位符类型时，编译器在解包值时会更加谨慎。这种转换的结果现在更接近于非泛型上下文中的结果。(SR-4248) 例如： 1234567891011func forceCast&lt;U&gt;(_ value: Any?, to type: U.Type) -&gt; U &#123; return value as! U &#125; let value: Any? = 42print(forceCast(value, to: Any.self))// Prints "Optional(42)"// (Prior to Swift 5, this would print "42".)print(value as! Any)// Prints "Optional(42)" 协议现在可以将它们的实现类型限定为指定类型的子类。支持两种等效形式： 12protocol MyView: UIView &#123; /*...*/ &#125;protocol MyView where Self: UIView &#123; /*...*/ &#125; Swift 4.2 接受了第二种形式，但没有完全实现，有时可能在编译时或运行时崩溃。(SR-5581) 在 Swift 5 中，当在属性自身的 didSet 或 willSet 中设置属性本身时，会避免递归调用（不论是隐式或显式地设置自身的属性）。(SR-419) 例如： 12345678910111213141516171819class Node &#123; var children = [Node]() var depth: Int = 0 &#123; didSet &#123; if depth &lt; 0 &#123; // Won’t recursively call didSet, because this is setting depth on self. depth = 0 &#125; // Will call didSet for each of the children, // as this isn’t setting the property on self. // (Prior to Swift 5, this didn’t trigger property // observers to be called again.) for child in children &#123; child.depth = depth + 1 &#125; &#125; &#125;&#125; Xcode 中 的 diagnostics 对 #sourceLocation 进行了支持。也就是说，如果您使用#sourceLocation 将生成的文件中的行映射回源代码时，diagnostics 会显示在原始源文件中的行数而不是生成的文件中的。 使用泛型类型别名作为参数或 @objc 方法的返回类型，不再导致生成无效的 Objective-C header。(SR-8697)]]></content>
      <tags>
        <tag>Swift</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[What is SwiftSyntax?]]></title>
    <url>%2F2019%2F02%2FWhat-is-SwiftSyntax%2F</url>
    <content type="text"><![CDATA[SwiftSyntax is a Swift library that lets you parse, analyze, generate, and transform Swift source code. It’s based on the libSyntax library, and was spun out from the main Swift language repository in August 2017. Together, the goal of these projects is to provide safe, correct, and intuitive facilities for structured editing, which is described thusly: What is structured editing? It’s an editing strategy that is keenly aware of the structure of source code, not necessarily its representation (i.e. characters or bytes). This can be achieved at different granularities: replacing an identifier, changing a call to global function to a method call, or indenting and formatting an entire source file based on declarative rules. At the time of writing, SwiftSyntax is still in development and subject to API changes. But you can start using it today to work with Swift source code in a programmatic way. It’s currently used by the Swift Migrator, and there are ongoing efforts to adopt the tool, both internally and externally. How Does It Work?To understand how SwiftSyntax works, let’s take a step back and look at the Swift compiler architecture: The Swift compiler is primarily responsible for turning Swift code into executable machine code. The process is divided up into several discrete steps, starting with the parser, which generates an abstract syntax tree, (AST). From there, semantic analysis is performed on the syntax to produce a type-checked AST, which lowered into Swift Intermediate Language; the SILis transformed and optimized and itself lowered into LLVM IR, which is ultimately compiled into machine code. The most important takeaway for our discussion is that SwiftSyntax operates on the AST generated at the first step of the compilation process. As such, it can’t tell you any semantic or type information about code. Contrast this with something like SourceKit, which operates with a much more complete understanding of Swift code. This additional information can be helpful for implementing editor features like code-completion or navigating across files. But there are plenty of important use cases that can be satisfied on a purely syntactic level, such as code formatting and syntax highlighting. Demystifying the ASTAbstract syntax trees can be difficult to understand in the abstract. So let’s generate one and see what it looks like. Consider the following single-line Swift file, which declares a function named one() that returns the value 1: 1func one() -&gt; Int &#123; return 1 &#125; Run the swiftc command on this file passing the -frontend -emit-syntaxarguments: 1$ xcrun swiftc -frontend -emit-syntax ./One.swift The result is a chunk of JSON representing the AST. Its structure becomes much clearer once you reformat the JSON: 123456789101112131415161718192021222324252627&#123; "kind": "SourceFile", "layout": [&#123; "kind": "CodeBlockItemList", "layout": [&#123; "kind": "CodeBlockItem", "layout": [&#123; "kind": "FunctionDecl", "layout": [null, null, &#123; "tokenKind": &#123; "kind": "kw_func" &#125;, "leadingTrivia": [], "trailingTrivia": [&#123; "kind": "Space", "value": 1 &#125;], "presence": "Present" &#125;, &#123; "tokenKind": &#123; "kind": "identifier", "text": "one" &#125;, "leadingTrivia": [], "trailingTrivia": [], "presence": "Present" &#125;, ... The Python json.tool module offers a convenient way to format JSON. It comes standard in macOS releases going back as far as anyone can recall. For example, here’s how you could use it with the redirected compiler output: 1$ xcrun swiftc -frontend -emit-syntax ./One.swift | python -m json.tool At the top-level, we have a SourceFile consisting of CodeBlockItemListelements and their constituent CodeBlockItem parts. This example has a single CodeBlockItem for the function declaration (FunctionDecl), which itself comprises subcomponents including a function signature, parameter clause, and return clause. The term trivia is used to describe anything that isn’t syntactically meaningful, like whitespace. Each token can have one or more pieces of leading and trailing trivia. For example, the space after the Int in the return clause (-&gt; Int) is represented by the following piece of trailing trivia. 1234&#123; "kind": "Space", "value": 1&#125; Working Around File System ConstraintsSwiftSyntax generates abstract syntax trees by delegating system calls to swiftc. However, this requires code to be associated with a file in order to be processed, and it’s often useful to work with code as a string. One way to work around this constraint is to write code to a temporary file and pass that to the compiler. We’ve written about temporary files in the past, but nowadays, there’s a much nicer API for working with them that’s provided by the Swift Package Manager itself. In your Package.swift file, add the following package dependency, and add the &quot;Utility&quot; dependency to the appropriate target: 1.package(url: &quot;https://github.com/apple/swift-package-manager.git&quot;, from: &quot;0.3.0&quot;), Now, you can import the Basic module and use its TemporaryFile API like so: 1234567891011import Basicimport Foundationlet code: Stringlet tempfile = try TemporaryFile(deleteOnClose: true)defer &#123; tempfile.fileHandle.closeFile() &#125;tempfile.fileHandle.write(code.data(using: .utf8)!)let url = URL(fileURLWithPath: tempfile.path.asString)let sourceFile = try SyntaxTreeParser.parse(url) What Can You Do With It?Now that we have a reasonable idea of how SwiftSyntax works, let’s talk about some of the ways that you can use it! Writing Swift Code: The Hard WayThe first and least compelling use case for SwiftSyntax is to make writing Swift code an order of magnitude more difficult. SwiftSyntax, by way of its SyntaxFactory APIs, allows you to generate entirely new Swift code from scratch. Unfortunately, doing this programmatically isn’t exactly a walk in the park. For example, consider the following code: 1234567891011121314151617181920import SwiftSyntaxlet structKeyword = SyntaxFactory.makeStructKeyword(trailingTrivia: .spaces(1))let identifier = SyntaxFactory.makeIdentifier("Example", trailingTrivia: .spaces(1))let leftBrace = SyntaxFactory.makeLeftBraceToken()let rightBrace = SyntaxFactory.makeRightBraceToken(leadingTrivia: .newlines(1))let members = MemberDeclBlockSyntax &#123; builder in builder.useLeftBrace(leftBrace) builder.useRightBrace(rightBrace)&#125;let structureDeclaration = StructDeclSyntax &#123; builder in builder.useStructKeyword(structKeyword) builder.useIdentifier(identifier) builder.useMembers(members)&#125;print(structureDeclaration) Whew. So what did all of that effort get us? 12struct Example &#123;&#125; Oofa doofa. This certainly isn’t going to replace GYB for everyday code generation purposes. (In fact, libSyntax and SwiftSyntax both make extensive use of gybto generate its interfaces.) But this interface can be quite useful when precision matters. For instance, you might use SwiftSyntax to implement a fuzzer for the Swift compiler, using it to randomly generate arbitrarily-complex-but-ostensibly-valid programs to stress test its internals. Rewriting Swift CodeThe example provided in the SwiftSyntax README shows how to write a program to take each integer literal in a source file and increment its value by one. Looking at that, you can already extrapolate out to how this might be used to create a canonical swift-format tool. But for the moment, let’s consider a considerably less productive — and more seasonally appropriate (🎃) — use of source rewriting: 1234567891011import SwiftSyntaxpublic class ZalgoRewriter: SyntaxRewriter &#123; public override func visit(_ token: TokenSyntax) -&gt; Syntax &#123; guard case let .stringLiteral(text) = token.tokenKind else &#123; return token &#125; return token.withKind(.stringLiteral(zalgo(text))) &#125;&#125; What’s that zalgo function all about? You’re probably better off not knowing… Anyway, running this rewriter on your source code transforms all string literals in the following manner: 12345// Before 👋😄print("Hello, world!")// After 🦑😵print("H͞͏̟̂ͩel̵ͬ͆͜ĺ͎̪̣͠ơ̡̼͓̋͝, w͎̽̇ͪ͢ǒ̩͔̲̕͝r̷̡̠͓̉͂l̘̳̆ͯ̊d!") Spooky, right? Highting Swift CodeLet’s conclude our look at SwiftSyntax with something that’s actually useful: a Swift syntax highlighter. A syntax highlighter, in this sense, describes any tool that takes source code and formats it in a way that’s more suitable for display in HTML. NSHipster is built on top of Jekyll, and uses the Ruby library Rouge to colorize the example code you see in every article. However, due to Swift’s relatively complex syntax and rapid evolution, the generated HTML isn’t always 100% correct. Instead of messing with a pile of regular expressions, we could instead build a syntax highlighter that leverages SwiftSyntax’s superior understanding of the language. At its core, the implementation is rather straightforward: implement a subclass of SyntaxRewriter and override the visit(_:) method that’s called for each token as a source file is traversed. By switching over each of the different kinds of tokens, you can map them to the HTML markup for theircorresponding highlighter tokens. For example, numeric literals are represented with &lt;span&gt; elements whose class name begins with the letter m (mf for floating-point, mi for integer, etc.). Here’s the corresponding code in our SyntaxRewriter subclass: 12345678910111213141516171819202122232425262728import SwiftSyntaxclass SwiftSyntaxHighlighter: SyntaxRewriter &#123; var html: String = "" override func visit(_ token: TokenSyntax) -&gt; Syntax &#123; switch token.tokenKind &#123; // ... case .floatingLiteral(let string): html += "&lt;span class=\"mf\"&gt;\(string)&lt;/span&gt;" case .integerLiteral(let string): if string.hasPrefix("0b") &#123; html += "&lt;span class=\"mb\"&gt;\(string)&lt;/span&gt;" &#125; else if string.hasPrefix("0o") &#123; html += "&lt;span class=\"mo\"&gt;\(string)&lt;/span&gt;" &#125; else if string.hasPrefix("0x") &#123; html += "&lt;span class=\"mh\"&gt;\(string)&lt;/span&gt;" &#125; else &#123; html += "&lt;span class=\"mi\"&gt;\(string)&lt;/span&gt;" &#125; // ... default: break &#125; return token &#125;&#125; Although SyntaxRewriter has specialized visit(_:) methods for each of the different kinds of syntax elements, I found it easier to handle everything in a single switch statement. (Printing unhandled tokens in the default branch was a really helpful way to find any cases that I wasn’t already handling). It’s not the most elegant of implementations, but it was a convenient place to start given my limited understanding of the library. Anyway, after a few hours of development, I was able to generate reasonable colorized output for a wide range of Swift syntactic features: 12345678910111213141516171819202122import Foundation#if os(macOS)class Class: NSObject &#123; pravate static let message = """ Hello, world! """ @obj var storedProperty: Int = 0 override init() &#123; self.storeProperty = 0b10101010 super.init() &#125; func printSelectorAndKeyPath() &#123; print(#selector(emptyFunction)) print(#keyPath(storedProperty)) &#125; @objc func emptyFunction() &#123;&#125;&#125;#endif The project comes with a library and a command line tool. Go ahead and try it out and let me know what you think! Reference Click me to visit]]></content>
      <tags>
        <tag>Swift</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[I Wish you a Merry Christmas Pt.2]]></title>
    <url>%2F2018%2F12%2FI-wish-you-a-Merry-Christmas-Pt-2%2F</url>
    <content type="text"><![CDATA[圣诞节快乐ε٩(๑&gt; ₃ &lt;)۶з～ 圣诞季又到了，好久都没写过中文文章了～ 年末总结今年不太顺利，虽然专业调配到了想去的专业，实验室招新宣讲也圆满完成了。但总是觉得很烦，感觉很迷茫。女朋友找了一年都还没找到。其实与其说没找到，其实是根本没去找….. 一转眼就大二了，还有一年就要去实习了，大佬们都可以去参加Google大二暑假的实习生了我是不可能了，我太菜了，真羡慕他们 这一年做了ColorPicker，ARImageRecognition,QQPluginForMac,TodayW等小玩意，跟着大佬混了一两个小奖，但是明显感受到了压力，可能后面会学习一些后端的知识。 学业上有了抵触情绪，我不太理解一些科目安排的必要性，所以只是想混及格就完事，烦来烦去，马上有临近期末，搞得最近是越来越烦。希望未来可以越来越好。 圣诞礼物唔，今年的圣诞礼物么，一首歌吧]]></content>
      <tags>
        <tag>Daily</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[macOS Dynamic Desktop]]></title>
    <url>%2F2018%2F11%2Fmac%E2%80%8BOS-Dynamic-Desktop%2F</url>
    <content type="text"><![CDATA[Dark Mode is one of the most popular additions to macOS — especially among us developer types, who tend towards light-on-dark color themes in text editors and appreciate this new visual consistency across the system.A couple of years back, there was similar fanfare for Night Shift, which helped to reduce eye strain from hacking late into the night (or early in the morning, as it were).If you triangulate from those two macOS features, you get Dynamic Desktops, also new in Mojave. Now when you go to “System Preferences&gt; Desktop &amp; Screen Saver”, you have the option to select a “Dynamic” desktop picture that changes throughout the day, based on your location. The result is subtle and delightful. Having a background that tracks the passage of time makes the desktop feel alive; in tune with the natural world. (If nothing else, it makes for a lovely visual effect when switching dark mode on and off) But how does it work, exactly?That’s the question for this week’s NSHipster article. The answer involves a deep dive into image formats, a little bit of reverse-engineering and even some spherical trigonometry. The first step to understanding how Dynamic Desktop works is to get hold of a dynamic image. If you’re running macOS Mojave open Finder, select “Go&gt; Go to Folder…” (⇧⌘G), and enter “/Library/Desktop Pictures/”. In this directory, you should find a file named “Mojave.heic”. Double-click it to open it in Preview. In Preview, the sidebar shows a list of thumbnails numbered 1 through 16, each showing a different view of the desert scene. If we select “Tools&gt; Show Inspector” (⌘I), we get some general information about what we’re looking at: Unfortunately, that’s about all Preview gives us (at least at the time of writing). If we click on the next panel over, “More Info Inspector”, we don’t learn a whole lot more about our subject: Color Model RGB Depth: 8 Pixel Height 2,880 Pixel Width 5,120 Profile Name Display P3 The .heic file extension corresponds to image containers encoded using the HEIF, or High-Efficiency Image File Format (which is itself based on HEVC, or High-Efficiency Video Compression — also known as H.265 video). For more information, check out WWDC 2017 Session 503 “Introducing HEIF and HEVC” If we want to learn more, we’ll need to roll up our sleeves and get our hands dirty with some low-level APIs. Digging Deeper with CoreGraphicsLet’s start our investigation by creating a new Xcode Playground. For simplicity, we can hard-code a URL to the “Mojave.heic” file on our system. 12345import Foundationimport CoreGraphics// macOS 10.14 Mojave Requiredlet url = URL(fileURLWithPath: "/Library/Desktop Pictures/Mojave.heic") Next, create a CGImageSource, copy its metadata, and enumerate over each of its tags: 123456789101112let source = CGImageSourceCreateWithURL(url as CFURL, nil)!let metadata = CGImageSourceCopyMetadataAtIndex(source, 0, nil)!let tags = CGImageMetadataCopyTags(metadata) as! [CGImageMetadataTag]for tag in tags &#123; guard let name = CGImageMetadataTagCopyName(tag), let value = CGImageMetadataTagCopyValue(tag) else &#123; continue &#125; print(name, value)&#125; When we run this code, we get two results: hasXMP, which has a value of &quot;True&quot;, and solar, which has a decidedly less understandable value: 123456789101112131415YnBsaXN0MDDRAQJSc2mvEBADDBAUGBwgJCgsMDQ4PEFF1AQFBgcICQoLUWlRelFhUW8QACNAcO7vOubr3yO/1e+pmkOtXBAB1AQFBgcNDg8LEAEjQFRxqCKOFiAjwCR6waUkDgHUBAUGBxESEwsQAiNAVZV4BI4c+CPAEP2uFrMcrdQEBQYHFRYXCxADI0BWtALKmrjwIz/2ObLnx6l21AQFBgcZGhsLEAQjQFfTrJlEjnwjQByrLle1Q0rUBAUGBx0eHwsQBSNAWPrrmI0ISCNAKiwhpSRpc9QEBQYHISIjCxAGI0BgJff9KDpyI0BENTOsilht1AQFBgclJicLEAcjQGbHdYIVQKojQEq3fAg86lXUBAUGBykqKwsQCCNAbTGmpC2YRiNAQ2WFOZGjntQEBQYHLS4vCxAJI0BwXfII2B+SI0AmLcjfuC7g1AQFBgcxMjMLEAojQHCnF6YrsxcjQBS9AVBLTq3UBAUGBzU2NwsQCyNAcTcSnimmjCPAGP5E0ASXJtQEBQYHOTo7CxAMI0BxgSADjxK2I8AoalieOTyE1AQFBgc9Pj9AEA0jQHNWsnnMcWIjwEO+oq1pXr8QANQEBQYHQkNEQBAOI0ABZpkFpAcAI8BKYGg/VvMf1AQFBgdGR0hAEA8jQErBKblRzPgjwEMGElBIUO0ACAALAA4AIQAqACwALgAwADIANAA9AEYASABRAFMAXABlAG4AcAB5AIIAiwCNAJYAnwCoAKoAswC8AMUAxwDQANkA4gDkAO0A9gD/AQEBCgETARwBHgEnATABOQE7AUQBTQFWAVgBYQFqAXMBdQF+AYcBkAGSAZsBpAGtAa8BuAHBAcMBzAHOAdcB4AHpAesB9AAAAAAAAAIBAAAAAAAAAEkAAAAAAAAAAAAAAAAAAAH9 Shining Light on SolarMost of us would look at that wall of text and quietly close the lid of our MacBook Pro. But, as some of you surely noticed, this text looks an awful lot like it’s Base64-encoded. Let’s test out our hypothesis in code: 1234if name == "solar" &#123; let data = Data(base64Encoded: value)! print(String(data: data, encoding: .ascii))&#125; bplist00Ò\u{01}\u{02}\u{03}... What’s that? bplist, followed by a bunch of garbled nonsense? By golly, that’s the file signature for a binary property list. Let’s see if PropertyListSerialization can make any sense of it… 12345678if name == "solar" &#123; let data = Data(base64Encoded: value)! let propertyList = try PropertyListSerialization .propertyList(from: data, options: [], format: nil) print(propertyList)&#125; Now we’re talking! We have two top-level keys: The ap key corresponds to a dictionary containing integers for the d and l keys. The si key corresponds to an array of dictionaries with integer and floating-point values. Of the nested dictionary keys, i is the easiest to understand: incrementing from 0 to 15, they’re the index of the image in the sequence. It’d be hard to guess a and z without any additional information, but they turn out to represent the altitude (a) and azimuth (z) of the sun in the corresponding pictures. Calculating Solar PositionAt the time of writing, those of us in the northern hemisphere are settling into the season of autumn and its shorter, colder days, whereas those of us in the southern hemisphere are gearing up for hotter and longer days. The changing of the seasons reminds us that the duration of a solar day depends where you are on the planet and where the planet is in its orbit around the sun. The good news is that astronomers can tell you — with perfect accuracy — where the sun is in the sky for any location or time. The bad news is that the necessary calculations are complicated to say the least. Honestly, we don’t really understand it ourselves, and are pretty much just porting whatever code we manage to find online. After some trial and error, we were able to arrive at something that seems to work (PRs welcome!): 12345678910111213import Foundationimport CoreLocation// Apple Park, Cupertino, CAlet location = CLLocation(latitude: 37.3327, longitude: -122.0053)let time = Date()let position = solarPosition(for: location, at: time)let formattedDate = DateFormatter.localizedString(from: time, dateStyle: .medium, timeStyle: .short)print("Solar Position on \(formattedDate)")print("\(position.azimuth)° Az / \(position.elevation)° El") Solar Position on Oct 1, 2018 at 12:00 180.73470025840783° Az / 49.27482549913847° El At noon on October 1, 2018, the sun shines on Apple Park from the south, about halfway between the horizon and directly overhead. If track the position of the sun over an entire day, we get a sinusoidal shape reminiscent of the Apple Watch “Solar” face. Extending Our Understanding of XMPAlright, enough astronomy for the moment. Let’s ground ourselves in something much more banal:de facto XML metadata standards. Remember the hasXMP metadata key from before? Yeah, that. XMP, or Extensible Metadata Platform, is a standard format for tagging files with metadata. What does XMP look like? Brace yourself: 123let xmpData = CGImageMetadataCreateXMPData(metadata, nil)let xmp = String(data: xmpData as! Data, encoding: .utf8)!print(xmp) Yuck. But it’s a good thing that we checked. We’ll need to honor that apple_desktop namespace to make our own Dynamic Desktop images work correctly. Speaking of, let’s get started on that. Creating Our Own Dynamic DesktopLet’s create a data model to represent a Dynamic Desktop: 1234567891011121314151617181920struct DynamicDesktop &#123; let images: [Image] struct Image &#123; let cgImage: CGImage let metadata: Metadata struct Metadata: Codable &#123; let index: Int let altitude: Double let azimuth: Double private enum CodingKeys: String, CodingKey &#123; case index = "i" case altitude = "a" case azimuth = "z" &#125; &#125; &#125;&#125; Each Dynamic Desktop comprises an ordered sequence of images, each of which has image data, stored in a CGImage object, and metadata, as discussed before. We adopt Codable in the Metadatadeclaration in order for the compiler to automatically synthesize conformance. We’ll take advantage of that when it comes time to generate the Base64-encoded binary property list. Writing to an Image DestinationFirst, create a CGImageDestination with a specified output URL. The file type is heic and the source count is equal to the number of images to be included. 123456789guard let imageDestination = CGImageDestinationCreateWithURL( outputURL as CFURL, AVFileType.heic as CFString, dynamicDesktop.images.count, nil )else &#123; fatalError("Error creating image destination")&#125; Next, enumerate over each image in the dynamic desktop object. By using the enumerated() method, we also get the current index for each loop so that we can set the image metadata on the first image: 123456789101112131415161718192021222324252627for (index, image) in dynamicDesktop.images.enumerated() &#123; if index == 0 &#123; let imageMetadata = CGImageMetadataCreateMutable() guard let tag = CGImageMetadataTagCreate( "http://ns.apple.com/namespace/1.0/" as CFString, "apple_desktop" as CFString, "solar" as CFString, .string, try! dynamicDesktop.base64EncodedMetadata() as CFString ), CGImageMetadataSetTagWithPath( imageMetadata, nil, "xmp:solar" as CFString, tag ) else &#123; fatalError("Error creating image metadata") &#125; CGImageDestinationAddImageAndMetadata(imageDestination, image.cgImage, imageMetadata, nil) &#125; else &#123; CGImageDestinationAddImage(imageDestination, image.cgImage, nil) &#125;&#125; Aside from the unrefined nature of Core Graphics APIs, the code is pretty straightforward. The only part that requires further explanation is the call to CGImageMetadataTagCreate(_:_:_:_:_:). Because of a mismatch between how image and container metadata are structured and how they’re represented in code, we have to implement Encodable for DynamicDesktop ourselves: 12345678910111213141516171819202122232425262728extension DynamicDesktop: Encodable &#123; private enum CodingKeys: String, CodingKey &#123; case ap, si &#125; private enum NestedCodingKeys: String, CodingKey &#123; case d, l &#125; func encode(to encoder: Encoder) throws &#123; var keyedContainer = encoder.container(keyedBy: CodingKeys.self) var nestedKeyedContainer = keyedContainer.nestedContainer(keyedBy: NestedCodingKeys.self, forKey: .ap) // FIXME: Not sure what `l` and `d` keys indicate try nestedKeyedContainer.encode(0, forKey: .l) try nestedKeyedContainer.encode(self.images.count, forKey: .d) var unkeyedContainer = keyedContainer.nestedUnkeyedContainer(forKey: .si) for image in self.images &#123; try unkeyedContainer.encode(image.metadata) &#125; &#125;&#125; With that in place, we can implement the aforementioned base64EncodedMetadata() method like so: 123456789extension DynamicDesktop &#123; func base64EncodedMetadata() throws -&gt; String &#123; let encoder = PropertyListEncoder() encoder.outputFormat = .binary let binaryPropertyListData = try encoder.encode(self) return binaryPropertyListData.base64EncodedString() &#125;&#125; Once the for-in loop is exhausted, and all images and metadata are written, we call CGImageDestinationFinalize(_:) to finalize the image source and write the image to disk. 123guard CGImageDestinationFinalize(imageDestination) else &#123; fatalError("Error finalizing image")&#125; If everything worked as expected, you should now be the proud owner of a brand new Dynamic Desktop. Nice! We love the Dynamic Desktop feature in Mojave, and are excited to see the same proliferation of them that we saw when wallpapers hit the mainstream with Windows 95. If you’re so inclined, here are a few ideas for where to go from here: Automatically Generating a Dynamic Desktop from PhotosIt’s mind-blowing to think that something as transcendent as the movement of celestial bodies can be reduced to a system of equations with two inputs: time and place. In the example before, this information is hard-coded, but you could ostensibly extract that information from images automatically. By default, the camera on most phones captures Exif metadata each time a photo is snapped. This metadata can include the time which the photo was taken and the GPS coordinates of the device at the time. By reading time and location information directly from image metadata, you can automatically determine solar position and simplify the process of generating a Dynamic Desktop from a series of photos. Shooting a Time Lapse on Your iPhoneWant to put your new iPhone Xs to good use? (Or more accurately, “Want to use your old iPhone for something productive while you procrastinate selling it?”) Mount your phone against a window, plug it into a charger, set the Camera to Timelapse mode, and hit the “Record” button. By extracting key frames from the resulting video, you can make your very own bespoke Dynamic Desktop. You might also want to check out Skyflow or similar apps that more easily allow you to take still photos at predefined intervals. Generating Landscapes from GIS DataIf you can’t stand to be away from your phone for an entire day (sad) or don’t have anything remarkable to look (also sad), you could always create your own reality (sounds sadder than it is). Using an app like Terragen, you can render photo-realistic 3D landscapes, with fine-tuned control over the earth, sun, and sky. You can make it even easier for yourself by downloading an elevation map from the U.S. Geological Survey’s National Map website and using that as a template for your 3D rendering project. Downloading Pre-Made Dynamic DesktopsOr if you have actual work to do and can’t be bothered to spend your time making pretty pictures, you can always just pay someone else to do it for you. We’re personally fans of the the 24 Hour Wallpaper app. If you have any other recommendations, @ us on Twitter!. ReferenceWritten by Mattt — October 1st, 2018 https://nshipster.com/macos-dynamic-desktop/]]></content>
      <tags>
        <tag>Swift</tag>
        <tag>macOs</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Creating and Modifying a URL in your Swift App]]></title>
    <url>%2F2018%2F10%2FCreating-and-Modifying-a-URL-in-your-Swift-App%2F</url>
    <content type="text"><![CDATA[In many types of apps, you have to access files. They can be in your app bundle, on the file system, or even somewhere on the web. You need to have someway to refer to where they are in your code. On Apple platforms, you basically have 2 choices, as a String or aURL. Given the address bar right above you, or any use of a terminal, a Swift String would be a very understandable choice, I mean, that’s all that text is in the address bar, right? Many of the older APIs in the Cocoa and Cocoa Touch SDKs take URLs and Strings (referred to as a “path” in those APIs usually), but things are moving more and more towards just using URL objects everywhere. URL objects have many advantages over String paths, most notably that you can access different parts of the URL from properties, instead of having to write your own code to parse those components from the path String. Stay tuned as we learn a thing or two about creating and using URL objects in your Swift app. Creating a URL in SwiftThere are several initializers and factory methods to create a URL in Swift, but I’m going to cover some of the more useful ones. init?(string URLString: String)This one is the most plain, and probably the most used. This takes your Swift String version of a URL, and changes it into a URL object. It is a failable initializer, because not all strings can make valid URLS. There are some characters that cannot be used in URLs, and thus are percent encoded, meaning a code that CAN be sent in a URL is used in its place. The one I personally have seen the most is %20, the “space” character. This initializer expects only valid characters, it will not percent encode for you. If the string does have characters or anything that can’t be converted into a valid URL, this initializer will return nil. 12let NSHipster = URL(string: "http://nshipster.com/") //returns a valid URLlet invalidURL = URL(string: "www.example.com/This is a sentence") //Returns nil This is actually a convenience initializer which defers to the initializer below. init?(string: String, relativeTo: URL?)This is the dedicated initializer. Similar to the previous initializer, it is a failable one, and takes a similar URL Swift String, but it also takes an optional baseURL object, which is a URL object itself. If the baseURL is nil, it just makes the URL entirely from the URL String, which is probably what the first initializer does under the hood. 12let NSHipsterTwo = URL(string: "http://nshipster.com/", relativeTo: nil) //Returns valid NSHipster URLlet article = URL(string: "ios9/", relativeTo: NSHipster) //Returns "http://nshipster.com/ios9/" URL init(fileURLWithPath: String, isDirectory: Bool)This is similar to the above initializer, but is meant to point at a local file or directory. I’m not certain why there is a special version for local files, but I presume some optimizations are made (at least to start it with the file scheme, as opposed to http, or other ones). There is a version without the isDirectory parameter, but the header file suggests using this one if you do know whether it is a directory or not. Presumably, the other one will need to perform the check itself, while this one has you providing the answer, saving it from having to check. init(fileURLWithPath: String, isDirectory: Bool, relativeTo: URL?)Newly added in iOS 9, this is similar to the previous one, but with the relativeToURL parameter. Like the previous initializers, this will return a URL object that appends the path to the baseURL. This could be used, if you had a directory of several files, where you were iterating through them to use for something. You could supply the directory the files were in as the baseURL, and then just create the URLs with the file name as the Swift String path. Converting URL back to a Swift StringSometimes, especially when dealing with older API, or when showing it to the user, you need to convert a URL object back to a Swift String. Thankfully, URL provides a simple read-only property to get that out: absoluteString. Just call that property on your URL object and you’ve got it: 12let articleString = article?.absoluteString//ArticleString now contains: "http://nshipster.com/ios9/" In this case it took our article constant that we defined using the relativeToURL version of the initializer, resolved it into a complete URL from scheme until the end (which in this case is a path). If we did have file extensions, queries, and fragments on this URL, it would resolve them as well. The original article object was returned from the failable initializer, so that is why we still have that question mark there for Swift’s optional chaining. Modifying a URL ObjectEach of these functions return a new URL object based on the one it was called from, but with the requested modification done. They do NOT change the URL they are called from though, it remains the same. func appendingPathComponent(String, isDirectory: Bool) -&gt; URLThis one adds more path components to the URL, say if you were adding a file to the directory you’re in (which is stored in the URL this is called from). There is a version without the isDirectory parameter like some of the initializers, but if you know whether it is a directory or not, it is recommended to use this one to save the metadata check to determine whether it is a directory or not. func deletingLastPathComponent() -&gt; URLThis method will return a new URL with the last path component deleted. This works on the path part of a URL, so other areas of the URL are unaffected, like the domain. So we can do this: 12345let articleTwo = NSHipster?.URLByAppendingPathComponent("ios9", isDirectory: true)//articleTwo now contains "http://nshipster.com/ios9/" let deletePathComp = articleTwo?.URLByDeletingLastPathComponent//deletePathComp now contains "http://nshipster.com/" If there is no path information, things can get a bit weird. For fun, I chained a few URLByDeletingLastPathComponent afterwards, and it ended up just appending “../” afterwards, analogous to going up a directory in the command line (cd ..). There are several more modification methods and properties, but these are probably the most commonly used. ConclusionIf you are curious about specifics of URL formatting specifications, you can checkout the RFC documents that Apple’s URL Class Reference mentions in how it handles URLs. The strings used when initializing URLs must conform to RFC 2396, and the URLs themselves are parsed according to RFC 1738 and RFC 1808. The are pretty long but probably have anything you would want to know about URLs, URIs, etc. There are many other properties in URL if you want a fully resolved URL, the baseURL, host, query, fragment, etc, and you can check them out in Apple’s URL Class Reference, but I personally primarily use absoluteString, and occasionally pathExtension. I hope you found this article helpful. If you did, please don’t hesitate to share this post on Twitter or your social media of choice, every share helps. Of course, if you have any questions, don’t hesitate to contact me on the Contact Page, or on Twitter @CodingExplorer, and I’ll see what I can do. Thanks! Sources URL Class Reference – Apple Inc.]]></content>
      <tags>
        <tag>swift</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Strings in Swift 4]]></title>
    <url>%2F2018%2F10%2FStrings-in-Swift-4%2F</url>
    <content type="text"><![CDATA[All modern programming languages have support for Unicode strings, but that often only means that the native string type can store Unicode data — it’s not a promise that simple operations like getting the length of a string will return “sensible” results. _In fact, most languages, and in turn most string manipulation code written in those languages, exhibit a certain level of denial about Unicode’s inherent complexity. This can lead to some unpleasant bugs. Swift’s string implementation goes to heroic efforts to be as Unicode-correct as possible. A String in Swift is a collection of Character values, where a Character is what a human reader of a text would perceive as a single character, regardless of how many Unicode code points it’s composed of. As a result, all standard Collection operations like count or prefix(5) work on the level of user-perceived characters. This is great for correctness, but it comes at a price, mostly in terms of unfamiliarity; if you’re used to manipulating strings with integer indices in other languages, Swift’s design will seem unwieldy at first, leaving you wondering. Why can’t I write str[999] to access a string’s one-thousandth character? Why doesn’t str[idx+1] get the next character? Why can’t I loop over a range of Character values such as &quot;a&quot;...&quot;z&quot;? It also has performance implications: String does not support random access, i.e. jumping to an arbitrary character is not an O(1) operation. It can’t be — when characters have variable width, the string doesn’t know where the nth character is stored without looking at all characters that come before it. In this chapter, we’ll discuss the string architecture in detail, as well as some techniques for getting the most out of Swift strings in terms of functionality and performance. But we’ll start with an overview of the required Unicode terminology. Unicode, Or: No More Fixed WidthThings used to be so simple. ASCII strings were a sequence of integers between 0 and 127. If you stored them in an 8-bit byte, you even had a bit to spare! Since every character was of a fixed size, ASCII strings could be random access. But ASCII wasn’t enough if you were writing in anything other than English or for a non-U.S. audience; other countries and languages needed other characters (even English-speaking Britain needed a £ sign). Most of them needed more characters than would fit into seven bits. ISO 8859 takes the extra bit and defines 16 different encodings above the ASCII range, such as Part 1 (ISO 8859-1, aka Latin-1), covering several Western European languages; and Part 5, covering languages that use the Cyrillic alphabet. This is still limiting, though. If you want to use ISO 8859 to write in Turkish about Ancient Greek, you’re out of luck, since you’d need to pick either Part 7 (Latin/Greek) or Part 9 (Turkish). And eight bits is still not enough to encode many languages. For example, Part 6 (Latin/Arabic) doesn’t include the characters needed to write Arabic-script languages such as Urdu or Persian. Meanwhile, Vietnamese — which is based on the Latin alphabet but with a large number of diacritic combinations — only fits into eight bits by replacing a handful of ASCII characters from the lower half. And this isn’t even an option for other East Asian languages. When you run out of room with a fixed-width encoding, you have a choice: either increase the size, or switch to variable-width encoding. Initially, Unicode was defined as a 2-byte fixed-width format, now called UCS-2. This was before reality set in, and it was accepted that even two bytes would not be sufficient, while four would be horribly inefficient for most purposes. So today, Unicode is a variable-width format, and it’s variable in two different senses: in the combining of code units into Unicode scalars, and in the combining of scalars into characters. Unicode data can be encoded with many different widths of code unit, most commonly 8 (UTF-8) or 16 (UTF-16) bits. UTF-8 has the added benefit of being backwardly compatible with 8-bit ASCII — something that’s helped it overtake ASCII as the most popular encoding on the web. Swift represents UTF-16 and UTF-8 code units as UInt16 and UInt8 values, respectively (aliased as Unicode.UTF16.CodeUnit and Unicode.UTF8.CodeUnit). A code point in Unicode is a single value in the Unicode code space with a possible value from 0 to 0x10FFFF (in decimal: 1,114,111). Only about 137,000 of the 1.1 million available code points are currently in use, so there’s a lot of room for more emoji. A given code point might take a single code unit if you’re using UTF-32, or it might take between one and four if you’re using UTF-8. The first 256 Unicode code points match the characters found in Latin-1. Unicode scalars are almost, but not quite, the same as code points. They’re all the code points except the 2,048 surrogate code points in the range 0xD800–0xDFFF, i.e. the code points used for the leading and trailing codes that indicate pairs in UTF-16 encoding. Scalars are represented in Swift string literals as &quot;\u{xxxx}&quot;, where xxxx represents hex digits. So the euro sign can be written in Swift as either &quot;€&quot; or &quot;\u{20AC}&quot;. The corresponding Swift type is Unicode.Scalar, which is a wrapper around a UInt32 value. To represent each Unicode scalar by a single code unit, you’d need a 21-bit encoding scheme (which usually gets rounded up to 32-bit, i.e. UTF-32), but even that wouldn’t get you a fixed-width encoding: Unicode is still a variable-width format when it comes to “characters.” What a user might consider “a single character” — as displayed on the screen — might require multiple scalars composed together. The Unicode term for such a user-perceived character is (extended) grapheme cluster. The rules for how scalars form grapheme clusters determine how text is segmented. For example, if you hit the backspace key on your keyboard, you expect your text editor to delete exactly one grapheme cluster, even if that “character” is composed of multiple Unicode scalars, each of which may use a varying number of code units in the text’s representation in memory. Grapheme clusters are represented in Swift by the Character type, which can encode an arbitrary number of scalars, as long as they form a single user-perceived character. We’ll see some examples of this in the next section. Grapheme Clusters and Canonical EquivalenceCombining MarksA quick way to see how String handles Unicode data is to look at the two different ways to write é. Unicode defines U+00E9, Latin small letter e with acute, as a single value. But you can also write it as the plain letter e, followed by U+0301, combining acute accent. In both cases, what’s displayed is é, and a user probably has a reasonable expectation that two strings displayed as “résumé” would not only be equal to each other but also have a “length” of six characters, no matter which technique was used to produce the é in either one. They would be what the Unicode specification describes as canonically equivalent. And in Swift, this is exactly the behavior you get: 12let single = "Pok\u&#123;00E9&#125;mon"let double = "Poke\u&#123;0301&#125;mon" They both display identically: 1(single, double) // → ("Pokémon", "Pokémon") And both have the same character count: 12single.count // → 7double.count // → 7 Consequently, they also compare equal: 1single == double // → true Only if you drop down to a view of the underlying representation can you see that they’re different: 12single.utf16.count // → 7double.utf16.count // → 8 Contrast this with NSString in Foundation: the two strings aren’t equal, and the lengthproperty — which many programmers probably use to count the number of characters to be displayed on the screen — gives different results: 1234567import Foundationlet nssingle = single as NSStringnssingle.length // → 7let nsdouble = double as NSStringnsdouble.length // → 8nssingle == nsdouble // → false Here, == is defined as the version for comparing two NSObjects: 12345extension NSObject: Equatable &#123; static func ==(lhs: NSObject, rhs: NSObject) -&gt; Bool &#123; return lhs.isEqual(rhs) &#125;&#125; In the case of NSString, this will do a literal comparison on the level of UTF-16 code units, rather than one accounting for equivalent but differently composed characters. Most string APIs in other languages work this way too. If you really want to perform a canonical comparison, you must use NSString.compare(_:). Didn’t know that? Enjoy your future undiagnosable bugs and grumpy international user base. Of course, there’s one big benefit to just comparing code units: it’s faster! This is an effect that can still be achieved with Swift strings, via the utf16 view: 1single.utf16.elementsEqual(double.utf16) // → false Why does Unicode support multiple representations of the same character at all? The existence of precomposed characters is what enables the opening range of Unicode code points to be compatible with Latin-1, which already had characters like é and ñ. While they might be a pain to deal with, it makes conversion between the two encodings quick and simple. And ditching precomposed forms wouldn’t have helped anyway, because composition doesn’t just stop at pairs; you can compose more than one diacritic together. For example, Yoruba has the character ọ́, which could be written three different ways: by composing ó with a dot, or by composing ọ with an acute, or by composing o with both an acute and a dot. And for that last one, the two diacritics can be in either order! So these are all equal: 12345678let chars: [Character] = [ "\u&#123;1ECD&#125;\u&#123;300&#125;", // ọ́ "\u&#123;F2&#125;\u&#123;323&#125;", // ọ́ "\u&#123;6F&#125;\u&#123;323&#125;\u&#123;300&#125;", // ọ́ "\u&#123;6F&#125;\u&#123;300&#125;\u&#123;323&#125;" // ọ́]let allEqual = chars.dropFirst() .all(matching: &#123; $0 == chars.first &#125;) // → true The all(matching:) method checks if the condition is true for all elements in a sequence: 12345678910extension Sequence &#123; func all(matching predicate: (Element) throws -&gt; Bool) rethrows -&gt; Bool &#123; for element in self &#123; if try !predicate(element) &#123; return false &#125; &#125; return true &#125;&#125; In fact, some diacritics can be added ad infinitum. A famous internet meme illustrates this nicely: 1234let zalgo = "s̼̐͗͜o̠̦̤ͯͥ̒ͫ́ͅo̺̪͖̗̽ͩ̃͟ͅn̢͔͖͇͇͉̫̰ͪ͑"zalgo.count // → 4zalgo.utf16.count // → 36 In the above, zalgo.count (correctly) returns 4, while zalgo.utf16.count returns 36. And if your code doesn’t work correctly with internet memes, then what good is it, really? Unicode’s grapheme breaking rules even affect you when all strings you deal with are pure ASCII: CR+LF, the character pair of carriage return and line feed that’s commonly used as a newline on Windows, is a single grapheme: 123// CR+LF is a single Characterlet crlf = "\r\n"crlf.count // → 1 EmojiStrings containing emoji can also be surprising in many other programming languages. Many emoji are assigned Unicode scalars that don’t fit in a single UTF-16 code unit. Languages that represent strings as collections of UTF-16 code units, such as Java or C#, would say that the string &quot;😂&quot; is two “characters” long. Swift handles this case correctly: 12let oneEmoji = "😂" // U+1F602oneEmoji.count // → 1 Notice that the important thing is how the string is exposed to the program, not how it’s stored in memory. Swift also uses UTF-16 as its internal encoding for non-ASCII strings, but that’s an implementation detail. The public API is based on grapheme clusters. Other emoji are composed of multiple scalars. An emoji flag is a combination of two regional indicator letters that correspond to an ISO country code. Swift treats it correctly as one Character: 12let flags = "🇧🇷🇳🇿"flags.count // → 2 To inspect the Unicode scalars a string is composed of, use the unicodeScalars view. Here, we format the scalar values as hex numbers in the common format for code points: 1234flags.unicodeScalars.map &#123; "U+\(String($0.value, radix: 16, uppercase: true))"&#125;// → ["U+1F1E7", "U+1F1F7", "U+1F1F3", "U+1F1FF"] Skin tones combine a base character such as 👧 with one of five skin tone modifiers (e.g. 🏽, or the type-4 skin tone modifier) to yield the final emoji (e.g. 👧🏽). Again, Swift handles this correctly: 12let skinTone = "👧🏽" // 👧 + 🏽skinTone.count // → 1 This time, let’s use a Foundation API to apply an ICU string transform that converts Unicode scalars to their official Unicode names: 12345678910111213141516171819202122extension StringTransform &#123; static let toUnicodeName = StringTransform(rawValue: "Any-Name")&#125;extension Unicode.Scalar &#123; /// The scalar’s Unicode name, e.g. "LATIN CAPITAL LETTER A". var unicodeName: String &#123; // Force-unwrapping is safe because this transform always succeeds let name = String(self).applyingTransform(.toUnicodeName, reverse: false)! // The string transform returns the name wrapped in "\\N&#123;...&#125;". Remove those. let prefixPattern = "\\N&#123;" let suffixPattern = "&#125;" let prefixLength = name.hasPrefix(prefixPattern) ? prefixPattern.count : 0 let suffixLength = name.hasSuffix(suffixPattern) ? suffixPattern.count : 0 return String(name.dropFirst(prefixLength).dropLast(suffixLength)) &#125;&#125;skinTone.unicodeScalars.map &#123; $0.unicodeName &#125;// → ["GIRL", "EMOJI MODIFIER FITZPATRICK TYPE-4"] The essential part of this code snippet is the applyingTransform(.toUnicodeName, …)call. The remaining lines clean up the name returned from the transform method by removing the wrapping braces. We code this defensively: we first check whether the string matches the expected pattern and compute the number of characters to strip from the start and end. If the format returned by the transform method changes in the future, it’s better to return the string unchanged than to remove characters we didn’t anticipate. Notice how we use the standard Collection methods dropFirst and dropLast to perform the stripping operation. This is a good example of how you can manipulate a string without doing manual index calculations. It’s also efficient, because dropFirst and dropLast return a Substring, which is a slice of the original string. No new memory allocations are needed until the final step when we create a new String from the substring. We’ll have more to say about substrings later in this chapter. Emoji depicting families and couples, such as 👨‍👩‍👧‍👦 and 👩‍❤️‍👩, present another challenge to the Unicode standards body. Due to the countless possible combinations of genders and the number of people in a group, providing a separate code point for each variation is problematic. Combine this with a distinct skin tone for each person and it becomes impossible. Unicode solves this by specifying that these emoji are actually sequences of multiple emoji, combined with the invisible zero-width joiner (ZWJ) character (U+200D). So the family 👨‍👩‍👧‍👦 is really man 👨 + ZWJ + woman 👩 + ZWJ + girl 👧 + ZWJ + boy 👦. The ZWJ serves as an indicator to the operating system that it should use a single glyph if available. You can verify that this is really what’s going on: 123let family1 = "👨‍👩‍👧‍👦"let family2 = "👨\u&#123;200D&#125;👩\u&#123;200D&#125;👧\u&#123;200D&#125;👦"family1 == family2 // → true And once again, Swift is smart enough to treat such a sequence as a single Character: 12family1.count // → 1family2.count // → 1 New emoji for professions introduced in 2016 are ZWJ sequences too. For example, the female firefighter 👩‍🚒 is composed of woman 👩 + ZWJ + fire engine 🚒, and the male health worker 👨‍⚕️ is a sequence of man 👨 + ZWJ + staff of aesculapius ⚕. Rendering these sequences into a single glyph is the task of the operating system. On Apple platforms in 2017, the OS includes glyphs for the subset of sequences the Unicode standard lists as “recommended for general interchange” (RGI), i.e. the ones “most likely to be widely supported across multiple platforms.” When no glyph is available for a syntactically valid sequence, the text rendering system falls back to rendering each component as a separate glyph. Notice that this can cause a mismatch “in the other direction” between user-perceived characters and what Swift sees as a grapheme cluster; all examples up until now were concerned with programming languages overcounting characters, but here we see the reverse. As an example, family sequences containing skin tones are currently not part of the RGI subset. But even though most operating systems currently render such a sequence as multiple glyphs, Swift still counts it as a single Character because the Unicode text segmentation rules are not concerned with rendering: 12345// Family with skin tones is rendered as multiple glyphs// on most platforms in 2017let family3 = "👱🏾\u&#123;200D&#125;👩🏽\u&#123;200D&#125;👧🏿\u&#123;200D&#125;👦🏻" // → "👱🏾‍👩🏽‍👧🏿‍👦🏻"// But Swift still counts it as a single Characterfamily3.count // → 1 Microsoft can already render this and other variations as a single glyph, by the way, and the other OS vendors will almost certainly follow soon. But the point still stands: no matter how carefully a string API is designed, text is so complicated that it may never catch all edge cases. In the past, Swift had trouble keeping up with Unicode changes. Swift 3 handled skin tones and ZWJ sequences incorrectly because its grapheme breaking algorithm was based on an old version of the Unicode standard. As of Swift 4, Swift uses the operating system’s ICU library. As a result, your programs will automatically adopt new Unicode rules as users update their OSes. The other side of the coin is of course that you can’t rely on users seeing the same behavior you see during development. In the examples we discussed in this section, we treated the length of a string as a proxy for all sorts of things that can go wrong when a language doesn’t take the full complexity of Unicode into account. Just think of the gibberish a simple task such as reversing a string can produce in a programming language that doesn’t process strings by grapheme clusters when the string contains composed character sequences. This isn’t a new problem, but the emoji explosion has made it much more likely that bugs caused by sloppy text handling will come to the surface, even if your user base is predominantly English-speaking. And the magnitude of errors has increased as well: whereas a decade ago a botched accented character would cause an off-by-one error, messing up a modern emoji can easily cause results to be off by 10 or more “characters.” For example, a four-person family emoji is 11 (UTF-16) or 25 (UTF-8) code units long: 123family1.count // → 1family1.utf16.count // → 11family1.utf8.count // → 25 It’s not that other languages don’t have Unicode-correct APIs at all — most do. For instance, NSString has the enumerateSubstrings method that can be used to walk through a string by grapheme clusters. But defaults matter; Swift’s priority is to do the correct thing by default. And if you ever need to drop down to a lower level of abstraction, String provides views that let you operate directly on Unicode scalars or code units. We’ll say more about those below. Strings and CollectionsAs we’ve seen, String is a collection of Character values. In Swift’s first three years of existence, String went back and forth between conforming and not conforming to the Collection protocol. The argument for not adding the conformance was that programmers would expect all generic collection-processing algorithms to be completely safe and Unicode-correct, which wouldn’t necessarily be true for all edge cases. As a simple example, you might assume that if you concatenate two collections, the resulting collection’s length would be the sum of the lengths of the two source collections. But this doesn’t hold for strings if a suffix of the first string forms a grapheme cluster with a prefix of the second string: 12345let flagLetterJ = "🇯"let flagLetterP = "🇵"let flag = flagLetterJ + flagLetterP // → "🇯🇵"flag.count // → 1flag.count == flagLetterJ.count + flagLetterP.count // → false To this end, String itself was not made a Collection in Swift 2 and 3; a collection-of-characters view was moved to a property, characters, which put it on a footing similar to the other collection views: unicodeScalars, utf8, and utf16. Picking a specific view prompted you to acknowledge you were moving into a “collection-processing” mode and that you should consider the consequences of the algorithm you were about to run. In practice, the loss in usability and learnability caused by this change turned out to vastly outweigh the gain in correctness for a few edge cases that are rarely relevant in real code (unless you’re writing a text editor). So String was made a Collection again in Swift 4. The characters view still exists, but only for backward compatibility. Bidirectional, Not Random AccessHowever, for reasons that should be clear from the examples in the previous section, String is not a random-access collection. How could it be, when knowing where the nthcharacter of a particular string is involves evaluating just how many Unicode scalars precede that character? For this reason, String conforms only to BidirectionalCollection. You can start at either end of the string, moving forward or backward, and the code will look at the composition of the adjacent characters and skip over the correct number of bytes. However, you need to iterate up and down one character at a time. Keep the performance implications of this in mind when writing string-processing code. Algorithms that depend on random access to maintain their performance guarantees aren’t a good match for Unicode strings. Consider this String extension for generating a list of a string’s prefixes, which works by generating an integer range from zero to the string’s length and then mapping over the range to create the prefix for each length: 12345678extension String &#123; var allPrefixes1: [Substring] &#123; return (0...self.count).map(self.prefix) &#125;&#125;let hello = "Hello"hello.allPrefixes1 // → ["", "H", "He", "Hel", "Hell", "Hello"] As simple as this code looks, it’s very inefficient. It first walks over the string once to calculate the length, which is fine. But then each of the n + 1 calls to prefix is another O(n)operation because prefix always starts at the beginning and has to work its way through the string to count the desired number of characters. Running a linear process inside another linear loop means this algorithm is accidentally O(n2) — as the length of the string increases, the time this algorithm takes increases quadratically. If possible, an efficient string algorithm should walk over a string only once and then operate on string indices to denote the substrings it’s interested in. Here’s another version of the same algorithm: 1234567extension String &#123; var allPrefixes2: [Substring] &#123; return [""] + self.indices.map &#123; index in self[...index] &#125; &#125;&#125;hello.allPrefixes2 // → ["", "H", "He", "Hel", "Hell", "Hello"] This code also has to iterate over the string once to generate the indices collection. But once that’s done, the subscripting operation inside map is O(1). This makes the whole algorithm O(n). Range-Replaceable, Not MutableString also conforms to RangeReplaceableCollection. Here’s an example of how you’d replace part of a string by first identifying the appropriate range in terms of string indices and then calling replaceSubrange. The replacement string can have a different length or could even be empty (which would be equivalent to calling removeSubrange): 123456var greeting = "Hello, world!"if let comma = greeting.index(of: ",") &#123; greeting[..&lt;comma] // → "Hello" greeting.replaceSubrange(comma..., with: " again.")&#125;greeting // → "Hello again." As always, keep in mind that results may be surprising if parts of the replacement string form new grapheme clusters with adjacent characters in the original string. One collection-like feature strings do not provide is that of MutableCollection. This protocol adds one feature to a collection — that of the single-element subscript set — in addition to get. This isn’t to say strings aren’t mutable — as we’ve just seen, they have several mutation methods. But what you can’t do is replace a single character using the subscript operator. The reason comes back to variable-length characters. Most people can probably intuit that a single-element subscript update would happen in constant time, as it does for Array. But since a character in a string may be of variable width, updating a single character could take linear time in proportion to the length of the string: changing the width of a single element would require shuffling all the later elements up or down in memory. Moreover, indices that come after the replaced index would become invalid through the shuffling, which is equally unintuitive. For these reasons, you have to use replaceSubrange, even if the range you pass in is only a single element. String IndicesMost programming languages use integers for subscripting strings, e.g. str[5] would return the sixth “character” of str (for whatever that language’s idea of a “character” is). Swift doesn’t allow this. Why? The answer should sound familiar to you by now: subscripting is supposed to take constant time (intuitively as well as per the requirements of the Collection protocol), and looking up the nth Character is impossible without looking at all bytes that come before it. String.Index, the index type used by String and its views, is an opaque value that essentially stores a byte offset from the beginning of the string. It’s still an O(n) operation if you want to compute the index for the nth character and have to start at the beginning of the string, but once you have a valid index, subscripting the string with it now only takes O(1)time. And crucially, finding the next index after an existing index is also fast because you can start at the existing index’s byte offset — you don’t need to go back to the beginning again. This is why iterating over the characters in a string in order (forward or backward) is efficient. String index manipulation is based on the same Collection APIs you’d use with any other collection. It’s easy to miss this equivalence since the collections we use by far the most — arrays — use integer indices, and we usually use simple arithmetic to manipulate those. The index(after:) method returns the index of the next character: 123let s = "abcdef"let second = s.index(after: s.startIndex)s[second] // → "b" You can automate iterating over multiple characters in one go via the index(_:offsetBy:)method: 123// Advance 4 more characterslet sixth = s.index(second, offsetBy: 4)s[sixth] // → "f" If there’s a risk of advancing past the end of the string, you can add a limitedBy:parameter. The method returns nil if it hits the limit before reaching the target index: 12let safeIdx = s.index(s.startIndex, offsetBy: 400, limitedBy: s.endIndex)safeIdx // → nil This is undoubtedly more code than simple integer indices would require, but again, that’s the point. If Swift allowed integer subscripting of strings, the temptation to accidentally write horribly inefficient code (e.g. by using integer subscripting inside a loop) would be too big. Nevertheless, to someone used to dealing with fixed-width characters, working with strings in Swift seems challenging at first — how will you navigate without integer indices? And indeed, some seemingly simple tasks like extracting the first four characters of a string can turn into monstrosities like this one: 1s[..&lt;s.index(s.startIndex, offsetBy: 4)] // → "abcd" But thankfully, being able to access the string via the Collection interface also means you have several helpful techniques at your disposal. Many of the methods that operate on Array also work on String. Using the prefix method, the same thing looks much clearer: 1s.prefix(4) // → "abcd" (Note that either expression returns a Substring; you can convert it back into a String by wrapping it in a String.init. We’ll talk more about substrings in the next section.) Iterating over characters in a string is easy without integer indices; just use a for loop. If you want to number each character in turn, use enumerated(): 123for (i, c) in s.enumerated() &#123; print("\(i): \(c)")&#125; Or say you want to find a specific character. In that case, you can use index(of:): 12345var hello = "Hello!"if let idx = hello.index(of: "!") &#123; hello.insert(contentsOf: ", world", at: idx)&#125;hello // → "Hello, world!" The insert(contentsOf:at:) method inserts another collection of the same element type (e.g. Character for strings) before a given index. This doesn’t have to be another String; you could insert an array of characters into a string just as easily. SubstringsLike all collections, String has a specific slice or SubSequence type named Substring. A substring is much like an ArraySlice: it’s a view of a base string with different start and end indices. Substrings share the text storage of their base strings. This has the huge benefit that slicing a string is a very cheap operation. Creating the firstWord variable in the following example requires no expensive copies or memory allocations: 1234let sentence = "The quick brown fox jumped over the lazy dog."let firstSpace = sentence.index(of: " ") ?? sentence.endIndexlet firstWord = sentence[..&lt;firstSpace] // → "The"type(of: firstWord) // → Substring.Type Slicing being cheap is especially important in loops where you iterate over the entire (potentially long) string to extract its components. Tasks like finding all occurrences of a word in a text or parsing a CSV file come to mind. A very useful string processing operation in this context is splitting. The split method is defined on Collection and returns an array of subsequences (i.e. [Substring]). Its most common variant is defined like so: 1234extension Collection where Element: Equatable &#123; public func split(separator: Element, maxSplits: Int = Int.max, omittingEmptySubsequences: Bool = true) -&gt; [SubSequence]&#125; You can use it like this: 12345678let poem = """ Over the wintry forest, winds howl in rage with no leaves to blow. """let lines = poem.split(separator: "\n")// → ["Over the wintry", "forest, winds howl in rage", "with no leaves to blow."]type(of: lines) // → Array&lt;Substring&gt;.Type This can serve a function similar to the components(separatedBy:) method Stringinherits from NSString, with added configurations for whether or not to drop empty components. Again, no copies of the input string are made. And since there’s another variant of split that takes a closure, it can do more than just compare characters. Here’s an example of a primitive word wrap algorithm, where the closure captures a count of the length of the line thus far: 1234567891011121314151617181920extension String &#123; func wrapped(after: Int = 70) -&gt; String &#123; var i = 0 let lines = self.split(omittingEmptySubsequences: false) &#123; character in switch character &#123; case "\n", " " where i &gt;= after: i = 0 return true default: i += 1 return false &#125; &#125; return lines.joined(separator: "\n") &#125;&#125;sentence.wrapped(after: 15)// → "The quick brown\nfox jumped over\nthe lazy dog." Or, consider writing a version that takes a sequence of multiple separators: 1234567extension Collection where Element: Equatable &#123; func split&lt;S: Sequence&gt;(separators: S) -&gt; [SubSequence] where Element == S.Element &#123; return split &#123; separators.contains($0) &#125; &#125;&#125; This way, you can write the following: 1"Hello, world!".split(separators: ",! ") // → ["Hello", "world"] StringProtocolSubstring has almost the same interface as String. This is achieved through a common protocol named StringProtocol, which both types conform to. Since almost the entire string API is defined on StringProtocol, you can mostly work with a Substring as you would with a String. At some point, though, you’ll have to turn your substrings back into String instances; like all slices, substrings are only intended for short-term storage, in order to avoid expensive copies during an operation. When the operation is complete and you want to store the results or pass them on to another subsystem, you should create a new String. You can do this by initializing a String with a Substring, as we do in this example: 123456789func lastWord(in input: String) -&gt; String? &#123; // Process the input, working on substrings let words = input.split(separators: [",", " "]) guard let lastWord = words.last else &#123; return nil &#125; // Convert to String for return return String(lastWord)&#125;lastWord(in: "one, two, three, four, five") // → "five" The rationale for discouraging long-term storage of substrings is that a substring always holds on to the entire original string. A substring representing a single character of a huge string will hold the entire string in memory, even after the original string’s lifetime would normally have ended. Long-term storage of substrings would therefore effectively cause memory leaks because the original strings have to be kept in memory even when they’re no longer accessible. By working with substrings during an operation and only creating new strings at the end, we defer copies until the last moment and make sure to only incur the cost of those copies that are actually necessary. In the example above, we split the entire (potentially long) string into substrings, but only pay the cost for a single copy of one short substring at the end. (Ignore for a moment that this algorithm isn’t efficient anyway; iterating backward from the end until we find the first separator would be the better approach.) Encountering a function that only accepts a Substring when you want to pass a String is less common — most functions should either take a String or any StringProtocol-conforming type. But if you do need to pass a String, the quickest way is to subscript the string with the range operator ... without specifying any bounds: 12// Substring with identical start and end index as the base stringlet substring = sentence[...] The Substring type is new in Swift 4. In Swift 3, String.CharacterView used to be its own slice type. This had the advantage that users only had to understand a single type, but it meant that a stored substring would keep the entire original string buffer alive even after it normally would’ve been released. Swift 4 trades a small loss in convenience for cheap slicing operations and predictable memory usage. The Swift team does recognize that requiring explicit conversions from Substring to String is a little annoying. If this turns out to be a big problem in practical use, the team is considering wiring an implicit subtype relationship between Substring and String directly into the compiler, in the same way that Int is a subtype of Optional&lt;Int&gt;. This would allow you to pass a Substring anywhere a String is expected, and the compiler would perform the conversion for you. You may be tempted to take full advantage of the existence of StringProtocol and convert all your APIs to take StringProtocol instances rather than plain Strings. But the advice of the Swift team is not to do that: Our general advice is to stick with String. Most APIs would be simpler and clearer just using String rather than being made generic (which itself can come at a cost), and user conversion on the way in on the few occasions that’s needed isn’t much of a burden. APIs that are extremely likely to be used with substrings, and at the same time aren’t further generalizable to the Sequence or Collection level, are an exception to this rule. An example of this in the standard library is the joined method. Swift 4 added an overload for sequences with StringProtocol-conforming elements: 12345extension Sequence where Element: StringProtocol &#123; /// Returns a new string by concatenating the elements of the sequence, /// adding the given separator between each element. public func joined(separator: String = "") -&gt; String&#125; This lets you call joined directly on an array of substrings (which you got from a call to split, for example) without having to map over the array and copy every substring into a new string. This is more convenient and much faster. The number type initializers that take a string and convert it into a number also take StringProtocol values in Swift 4. Again, this is especially handy if you want to process an array of substrings: 1234let commaSeparatedNumbers = "1,2,3,4,5"let numbers = commaSeparatedNumbers .split(separator: ",").flatMap &#123; Int($0) &#125;// → [1, 2, 3, 4, 5] Since substrings are intended to be short-lived, it’s generally not advisable to return one from a function unless we’re talking about Sequence or Collection APIs that return slices. If you write a similar function that only makes sense for strings, having it return a substring tells readers that it doesn’t make a copy. Functions that create new strings requiring memory allocations, such as uppercased(), should always return String instances. If you want to extend String with new functionality, placing the extension on StringProtocol is a good idea to keep the API surface between String and Substringconsistent. StringProtocol is explicitly designed to be used whenever you would’ve previously extended String. If you want to move existing extensions from String to StringProtocol, the only change you should have to make is to replace any passing of self into an API that takes a concrete String with String(self). Keep in mind, though, that as of Swift 4, StringProtocol is not yet intended as a conformance target for your own custom string types. The documentation explicitly warns against it: Do not declare new conformances to StringProtocol. Only the String and Substring types of the standard library are valid conforming types. Allowing developers to write their own string types (with special storage or performance optimizations, for instance) is the eventual goal, but the protocol design hasn’t yet been finalized, so adopting it now may break your code in Swift 5. … … RecapStrings in Swift are very different than their counterparts in almost all other mainstream programming languages. When you’re used to strings effectively being arrays of code units, it’ll take a while to switch your mindset to Swift’s approach of prioritizing Unicode correctness over simplicity. Ultimately, we think Swift makes the right choice. Unicode text is much more complicated than what those other languages pretend it is. In the long run, the time savings from avoided bugs you’d otherwise have written will probably outweigh the time it takes to unlearn integer indexing. We’re so used to random “character” access that we may not realize how rarely this feature is really needed in string processing code. We hope the examples in this chapter convince you that simple in-order traversal is perfectly fine for most common operations. Forcing you to be explicit about which representation of a string you want to work on — grapheme clusters, Unicode scalars, UTF-16 or UTF-8 code units — is another safety measure; readers of your code will be grateful for it. When Chris Lattner outlined the goals for Swift’s string implementation in July 2016, he ended with this: Our goal is to be better at string processing than Perl! Swift 4 isn’t quite there yet — too many desirable features are missing, including moving more string APIs from Foundation into the standard library, native language support for regular expressions, string formatting and parsing APIs, and more powerful string interpolation. The good news it that the Swift team has expressed interest in tackling all these topics in the future. Referencehttps://goo.gl/VXiEBg]]></content>
      <tags>
        <tag>Swift</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Introduction to Siri Shortcuts in iOS 12]]></title>
    <url>%2F2018%2F09%2FIntroduction-to-Siri-Shortcuts-in-iOS-12%2F</url>
    <content type="text"><![CDATA[At WWDC 2018 in San Jose, Apple announced Siri Shortcuts, a long-awaited feature which empowers developers to extend and augment the capabilities of Siri within their own apps. Previously, the SiriKit SDK was quite limited in its overall functionalities. With the onset of Siri Shortcuts, developers can extend Siri’s features and build custom voice actions to invoke apps. Too lazy to update. A Brief History of Siri ShortcutsAt the heart of Siri Shortcuts is automation. In fact, Siri Shortcuts evolved out of Workflow, an iOS automation app built by former WWDC scholars. Apple acquired Workflow in 2017 but in an uncharacteristic move, kept the app live on the App Store well after its acquisition. Shortcuts let you expose the capabilities of your apps to Siri. Today, Apple’s new Siri Shortcuts app borrows heavily from the Workflow app. However, it’s important to differentiate voice shortcuts from the Shortcuts app. While the shortcuts app allows users to create voice-based phrases for common everyday tasks, Siri shortcuts empowers developers to extend the functionality of Siri in their own native apps. At the time of writing, the Shortcuts app is not available for testing in the iOS 12 Beta 2 Build. Instead, we will explore the utility of Siri Shortcuts within a custom app we build. Sample ProjectNote: This tutorial assumes you have a basic familiarity with the NSUserActivity API. If you do not, please refer to our excellent tutorial on the topic here. In this tutorial, we will explore how to leverage Siri Shortcuts in a simple and basic project that will let users say a phrase like “Say Hi” and then we will launch our app and present a UIAlertView. The purpose of this app is to provide a simple overview of how to integrate Siri Shortcuts within your app without adding the clutter of a large project. By the end of this tutorial, you should have a solid grasp on the use cases and technologies behind SiriShortcuts and know how to integrate them with your apps! Defining Your Shortcut in the New ProjectWhen starting any new project, it is important to first take a moment to set up the basic project structure. To begin, make sure you have the latest developer previews of iOS 12, macOS Mojave, and Xcode 10. If you do not have these tools, you will be unable to run the code in this tutorial as Siri Shortcuts is a new API introduced in the Xcode 10 and iOS 12 beta. If you are a registered Apple Developer, you can download these from the Developer Site. Fire up Xcode and create a new Single View App, key in SiriShortcuts for the name (or any name you’d like). We included com.appcoda as the Organization Identifer, but feel free to change this to your own Organization Identifier. Once done, click create to load your Xcode project. First off, navigate to the Project Settings section of your Xcode project, select Capabilities, and scroll down, and make sure you enable Siri as seen below. This will allow us to use the Siri SDK in our app and will add an entitlements file to the project. Once you enable Siri, Xcode will add a .entitlements file to your project. Next, we’ll navigate to the General tab of our project’s build settings, scroll to the bottom, and select Linked Frameworks and Libraries. Make sure to click the + button here to add a framework. Search for Intents.framework and once selected, press the Add button. This will allow us to use the new Intents framework within our application. Lastly, navigate to your Info.plist file and add a NSUserActivityTypesdictionary with a key-value pair. The value of your first item should include your bundle identifier with an appended action like “sayHi”. Donating a Shortcut&gt; To create a shortcut, you first define the shortcut and then donate the shortcut. Now that our project is all set up with the shortcut defined, it’s time to get down to coding! In order to make our shortcut available to our users via Siri, we leverage a process called “Donating Shortcuts.” According to the official Apple developer documentation, You should donate a shortcut each time the user performs the action in your app. For example, if the user can order soup from a restaurant using your app, donate a shortcut for the order soup action after the user places their order. Don’t make donations for actions that the user has not completed in your app; if the user never places an order for soup, you should never donate a shortcut for the order soup action. Clearly, donations should only be used when they provide meaningful use cases and can enhance the overall functionality of your app. Okay, back to coding! Head to your ViewController.swift file. After the viewDidLoad method, create a new method called setupIntents. Inside this method, we’ll include our Siri Shortcuts code. 12345678910func setupIntents() &#123; let activity = NSUserActivity(activityType: "com.AppCoda.SiriSortcuts.sayHi") // 1 activity.title = "Say Hi" // 2 activity.userInfo = ["speech" : "hi"] // 3 activity.isEligibleForSearch = true // 4 activity.isEligibleForPrediction = true // 5 activity.persistentIdentifier = NSUserActivityPersistentIdentifier(rawValue: "com.AppCoda.SiriSortcuts.sayHi") // 6 view.userActivity = activity // 7 activity.becomeCurrent() // 8 &#125; Okay, so let’s take a look at what’s going on in this code snippet. In the first line, we setup an instance of NSUserActivity and assign the activityType parameter to the identifier we defined in our Info.plistfile. In the second line, we define the activity title (what it will appear like in Settings and in Spotlight searches. If you’re unfamiliar with NSUserActivity and how spotlight indexes activities for searches, I recommend you read our other tutorials on the topic. In the third line, we add a userInfo dictionary. According to Apple, the userInfo dictionary is a “dictionary containing app-specific state information needed to continue an activity on another device.” Next, we set the .isEligibleForSearch property to true and in the following line enable isEligibleForPrediction. . These two properties allow iOS to search and suggest our NSUserActivity on the device. We next set the persistentIdentifier property to an instance of NSUserActivityPersistentIdentifier with the rawValue property assigned to our identifier from earlier. Lastly, we assign this view’s userActivity property to the activity we just created and invoke the becomeCurrent() method to activate our Activity. Create another method called sayHi() and paste in the following code. This code sets up a basic UIAlertController to display a message. 12345public func sayHi() &#123; let alert = UIAlertController(title: "Hi There!", message: "Hey there! Glad to see you got this working!", preferredStyle: UIAlertController.Style.alert) alert.addAction(UIAlertAction(title: "OK", style: UIAlertAction.Style.default, handler: nil)) self.present(alert, animated: true, completion: nil) &#125; While the above method is quite basic, it is good enough to demonstrate how Siri Shortcuts work. It’s important to note that this is a public function because we need to use it outside the scope of this view controller. Exposing the ActivityNow that you’ve set up the basic functionality in ViewController.swift, navigate to the AppDelegate.swift file and add the application(_:continueUserActivity:restorationHandler) function as seen below. 12345func application(_ application: UIApplication, continue userActivity: NSUserActivity, restorationHandler: @escaping ([UIUserActivityRestoring]?) -&gt; Void) -&gt; Bool &#123; let viewController = window?.rootViewController as! ViewController viewController.sayHi() return true&#125; This code exposes our newly created activity within the app delegate and allows Siri to take action on this activity to launch the app if it isn’t opened. Okay, so let’s give it a spin now! Navigate to the Settings app and select Siri. You should see a new shortcut created called “Say Hi.” Click the + button to add it and then follow the on screen prompts to create a custom voice phrase to invoke this shortcut. Once you’re done, spin up Siri and say your phrase! Wrapping UpAs you can see, it’s quite easy to use NSUserActivity in your project to leverage the power of Siri Shortcuts. In this tutorial, we set up a basic app that leverages this technology within your own apps. As you can see, the possibilities here are quite endless and developers will surely leverage this new technology in creative and unique ways. Reference:https://goo.gl/KLhrf3]]></content>
      <tags>
        <tag>iOS</tag>
        <tag>Shortcuts</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[How to convert your image to a current size in iOS]]></title>
    <url>%2F2018%2F07%2FHow-to-convert-your-image-to-a-current-size-in-iOS%2F</url>
    <content type="text"><![CDATA[In machine learning, if you need to use .mlmodel to process your images, you will inevitably encounter a very important problem. $0First things first, all the .mlmodels have the Model Evaluation Parameters, for this one,it asks for the current type of the image (Color 299 x 299). $1We can code this first to use the function. 1guard let pixelBuffer = resizedImage.toPixelBuffer() else &#123; return &#125; And brianadvent created q simple function to convert an UIImage to CVPixelBuffer for the use with Core ML. Click to Dowload But it’s different from our needs, so let’s do some changes. _$012345import CoreVideostruct ImageProcessor &#123; static func pixelBuffer (forImage image:CGImage) -&gt; CVPixelBuffer? &#123; ... brianadvent used the CroeVideo, and defined a stucture named ImageProcessor, we only need to make few changes: 1234567import UIKitextension UIImage &#123; func toPixelBuffer() -&gt; CVPixelBuffer? &#123; guard let image = self.cgImage else &#123; return nil &#125; ... The rest of codes do not require any changes.And you can use this file to convert your image correctly. UIImageToCVPixelBuffer.swift1234567891011121314151617181920212223242526272829303132import UIKitextension UIImage &#123; func toPixelBuffer() -&gt; CVPixelBuffer? &#123; guard let image = self.cgImage else &#123; return nil &#125; let frameSize = CGSize(width: image.width, height: image.height) var pixelBuffer: CVPixelBuffer? = nil let status = CVPixelBufferCreate(kCFAllocatorDefault, Int(frameSize.width), Int(frameSize.height), kCVPixelFormatType_32BGRA , nil, &amp;pixelBuffer) if status != kCVReturnSuccess &#123; return nil &#125; CVPixelBufferLockBaseAddress(pixelBuffer!, CVPixelBufferLockFlags.init(rawValue: 0)) let data = CVPixelBufferGetBaseAddress(pixelBuffer!) let rgbColorSpace = CGColorSpaceCreateDeviceRGB() let bitmapInfo = CGBitmapInfo(rawValue: CGBitmapInfo.byteOrder32Little.rawValue | CGImageAlphaInfo.premultipliedFirst.rawValue) let context = CGContext(data: data, width: Int(frameSize.width), height: Int(frameSize.height), bitsPerComponent: 8, bytesPerRow: CVPixelBufferGetBytesPerRow(pixelBuffer!), space: rgbColorSpace, bitmapInfo: bitmapInfo.rawValue) context?.draw(image, in: CGRect(x: 0, y: 0, width: image.width, height: image.height)) CVPixelBufferUnlockBaseAddress(pixelBuffer!, CVPixelBufferLockFlags(rawValue: 0)) return pixelBuffer &#125; &#125;]]></content>
      <tags>
        <tag>swift</tag>
        <tag>ML</tag>
        <tag>image</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[What’s new in iOS 12?]]></title>
    <url>%2F2018%2F06%2FWhat%E2%80%99s-new-in-iOS-12%2F</url>
    <content type="text"><![CDATA[iOS 12 brings with it huge leaps forward in machine learning, new ways to work with text, alert grouping so that users are bothered less frequently, and more. Part of this comes through huge improvements to Xcode, but I’ll be covering it all here. In this article I’m going to walk you through the major changes, complete with code examples, so you can try it all for yourself. Right now you can try iOS 12 only using the beta version of Xcode, and you will also need macOS Mojave if you want to use the new Create ML tools. You might also want to watch what’s new in Swift 4.2. Here is API diffs for iOS 12. Machine learning for image recognitionMachine learning (ML) was one of several major announcements from iOS 11, but it wasn’t that easy to use – particularly for folks who hadn’t studied the topic previously. This is all changing now, because Apple introduced two important new pieces of functionality. The first – Create ML – is actually a macOS framework that’s designed to make it trivial for anyone to create Core ML models to use in their app. The second – prediction batching – allows Core ML to evaluate many input sources in a more efficient way, making it less likely that newcomers would make basic mistakes. Create ML has to seen to be believed. Although I suspect it will change a little as the Xcode 10 beta evolves – the current UI feels a bit last-minute, to be honest – it’s already quite remarkable in its features, performance, and results. If you want to try it out, first create a new macOS playground, then give it this code: 1234import CreateMLUI let builder = MLImageClassifierBuilder()builder.showInLiveView() Press the play button to run the code, then open the assistant editor to show the live view for Create ML. You should see “ImageClassifier” at the top, followed by “Drop Images To Begin Training” below. Now we need some training data. If you just want to take it for a quick test run I’ve provided some images for you: click here to download them. These were all taken from https://unsplash.com/, and are available under a “do whatever you want” license, If you’d rather create the data yourself, I think you’ll be pleasantly surprised how easy it is: Create a new folder somewhere such as your desktop. Inside there, create two new folders: Training Data and Test Data. Inside each of those, create new folders for each thing you want to identify. Now drag your photos into the appropriate folders. That’s it! The training data is used to create your trained model, and the testing data is there just to see how well the trained model does with pictures it hasn’t seen before. Warning: Do not put the same image into both training data and test data – that rather undermines the test! As an example, n my example data, I’ve provided images of cats and dogs so we can use Create ML to train a model to distinguish the two. So, I have a folder structure like this: Training Data Training Data &gt; Cat Training Data &gt; Cat &gt; SomeCat.jpg Training Data &gt; Cat &gt; AnotherCat.jpg Training Data &gt; Dog Training Data &gt; Dog &gt; SomeDog.jpg Training Data &gt; Dog &gt; AnotherDog.jpg Testing Data &gt; Cat Testing Data &gt; Cat &gt; AThirdCat.jpg And so on. It’s a good idea to have at least 10 images in each data set, and you should try to have a roughly equal number of images in each category. Apple suggests you allocate about 80% of your images to training data, leaving 20% for testing. Now that you have your data ready, it’s time to have Create ML start its training process. To do that, drag the whole Training Data folder into the playground assistant editor window, over where it says”Drop Images To Begin Training”. What you’ll see now is Xcode flash through all the images repeatedly as it attempts to figure out what separates a cat from a dog visually. It takes under 10 seconds for me, and when it finishes you’ll see “SUCCESS: Optimal Solution found”, which means your model is ready. The next step is to figure out how good the model is, and to do that we need to give it some test images. You’ll see a new”Drop Images To Begin Testing”area has appeared, so drag the Testing Data folder into there. These are all images our model hasn’t seen before, so it needs to figure out cat vs dog based on what it learned from our training data. This testing process will take under a second to complete, but when it does you’ll see a breakdown of how well Core ML performed. Obviously we’re looking for 100% accuracy – and indeed that’s precisely what we get with my cat/dog sample data – but if you don’t reach that you might want to try adding more images for Create ML to learn from. Once you’re happy with your finished model, click the disclosure indicator to the right of”ImageClassifier” and provide a little metadata, then click Save to generate a Core ML model that you can then import to your app just like you would do with iOS 10. Machine learning for text analysisAs well as being able to process images, Create ML is also capable of analyzing text. The process quite different in practice, but conceptually it’s the same: provide some training data that teaches Create ML what various text”means”, then provide some testing data that lets you evaluate how well the model performs. Once again, I’ve provided some example training data so you can try it out yourself. This data comes from a paper called A Sentimental Education: Sentiment Analysis Using Subjectivity Summarization Based on Minimum Cuts by Bo Pang and Lillian Lee, published in the Proceedings of the ACL in 2004 – you can find out more here. I’ve taken that data, and converted it into the format Create ML expects so it’s ready to use. You can download it here. If you’d rather create your own data, it’s easy. First, create a new file called yourdata.json. For example, car-prices.json, or reviews.json. Second, give it content like this: 1234567891011121314[ &#123; "text": "Swift is an awesome language", "label": "positive" &#125;, &#123; "text": "Swift is much worse than Objective-C.", "label": "negative" &#125;, &#123; "text": "I really hate Swift", "label": "negative" &#125;] The “text” field is whatever free-form text you want to train with, and the “label” field is what you consider that text to be. In the above example it marks reviews of Swift as being either positive or negative, but in my example data it uses thousands of movie reviews. The next step is to create an MLDataTable from your data, which is just a structure that holds data ready to be processed. Once thats done, we can split the table in two parts so we have some training data and some testing data – again, the 80/20 rule is useful. In code, it looks like this: 12345import CreateMLimport Foundationlet data = try MLDataTable(contentsOf: URL(fileURLWithPath: "/Users/twostraws/Desktop/reviews.json"))let (trainingData, testingData) = data.randomSplit(by: 0.8, seed: 5) You’ll need to change”twostraws” to whatever your username is – I just used a path to the file on my desktop. Now for the important: creating an MLTextClassifier from our data, telling it the name of the text column and label colum: 1let classifier = try MLTextClassifier(trainingData: trainingData, textColumn: "text", labelColumn: "label") At this point you can go ahead and save the finished model, but it’s usually a good idea to check your accuracy first just in case you have too little (or too much!) data. This is done using by reading the number of classification errors that Create ML detected when it was doing its training. These will return a number between 0 (no errors) and 100 (nothing but errors): 12let trainingErrorRate = classifier.trainingMetrics.classificationError * 100let validationErrorRate = classifier.validationMetrics.classificationError * 100 This next line will then pass the testing data through the same model to see how it fares: 12let evaluationMetrics = classifier.evaluation(on: testingData)let errorRate = evaluationMetrics.classificationError * 100 Again, a value of 0 means no errors, which is what we ideally want. Finally, we’re ready to save. This takes two steps: create some metadata describing our model, then writing it to a URL something on our drive. 123let metadata = MLModelMetadata(author: "Paul Hudson", shortDescription: "A model trained to handle sentiment analysis in movie reviews.", version: "1.0")try classifier.write(to: URL(fileURLWithPath: "/Users/twostraws/Desktop/result.mlmodel"), metadata: metadata) Note: All these fancy Create ML tools are only available in Swift – a first from Apple, I think. Grouped alertsNotifications can now be grouped by the system, so that one conversation between friends doesn’t end up occupying a meter’s worth of screen scrolling. Normally you’d create a notification like this: 1234567891011121314func scheduleNotification() &#123; let center = UNUserNotificationCenter.current() let content = UNMutableNotificationContent() content.title = "Late wake up call" content.body = "The early bird catches the worm, but the second mouse gets the cheese." content.categoryIdentifier = "alarm" content.sound = UNNotificationSound.default let trigger = UNTimeIntervalNotificationTrigger(timeInterval: 5, repeats: false) let request = UNNotificationRequest(identifier: UUID().uuidString, content: content, trigger: trigger) center.add(request)&#125; This has changed in iOS 12 thanks to three new properties: The threadIdentifier property describes what group this message belongs to. The summaryArgument property lets you describe to the user what the message relates to – perhaps “from Andrew and Jill”, for example. The summaryArgumentCount is used when each message relates to more than one thing. For example, if you got a message saying “you have five invites” then another saying “you have three invites”, you have two messages but eight invites. So, you’d use 5 and 3 with summaryArgumentCount. If you don’t provide a thread identifier, iOS will automatically group all your notifications together. However, if you do provide one then it will group your notifications by identifier: three from Andrew and Jill, four from Steven, two from your husband, and so on. To try it out, we can create a simple loop: 123456789101112131415for i in 1...10 &#123; let content = UNMutableNotificationContent() content.title = "Late wake up call" content.body = "The early bird catches the worm, but the second mouse gets the cheese." content.categoryIdentifier = "alarm" content.userInfo = ["customData": "fizzbuzz"] content.sound = UNNotificationSound.default content.threadIdentifier = "Andrew" content.summaryArgument = "from Andrew" let trigger = UNTimeIntervalNotificationTrigger(timeInterval: 5, repeats: false) let request = UNNotificationRequest(identifier: UUID().uuidString, content: content, trigger: trigger) center.add(request)&#125; That will create ten notifications, all grouped as “from Andrew”. There’s one extra new option, which is the ability to create and show critical alerts – alerts that be delivered loudly even when the system is set to Do Not Disturb. Critical messages require approval from Apple, and I doubt they will hand out permission easily! ShortcutsiOS 12 introduces the ability for users to trigger actions in our app using Siri, regardless of what the action is. Apple has given us two APIs to use, one very easy and one very difficult. I suspect most folks will go with the easy option to begin with and gauge user feedback – if there’s enough usage they can then invest more time to implement the more complex solution, but there’s no reason to go for that unless you do see good engagement. If you want to try it out, most of the work is done using the same NSUserActivityclass that does so much other work on iOS – Spotlight search, Handoff, and SiriKit. You can create as many of these as you need, attaching them to your view controllers as needed, however, you should only expose shortcuts that can be used at any time – Siri isn’t able to understand when an activity shouldn’t be available. Note: At this time, shortcuts appear to work only on actual devices. First, we need to tell iOS what activities we support. So, open your project’s Info.plist file and add a new row called NSUserActivityTypes. Make it an array, then add a single item to it: com.hackingwithswift.example.showscores. This identifies one activity uniquely to iOS. Now we need to register that activity when the user does something interesting. If you’re just trying it out, try adding this in viewDidAppear(): 123456789101112131415161718// give our activity a unique IDlet activity = NSUserActivity(activityType: "com.hackingwithswift.example.showscores")// give it a title that will be displayed to usersactivity.title = "Show the latest scores"// allow Siri to index this and use it for voice-matched queriesactivity.isEligibleForSearch = trueactivity.isEligibleForPrediction = true// attach some example information that we can use when loading the app from this activityactivity.userInfo = ["message": "Important!"]// give the activity a unique identifier so we can delete it later if we need toactivity.persistentIdentifier = NSUserActivityPersistentIdentifier("abc")// make this activity active for the current view controller – this is what Siri will restore when the activity is triggeredself.userActivity = activity That donates the activity to Siri – tells it what the user was doing so it can try to figure out a pattern. However, we still need to write some code that gets triggered when the action is selected. So, add this to your AppDelegate class: 123456func application(_ application: UIApplication, continue userActivity: NSUserActivity, restorationHandler: @escaping ([UIUserActivityRestoring]?) -&gt; Void) -&gt; Bool &#123; if userActivity.activityType == "com.hackingwithswift.example.showscores" &#123; print("Show scores...") &#125; return true&#125; That’s all our code done, so if you’re using a real device you can run the app to register the shortcut, then add it to Siri. You can do this by going to the Settings app, then selecting Siri &amp; Search. You’ll see there any activities that have been registered by the system, and you can add any you please. You’ll need to record a voice command for each, but that only takes a couple of seconds. For shortcut testing purposes, there are two useful options you should enable. Both are in the Settings app, under Developer: Display Recent Shortcuts, and Display Donations On Lock Screen. These help you check exactly which donations were received by Siri, and will always show your shortcuts in the Siri search rather than whichever ones Siri recommends. Again, these only work on a real device for now. Working with textNSLinguisticTagger was fêted during last year’s WWDC, because it was now powered by Core ML and able to perform all sorts of clever calculations at incredible speed. Well, this year it’s gone. Well, not gone – you can still use it if you want. But we now have a better solution called the Natural Language framework. This is, for all intents and purposes, a Swiftified version of NSLinguisticTagger: apart from being more Swifty, its API is almost identical to the old linguistic tagger code. Let’s start with a simple example. To recognize the language of any text string, large or small, use this: 12345678910111213141516import NaturalLanguagelet string = """He thrusts his fistsAgainst the postsAnd still insistsHe sees the ghosts"""if let lang = NLLanguageRecognizer.dominantLanguage(for: string) &#123; if lang == .english &#123; print("It's English!") &#125; else &#123; print("It's something else...") &#125;&#125; As you can see, dominantLanguage(for:) returns an optional enum matching its best guess language. There are a few things to keep in mind: It looks for the dominant language, so if you provide a text string with multiple languages then it will return the most important one. Sending in very small amounts of text will likely be problematic – without any context, Core ML can’t make a good choice.” The result is optional because it’s possible no language will match your input string. This feature was also possible using NSLinguisticTagger. Another feature that you might recognize is the ability to scan through a sentence, paragraph, or even entire document looking for tokens such as individual words. For example, this code will load a string and break it up into individual words: 1234567891011121314import Foundationimport NaturalLanguagelet string = """He thrusts his fistsAgainst the postsAnd still insistsHe sees the ghosts"""let tokenizer = NLTokenizer(unit: .word)tokenizer.string = stringlet tokens = tokenizer.tokens(for: string.startIndex..&lt;string.endIndex).map &#123; string[$0] &#125; If you’d prefer, you can also loop over each token by hand. This will pass a closure to you, and you need to return either true (“I want to carry on processing”) or false (“I’m done”). Here’s that in code: 12345tokenizer.enumerateTokens(in: string.startIndex ..&lt; string.endIndex) &#123; (range, attrs) -&gt; Bool in print(string[range]) print(attrs) return true&#125; In case you were wondering, the “attrs” value describes the attributes of the token – was it a letter, a symbol, or an emoji, for example. Another useful ability of Natural Language is that it can parse text looking for names of things. For example, this defines a simple text string and creates a name tagger to figure out what’s inside: 1234567891011let text = "Steve Jobs, Steve Wozniak, and Ronald Wayne founded Apple Inc in California."let tagger = NLTagger(tagSchemes: [.nameType])tagger.string = textlet options: NLTagger.Options = [.omitPunctuation, .omitWhitespace, .joinNames]let tags: [NLTag] = [.personalName, .placeName, .organizationName]tagger.enumerateTags(in: text.startIndex..&lt;text.endIndex, unit: .word, scheme: .nameType, options: options) &#123; tag, tokenRange in if let tag = tag, tags.contains(tag) &#123; print("\(text[tokenRange]): \(tag.rawValue)") &#125; return true&#125; As you can see, it asks Natural Language to look for an array of tags: people’s name, any place names, and any organization name. When it finishes, that should produce the following output: 12345Steve Jobs: PersonalNameSteve Wozniak: PersonalNameRonald Wayne: PersonalNameApple Inc: OrganizationNameCalifornia: PlaceName If all this seems eerily familiar to NSLinguisticTagger, you’re spot on: these two are almost identical, although Natural Language has a much nicer API for Swift users. Small extrasThose are the main features, but a few more stick out as being interesting. UIWebView is deprecated for real now. It was marked as “Legacy” in Xcode 9.3, but is now formally deprecated. You should use WKWebView instead – perhaps start with my ultimate guide to WKWebView. There is now UIUserInterfaceStyle.dark for when our iOS app is in dark mode. This cannot currently be activated on an iPhone, but the rest of the infrastructure is there – you can load dark mode images, read UI changes when dark mode is activated, and so on. Any text input files now support password rules to the system generate better, stronger passwords. This isn’t working too well in the current beta, but that should hopefully change soon. The UIImagePNGRepresentation() and UIImageJPEGRepresentation()functions have been replaced with .pngData() and .jpegData(compressionQuality:) methods. ReferencePaul Hudson’s Blog]]></content>
      <tags>
        <tag>iOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SCP Permission denied ?]]></title>
    <url>%2F2018%2F04%2FSCP-Permission-denied%2F</url>
    <content type="text"><![CDATA[I bought a new server today.But there is always an error when I am using SCP. ErrorAs you can see ,Terminal throw a error :scp: /var/www/html/123321.zip: Permission denied So……how to fix that ? FixThe first problem that we should consider is the “folder permissions issue”. This folder was may created by the Root user. Normal users do not have that permission. Solve:These are the examples from the symbolic notationsection given in octal notation: Symbolic Notation Numeric Notation Means ---------- 0000 no permissions -rwx------ 0700 read, write, &amp; execute only for owner -rwxrwx--- 0770 read, write, &amp; execute for owner and group -rwxrwxrwx 0777 read, write, &amp; execute for owner, group and others ---x--x--x 0111 execute --w--w--w- 0222 write --wx-wx-wx 0333 write &amp; execute -r--r--r-- 0444 read -r-xr-xr-x 0555 read &amp; execute -rw-rw-rw- 0666 read &amp; write -rwxr----- 0740 owner can read, write, &amp; execute; group can only read; others have no permissions So , we need 777 1chmod 777 /your_folder So let’s try again: w..wait..what ? Why there is still error ? I am using QCloud. Emm…..Could it be that….? FindFolder permissions are resolved, is it the server’s security settings? So I decide to open all the ports…… let’s try again……. まさか ?Find the sshd_config use nano to open it ,find &amp;&amp;change PermitRootLogin yes exit and save Let’s try again Success !]]></content>
      <tags>
        <tag>SCP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Solutions for Java homework]]></title>
    <url>%2F2018%2F03%2FSolutions-for-Java-homework%2F</url>
    <content type="text"><![CDATA[I will update answers in this page. Exercise 13.11123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051/*(Find the number of days in a month) Write a program that prompts the userto enter the month and year and displays the number of days in the month. Forexample, if the user entered month 2 and year 2012, the program should displaythat February 2012 had 29 days. If the user entered month 3 and year 2015, theprogram should display that March 2015 had 31 days.*/import java.util.Scanner;public class Exercise_03_11 &#123; public static void main(String[] args) &#123; Scanner input = new Scanner(System.in); // Prompt user to enter the month an year System.out.print("Enter the month as integer: "); int month = input.nextInt(); System.out.print("Enter the year as integer: "); int year = input.nextInt(); boolean leapYear = (year % 4 == 0 &amp;&amp; year % 100 != 0) || (year % 400 == 0); // Display the number of days in the month switch (month) &#123; case 1: System.out.println( "January " + year + " had 31 days"); break; case 2: System.out.println("February " + year + " had" + ((leapYear) ? " 29 days" : " 28 days")); break; case 3: System.out.println( "March " + year + " had 31 days"); break; case 4: System.out.println( "April " + year + " had 30 days"); break; case 5: System.out.println( "May " + year + " had 31 days"); break; case 6: System.out.println( "June " + year + " had 30 days"); break; case 7: System.out.println( "July " + year + " had 31 days"); break; case 8: System.out.println( "August " + year + " had 31 days"); break; case 9: System.out.println( "September " + year + " had 30 days"); break; case 10: System.out.println( "October " + year + " had 31 days"); break; case 11: System.out.println( "November " + year + " had 30 days"); break; case 12: System.out.println( "December " + year + " had 31 days"); &#125; &#125;&#125; 4.612345678910111213141516171819202122232425262728293031323334353637383940414243/*(Random points on a circle) Write a program that generates three random pointson a circle centered at (0, 0) with radius 40 and display three angles in a triangleformed by these three points, as shown in Figure 4.7a. (Hint: Generate a randomangle a in radians between 0 and 2PI, as shown in Figure 4.7b and the point determinedby this angle is (r*cos(a), r*sin(a)).)*/public class Exercise_04_06 &#123; public static void main(String[] args) &#123; final double RADIUS = 40; // Generate random angle in radians between 0 and 2PI double angle1 = (Math.random() * (2 * Math.PI)); double angle2 = (Math.random() * (2 * Math.PI)); double angle3 = (Math.random() * (2 * Math.PI)); // Get x and y double x1 = RADIUS * Math.cos(angle1); double y1 = RADIUS * Math.sin(angle1); double x2 = RADIUS * Math.cos(angle2); double y2 = RADIUS * Math.sin(angle2); double x3 = RADIUS * Math.cos(angle3); double y3 = RADIUS * Math.sin(angle3); // Compute three sides double a = Math.sqrt(Math.pow(x2 - x3, 2) + Math.pow(y2 - y3, 2)); double b = Math.sqrt(Math.pow(x1 - x3, 2) + Math.pow(y1 - y3, 2)); double c = Math.sqrt(Math.pow(x1 - x2, 2) + Math.pow(y1 - y2, 2)); // Compute three angles double angleA = Math.toDegrees(Math.acos((a * a - b * b - c * c) / (-2 * b * c))); double angleB = Math.toDegrees(Math.acos((b * b - a * a - c * c) / (-2 * a * c))); double angleC = Math.toDegrees(Math.acos((c * c - b * b - a * a) / (-2 * a * b))); // Display results System.out.println("The three angles are " + Math.round(angleA * 100) / 100.0 + " " + Math.round(angleB * 100) / 100.0 + " " + Math.round(angleC * 100) / 100.0); &#125;&#125; 4.211234567891011121314151617181920212223242526272829303132333435/*(Check SSN) Write a program that prompts the user to enter a Social Securitynumber in the format DDD-DD-DDDD, where D is a digit. Your program shouldcheck whether the input is valid.*/import java.util.Scanner;public class Exercise_04_21 &#123; public static void main(String[] args) &#123; Scanner input = new Scanner(System.in); // Prompt the user to enter a Social Security number System.out.print("Enter a SSN: "); String ssn = input.nextLine(); // Check whether the input is valid boolean isValid = (ssn.length() == 11) &amp;&amp; (Character.isDigit(ssn.charAt(0))) &amp;&amp; (Character.isDigit(ssn.charAt(1))) &amp;&amp; (Character.isDigit(ssn.charAt(2))) &amp;&amp; (ssn.charAt(3) == '-') &amp;&amp; (Character.isDigit(ssn.charAt(4))) &amp;&amp; (Character.isDigit(ssn.charAt(5))) &amp;&amp; (Character.isDigit(ssn.charAt(7))) &amp;&amp; (ssn.charAt(6) == '-') &amp;&amp; (Character.isDigit(ssn.charAt(8))) &amp;&amp; (Character.isDigit(ssn.charAt(9))) &amp;&amp; (Character.isDigit(ssn.charAt(10))); // Display result System.out.println(ssn + " is " + ((isValid) ? "a valid " : "an invalid ") + "social security number"); &#125;&#125; 5.51123456789101112131415161718192021222324252627282930313233/*(Longest common prefix) Write a program that prompts the user to enter twostrings and displays the largest common prefix of the two strings.*/import java.util.Scanner;public class Exercise_05_51 &#123; public static void main(String[] args) &#123; Scanner input = new Scanner(System.in); // Prompt the user to enter two strings System.out.print("Enter the first string: "); String string1 = input.nextLine(); System.out.print("Enter the second string: "); String string2 = input.nextLine(); int index = 0; // Initialize index to 0 String prefix = ""; // Initialize prefix as empty string // Get the largest commmon prefix of the two strings while (string1.charAt(index) == string2.charAt(index)) &#123; prefix += string1.charAt(index); index++; &#125; // Display the result if (prefix.length() &gt; 0) System.out.println("The commmon prefix is " + prefix); else System.out.println(string1 + " and " + string2 + " have no commmon prefix"); &#125;&#125; Exercise 26.3123456789101112131415161718192021222324252627282930313233343536373839404142/*(Palindrome integer) Write the methods with the following headers// Return the reversal of an integer, i.e., reverse(456) returns 654public static int reverse(int number)// Return true if number is a palindromepublic static boolean isPalindrome(int number)Use the reverse method to implement isPalindrome. A number is a palindromeif its reversal is the same as itself. Write a test program that prompts theuser to enter an integer and reports whether the integer is a palindrome.*/import java.util.Scanner;public class Exercise_06_03 &#123; /** Main Method */ public static void main(String[] args) &#123; Scanner input = new Scanner(System.in); // Create a Scanner // Prompt the user to enter an integer System.out.print("Enter an integer: "); int number = input.nextInt(); // Report whether the integer is a palindrome. System.out.println(number + (isPalindrome(number) ? " is " : " is not ") + "a palindrome."); &#125; /** Method isPalindrome returns true if number is a palindrome */ public static boolean isPalindrome(int number) &#123; return number == reverse(number) ? true : false; &#125; /** Method reverse returns the reversal of an integer */ public static int reverse(int number) &#123; String reverse = ""; // Holds reversed number String n = number + ""; // Convert number to string // Reverse string for (int i = n.length() - 1; i &gt;= 0; i--) &#123; reverse += n.charAt(i); &#125; return Integer.parseInt(reverse); // Return reversed integer &#125;&#125; 7.3123456789101112131415161718192021222324252627282930313233343536373839/*(Count occurrence of numbers) Write a program that reads the integers between 1and 100 and counts the occurrences of each. Assume the input ends with 0.Note that if a number occurs more than one time, the plural word “times” is usedin the output.*/import java.util.Scanner;public class Exercise_07_03 &#123; /** Main Method */ public static void main(String[] args) &#123; int[] counts = new int[100]; // Counts the occurrences of numbers // Prompt the user to enter integers between 1 and 100 System.out.print("Enter the integers between 1 and 100: "); // Count occurrence of numbers count(counts); // Display results for (int i = 0; i &lt; counts.length; i++) &#123; if (counts[i] &gt; 0) System.out.println((i + 1) + " occurs " + counts[i] + " time" + (counts[i] &gt; 1 ? "s" : "")); &#125; &#125; /** Method count reads integers between 1 and 100 * and counts the occurrences of each */ public static void count(int[] counts)&#123; Scanner input = new Scanner(System.in); int num; // holds user input do &#123; num = input.nextInt(); if (num &gt;= 1 &amp;&amp; num &lt;= 100) counts[num - 1]++; &#125; while (num != 0); &#125;&#125; 7.30123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051/********************************************************************************** (Pattern recognition: consecutive four equal numbers) Write the following ** method that tests whether the array has four consecutive numbers with the same ** value. ** * * public static boolean isConsecutiveFour(int[] values) ** * * Write a test program that prompts the user to enter a series of integers and ** displays if the series contains four consecutive numbers with the same value. ** Your program should first prompt the user to enter the input size—i.e., the ** number of values in the series. **********************************************************************************/import java.util.Scanner;public class Exercise_07_30 &#123; /** Main method */ public static void main(String[] args) &#123; Scanner input = new Scanner(System.in); // Prompt the user to enter the input size System.out.print("Enter the number of values: "); int[] values = new int[input.nextInt()]; // Promt the user to enter the values System.out.print("Enter the values: "); for (int i = 0; i &lt; values.length; i++) values[i] = input.nextInt(); // Display if the series contains for consecutive numbers System.out.println("The list has" + (isConsecutiveFour(values) ? " " : " no ") + "consecutive fours"); &#125; /** isConsecutiveFour tests whether the array has * four consecutive numbers with the same value */ public static boolean isConsecutiveFour(int[] values) &#123; int count = 1; // number of consecutive numbers for (int i = 0; i &lt; values.length - 1; i++) &#123; if (values[i] == values[i + 1]) count++; if (count &gt;= 4) return true; if (values[i] != values[i + 1]) count = 1; &#125; return false; &#125;&#125; 8.71234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253/********************************************************************************** (Points nearest to each other) Listing 8.3 gives a program that finds two ** points in a two-dimensional space nearest to each other. Revise the program so ** that it finds two points in a three-dimensional space nearest to each other. ** Use a two-dimensional array to represent the points. Test the program using ** the following points: ** double[][] points = &#123;&#123;-1, 0, 3&#125;, &#123;-1, -1, -1&#125;, &#123;4, 1, 1&#125;, ** &#123;2, 0.5, 9&#125;, &#123;3.5, 2, -1&#125;, &#123;3, 1.5, 3&#125;, &#123;-1.5, 4, 2&#125;, ** &#123;5.5, 4, -0.5&#125;&#125;; ** The formula for computing the distance between two points (x1, y1, z1) and ** (x2, y2, z2) is √(x2 - x1)^2 + (y2 - y1)^2 + (z2 - z1)^2. **********************************************************************************/public class Exercise_08_07 &#123; /** Main method */ public static void main(String[] args) &#123; // Initialize array with points double[][] points = &#123;&#123;-1, 0, 3&#125;, &#123;-1, -1, -1&#125;, &#123;4, 1, 1&#125;, &#123;2, 0.5, 9&#125;, &#123;3.5, 2, -1&#125;, &#123;3, 1.5, 3&#125;, &#123;-1.5, 4, 2&#125;, &#123;5.5, 4, -0.5&#125;&#125;; // p1 and p2 are the indices in the points' array int p1 = 0, p2 = 1, p3 = 3; // Initial two points double shortestDistance = distance(points[p1][0], points[p1][1], points[p1][2], points[p2][0], points[p2][p1], points[p3][p2]); // Initialize shortest Distance // Compute distance for every two points for (int i = 0; i &lt; points.length; i++) &#123; for (int j = i + 1; j &lt; points.length; j++) &#123; double distance = distance(points[i][0], points[i][1], points[i][2], points[j][0], points[j][1], points[j][2]); // Find distance if (shortestDistance &gt; distance) &#123; p1 = i; // Update p1 p2 = j; // Update p2 shortestDistance = distance; // Update shortestDistance &#125; &#125; &#125; // Display result System.out.println("The closest two points are " + "(" + points[p1][0] + ", " + points[p1][1] + ") and (" + points[p2][0] + ", " + points[p2][1] + ")"); &#125; /** Compute the distance between two points (x1, y1) and (x2, y2)*/ public static double distance( double x1, double y1, double z1, double x2, double y2, double z2) &#123; return Math.sqrt(Math.pow(x2 - x1, 2) + Math.pow(y2 - y1, 2) + Math.pow(y2 - y1, 2)); &#125;&#125; 8.14123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176/********************************************************************************** (Explore matrix) Write a program that prompts the user to enter the length of ** a square matrix, randomly fills in 0s and 1s into the matrix, prints the ** matrix, and finds the rows, columns, and diagonals with all 0s or 1s. **********************************************************************************/import java.util.Scanner;public class Exercise_08_14 &#123; /** Main method */ public static void main(String[] args) &#123; // Create a square matrix int[][] matrix = getMatrix(); // Display matrix print(matrix); // Display results int[] rows = allRow(matrix); int count = 0; for (int i = 0; i &lt; rows.length; i++) &#123; if (rows[i] &gt;= 0) System.out.println("All " + rows[i] + "s on row " + (i + 1)); else count++; if (count == rows.length) System.out.println("No same numbers on a row"); &#125; int[] columns = allColumn(matrix); count = 0; for (int i = 0; i &lt; columns.length; i++) &#123; if (columns[i] &gt;= 0) System.out.println("All " + columns[i] + "s on column " + (i + 1)); else count++; if (count == columns.length) System.out.println("No same numbers on a column"); &#125; int n = allMajorDiagonal(matrix); switch (n) &#123; case 0: case 1: System.out.println("All " + n + "s on the major diagonal"); break; default: System.out.println("No same numbers on the major diagonal"); &#125; n = allSubDiagonal(matrix); switch (n) &#123; case 0: case 1: System.out.println("All " + n + "s on the sub-diagonal"); break; default: System.out.println("No same numbers on the sub-diagonal"); &#125; &#125; /** allSubDiagonal returns 0 or 1 if all 0s or 1s on the sub-diagonal, otherwise returns -1 */ public static int allSubDiagonal(int[][] m) &#123; int[] count = new int[2]; // Counts 0s and 1s // Initialize count array to 0; count[0] = 0; count[1] = 0; for (int i = 0, j = m.length - 1; i &lt; m.length; i++, j--) &#123; count[m[i][j]]++; if (count[0] == m.length) return 0; if (count[1] == m.length) return 1; &#125; return -1; &#125; /** allMajorDiagonal returns 0 or 1 if all 0s or 1s on the major diagonal, otherwise returns -1 */ public static int allMajorDiagonal(int[][] m) &#123; int[] count = new int[2]; // Counts 0s and 1s // Initialize count array to 0; count[0] = 0; count[1] = 0; for (int i = 0; i &lt; m.length; i++) &#123; count[m[i][i]]++; if (count[0] == m.length) return 0; if (count[1] == m.length) return 1; &#125; return -1; &#125; /** allColumn returns 0 or 1 if a column has all 0s or 1s, otherwise returns -1 */ public static int[] allColumn(int[][] m) &#123; // Initilize array to hold results with -1 int[] result = new int[m.length]; for (int i = 0; i &lt; result.length; i++) &#123; result[i] = -1; &#125; int[] count = new int[2]; // Counts 0s and 1s for (int i = 0; i &lt; m.length; i++) &#123; // Initialize count array to 0; count[0] = 0; count[1] = 0; for (int j = 0; j &lt; m[i].length; j++) &#123; count[m[j][i]]++; if (count[0] &lt; j + 1 &amp;&amp; count[1] &lt; j + 1) &#123; break; &#125; &#125; if (count[0] &gt;= m.length || count[1] &gt;= m.length) result[i] = count[0] &gt; count[1] ? 0 : 1; &#125; return result; &#125; /** allRow returns 0 or 1 if a row has all 0s or 1s, otherwise returns -1 */ public static int[] allRow(int[][] m) &#123; // Initilize array to hold results with -1 int[] result = new int[m.length]; for (int i = 0; i &lt; result.length; i++) &#123; result[i] = -1; &#125; int[] count = new int[2]; // Counts 0s and 1s for (int i = 0; i &lt; m.length; i++) &#123; // Initialize count array to 0; count[0] = 0; count[1] = 0; for (int j = 0; j &lt; m[i].length; j++) &#123; count[m[i][j]]++; if (count[0] &lt; j + 1 &amp;&amp; count[1] &lt; j + 1) &#123; break; &#125; &#125; if (count[0] &gt;= m.length || count[1] &gt;= m.length) result[i] = count[0] &gt; count[1] ? 0 : 1; &#125; return result; &#125; /** getMatrix prompts the user to enter the length of a square matrix and randomly fills in 0s and 1s into the matrix, then returns it */ public static int[][] getMatrix() &#123; Scanner input = new Scanner(System.in); System.out.print("Enter the size for the matrix: "); int size = input.nextInt(); int[][] m = new int[size][size]; for (int i = 0; i &lt; m.length; i++) &#123; for (int j = 0; j &lt; m[i].length; j++) &#123; m[i][j] = (int)(Math.random() * 2); &#125; &#125; return m; &#125; /** print displays all elements in a matrix */ public static void print(int[][] m) &#123; for (int i = 0; i &lt; m.length; i++) &#123; for (int j = 0; j &lt; m[i].length; j++) &#123; System.out.print(m[i][j]); &#125; System.out.println(); &#125; &#125;&#125; Exercise 39.1Test1234567891011121314151617181920212223242526272829303132333435363738394041424344/********************************************************************************** (The Rectangle class) Following the example of the Circle class in Section 9.2,** design a class named Rectangle to represent a rectangle. The class contains: ** ** ■ Two double data fields named width and height that specify the width and ** height of the rectangle. The default values are 1 for both width and height. ** ■ A no-arg constructor that creates a default rectangle. ** ■ A constructor that creates a rectangle with the specified width and height. ** ■ A method named getArea() that returns the area of this rectangle. ** ■ A method named getPerimeter() that returns the perimeter. ** ** Draw the UML diagram for the class and then implement the class. Write a test ** program that creates two Rectangle objects—one with width 4 and height 40 ** and the other with width 3.5 and height 35.9. Display the width, height, area, ** and perimeter of each rectangle in this order. **********************************************************************************/public class Exercise_09_01 &#123; /** Main method */ public static void main(String[] args) &#123; // Create a Rectangle with width 4 and height 40 Rectangle rectangle1 = new Rectangle(4, 40); // Create a Rectangle with width 3.5 and height 35.9 Rectangle rectangle2 = new Rectangle(3.5, 35.9); // Display the width, height, area, and perimeter of rectangle1 System.out.println("\n Rectangle 1"); System.out.println("-------------"); System.out.println("Width: " + rectangle1.width); System.out.println("Height: " + rectangle1.height); System.out.println("Area: " + rectangle1.getArea()); System.out.println("Perimeter: " + rectangle1.getPerimeter()); // Display the width, height, area, and perimeter of rectangle2 System.out.println("\n Rectangle 2"); System.out.println("-------------"); System.out.println("Width: " + rectangle2.width); System.out.println("Height: " + rectangle2.height); System.out.println("Area: " + rectangle2.getArea()); System.out.println("Perimeter: " + rectangle2.getPerimeter()); &#125;&#125; Rectangle12345678910111213141516171819202122232425262728293031323334353637383940//UML Class Diagram /*************************************************** Rectangle * * ------------------------------------------------* * width: double ** height: double * * Rectangle() * * Rectangle(newWidth: double, newHeight: double) ** getArea(): double ** getPerimeter(): double ****************************************************/// Define the Rectangle classpublic class Rectangle &#123; double width; // Width of rectangle double height; // Height of rectangle /** A no-arg constructor that creates a default rectangle */ Rectangle() &#123; width = 1; height = 1; &#125; /** A constructor that creates a rectangle with the specified width and height */ Rectangle(double newWidth, double newHeight) &#123; width = newWidth; height = newHeight; &#125; /** Return the area of this rectangle */ double getArea() &#123; return width * height; &#125; /** Return the perimeter of this rectangle */ double getPerimeter() &#123; return 2 * (width + height); &#125;&#125; 9.2Test123456789101112131415161718192021222324252627282930313233343536/********************************************************************************** (The Stock class) Following the example of the Circle class in Section 9.2, ** design a class named Stock that contains: ** ** ■ A string data field named symbol for the stock’s symbol. ** ■ A string data field named name for the stock’s name. ** ■ A double data field named previousClosingPrice that stores the stock ** price for the previous day. ** ■ A double data field named currentPrice that stores the stock price for the ** current time. ** ■ A constructor that creates a stock with the specified symbol and name. ** ■ A method named getChangePercent() that returns the percentage changed from ** previousClosingPrice to currentPrice. ** ** Draw the UML diagram for the class and then implement the class. Write a test ** program that creates a Stock object with the stock symbol ORCL, the name ** Oracle Corporation, and the previous closing price of 34.5. Set a new current ** price to 34.35 and display the price-change percentage. **********************************************************************************/public class Exercise_09_02 &#123; /** Main method */ public static void main(String[] args) &#123; // Create a Stock object with the stock // symbol ORCL, the name Oracle Corporation Stock stock = new Stock("ORCL", "Oracle Corporation"); stock.previousClosingPrice = 34.5; stock.currentPrice = 34.35; // Display the price-change percentage System.out.println("\nStock name: " + stock.name); System.out.println("Stock symbol: " + stock.symbol); System.out.printf("Price-change percentage: %.2f%%\n", stock.getChangePercent()); &#125;&#125; Stock12345678910111213141516171819202122232425262728293031//UML diagram /********************************************* Stock **-------------------------------------------** symbol: String ** name: String ** previousClosingPrice: double ** currentPrice: double ** Stock(newSymbol: String, newName: String) ** getChangePercent(): double *********************************************/// Define the stock classpublic class Stock &#123; String symbol; // The stock's symbol String name; // The stock's name double previousClosingPrice; // The stock price for the previous day double currentPrice; // The stock price for the current time // Construct a stock with a specified symbol and name Stock(String newSymbol, String newName) &#123; symbol = newSymbol; name = newName; &#125; // Return the percentage changed from previousClosingPrice to currentPrice double getChangePercent() &#123; return ((currentPrice - previousClosingPrice) / previousClosingPrice) * 100; &#125;&#125; 9.6Test123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869/********************************************************************************** (Stopwatch) Design a class named StopWatch. The class contains: ** ** ■ Private data fields startTime and endTime with getter methods. ** ■ A no-arg constructor that initializes startTime with the current time. ** ■ A method named start() that resets the startTime to the current time. ** ■ A method named stop() that sets the endTime to the current time. ** ■ A method named getElapsedTime() that returns the elapsed time for the ** stopwatch in milliseconds. ** ** Draw the UML diagram for the class and then implement the class. Write a test ** program that measures the execution time of sorting 100,000 numbers using ** selection sort. **********************************************************************************/public class Exercise_09_06 &#123; /** Main method */ public static void main(String[] args) &#123; // Create a StopWatch object StopWatch stopWatch = new StopWatch(); // create array of 100,000 random numbers int[] randomArray = getArray(); // Invoke the start method in StopWatch class stopWatch.start(); // Sort array selectionSort(randomArray); // Invoke the stop method in StopWatch class stopWatch.stop(); // Display the execution time System.out.println("The execution time of sorting 100,000 " + "numbers using selection sort: " + stopWatch.getElapsedTime() + " milliseconds"); &#125; /** getArray creates and returns an array of 100,000 random numbers */ public static int[] getArray() &#123; // Create an array of length 100,000 int[] array = new int[100000]; for (int i = 0; i &lt; array.length; i++) &#123; array[i] = (int)(Math.random() * 100000); &#125; return array; &#125; /** selectionSort performs a selection sort on an array */ public static void selectionSort(int[] array) &#123; for (int i = 0; i &lt; array.length - 1; i++) &#123; int min = array[i]; int minIndex = i; for (int j = i + 1; j &lt; array.length; j++) &#123; if (array[j] &lt; min) &#123; min = array[j]; minIndex = j; &#125; &#125; if (i != minIndex) &#123; array[minIndex] = array[i]; array[i] = min; &#125; &#125; &#125; &#125; StopWatch1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950/***************************** StopWatch **---------------------------** -startTime: long ** -endTime: long ** +StopWatch() ** +start() ** +stop() ** +getElapsedTime(): long ** +getStratTime(): long ** +getEndTime(): long *****************************/// Implement StopWatch classpublic class StopWatch &#123; private long startTime; // Start time private long endTime; // End time // no-arg constructor that initializes // startTime with the current time StopWatch() &#123; startTime = System.currentTimeMillis(); &#125; // Resets the startTime to the current time public void start() &#123; startTime = System.currentTimeMillis(); &#125; // Sets the endTime to the current time public void stop() &#123; endTime = System.currentTimeMillis(); &#125; // Returns the elapsed time for // the stopwatch in milliseconds public long getElapsedTime() &#123; return getEndTime() - getStratTime(); &#125; // Return start time public long getStratTime() &#123; return startTime; &#125; // Return end time public long getEndTime() &#123; return endTime; &#125;&#125; 9.9Test123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051/********************************************************************************** (Geometry: n-sided regular polygon) In an n-sided regular polygon, all sides ** have the same length and all angles have the same degree (i.e., the polygon is ** both equilateral and equiangular). Design a class named RegularPolygon that ** contains: ** ** ■ A private int data field named n that defines the number of sides in the ** polygon with default value 3. ** ■ A private double data field named side that stores the length of the side ** with default value 1. ** ■ A private double data field named x that defines the x-coordinate of the ** polygon’s center with default value 0. ** ■ A private double data field named y that defines the y-coordinate of the ** polygon’s center with default value 0. ** ■ A no-arg constructor that creates a regular polygon with default values. ** ■ A constructor that creates a regular polygon with the specified number of ** sides and length of side, centered at (0, 0). ** ■ A constructor that creates a regular polygon with the specified number of ** sides, length of side, and x- and y-coordinates. ** ■ The accessor and mutator methods for all data fields. ** ■ The method getPerimeter() that returns the perimeter of the polygon. ** ■ The method getArea() that returns the area of the polygon. The formula for ** computing the area of a regular polygon is Area = (n x s^2) / (4 x tan(π / n)** ** Draw the UML diagram for the class and then implement the class. Write a test ** program that creates three RegularPolygon objects, created using the no-arg ** constructor, using RegularPolygon(6, 4), and using RegularPolygon(10, 4, 5.6, ** 7.8). For each object, display its perimeter and area. **********************************************************************************/public class Exercise_09_09 &#123; /** Main method */ public static void main(String[] args) &#123; // Create three RegularPolygon objects RegularPolygon regularPolygon1 = new RegularPolygon(); RegularPolygon regularPolygon2 = new RegularPolygon(6, 4); RegularPolygon regularPolygon3 = new RegularPolygon(10, 4, 5.6, 7.8); // Display perimeter and area of each object System.out.println("\n--------------------------------------------------"); System.out.println("| Regular Polygon Objects | Perimeter | Area |"); System.out.println("--------------------------------------------------"); System.out.printf( "| Object# 1 |%8.2f |%6.2f |\n", regularPolygon1.getPerimeter(), regularPolygon1.getArea()); System.out.printf( "| Object# 2 |%8.2f |%6.2f |\n", regularPolygon2.getPerimeter(), regularPolygon2.getArea()); System.out.printf( "| Object# 3 |%8.2f |%6.2f |\n", regularPolygon3.getPerimeter(), regularPolygon3.getArea()); System.out.println("--------------------------------------------------"); &#125;&#125; RegularPolygon123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107// UML diagram/*************************************************************** RegularPolygon ***************************************************************** -n: int ** -side: double ** -x: double ** -y: double ** +RegularPolygon() ** +RegularPolygon(n: int, side: double) ** +RegularPolygon(n: int, side: double, x: double, y: double) ** +setN(newN: int) ** +setSide(newSide: double) ** +setX(newX: double) * * +setY(newY: double) * * +getN(): int ** +getSide(): double ** +getX(): double * * +getY(): double * * +getPerimeter(): double ** +getArea(): doulbe * **************************************************************/// Implement RegularPolygon classpublic class RegularPolygon &#123; /** Data fields */ private int n; private double side; private double x; private double y; /** Constructors */ /** Creates a regular polygon with default values */ RegularPolygon() &#123; n = 3; side = 1; x = y = 0; &#125; /** Creates a regular polygon with the specified number /* of sides and length of side, centered at (0, 0) */ RegularPolygon(int newN, double newSide) &#123; n = newN; side = newSide; x = y = 0; &#125; /** creates a regular polygon with the specified number /* of sides, length of side, and x- and y-coordinates */ RegularPolygon(int newN, double newSide, double newX, double newY) &#123; n = newN; side = newSide; x = newX; y = newY; &#125; /** Methods */ /** Sets new n */ public void setN(int newN) &#123; n = newN; &#125; /** Sets new length of the side */ public void setSide(double newSide) &#123; side = newSide; &#125; /** Sets new x-coordinate */ public void setX(double newX) &#123; x = newX; &#125; /** Sets new y-coordinate */ public void setY(double newY) &#123; y = newY; &#125; /** Returns n */ public int getN() &#123; return n; &#125; /** Returns the length of the side */ public double getSide() &#123; return side; &#125; /** Returns x-coordinate */ public double getX() &#123; return x; &#125; /** Returns y-coordinate */ public double getY() &#123; return y; &#125; /** Returns the perimeter of the polygon */ public double getPerimeter() &#123; return side * n; &#125; /** Returns the area of the polygon */ public double getArea() &#123; return (n * Math.pow(side, 2)) / (4 * Math.tan(Math.PI / n)); &#125;&#125; 9.13Test12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152/********************************************************************************** (The Location class) Design a class named Location for locating a maximal ** value and its location in a two-dimensional array. The class contains public ** data fields row, column, and maxValue that store the maximal value and its ** indices in a two-dimensional array with row and column as int types and ** maxValue as a double type. ** ** Write the following method that returns the location of the largest element in ** a two-dimensional array: ** ** public static Location locateLargest(double[][] a) ** ** The return value is an instance of Location. Write a test program that prompts ** the user to enter a two-dimensional array and displays the location of the ** largest element in the array. **********************************************************************************/import java.util.Scanner;public class Exercise_09_13 &#123; /** Main method */ public static void main(String[] args) &#123; // Create a Scanner object Scanner input = new Scanner(System.in); // Prompt the user to enter a two-dimensional array System.out.print("Enter the number of rows and columns in the array: "); int rows = input.nextInt(); int columns = input.nextInt(); // Create a matrix double[][] array = new double[rows][columns]; System.out.println("Enter the array: "); for (int i = 0; i &lt; array.length; i++) &#123; for (int j = 0; j &lt; array[i].length; j++) &#123; array[i][j] = input.nextDouble(); &#125; &#125; // Get and instance of Loacation Location max = locateLargest(array); // Display the location of the largest element in the array System.out.println("The location of the largest element is " + max.maxValue + " at (" + max.row + ", " + max.column + ")"); &#125; /** locateLargest returns an instance of Location */ public static Location locateLargest(double[][] a) &#123; return new Location(a); &#125;&#125; Location123456789101112131415161718192021222324252627282930313233// UML Diagram/******************************** Location **------------------------------** +row: int ** +column: int ** +maxValue: double ** +Location(array: double[][]) ********************************/// Implement Location classpublic class Location &#123; // Data fields int row; // Row index of maximal value int column; // Column index of maximal value double maxValue; // Maximal value /** Constructs a default Loction object */ Location(double[][] a) &#123; maxValue = a[0][0]; row = 0; column = 0; for (int i = 0; i &lt; a.length; i++) &#123; for (int j = 0; j &lt; a[i].length; j++) &#123; if (a[i][j] &gt; maxValue) &#123; maxValue = a[i][j]; row = i; column = j; &#125; &#125; &#125; &#125;&#125; Exercise 410.28 (book inside)12345public static String reverseStr(String orignalString)&#123; StringBuilder newString = new StringBuilder(orignalString); newString.reverse(); return newString.toString(); &#125; 10.29 (book inside)12345public static String deleteStr(String orignalString)&#123; StringBuilder newString = new StringBuilder(orignalString); newString.delete(4,10); return newString.toString();&#125; 10.1Test1234567891011121314151617181920212223242526272829303132333435363738394041/********************************************************************************** (The Time class) Design a class named Time. The class contains: ** ■ The data fields hour, minute, and second that represent a time. ** ■ A no-arg constructor that creates a Time object for the current time. (The ** values of the data fields will represent the current time.) ** ■ A constructor that constructs a Time object with a specified elapsed time ** since midnight, January 1, 1970, in milliseconds. (The values of the data ** fields will represent this time.) ** ■ A constructor that constructs a Time object with the specified hour, minute, ** and second. ** ■ Three getter methods for the data fields hour, minute, and second, ** respectively. ** ■ A method named setTime(long elapseTime) that sets a new time ** for the object using the elapsed time. For example, if the elapsed time is ** 555550000 milliseconds, the hour is 10, the minute is 19, and the second is ** 10. ** ** Draw the UML diagram for the class and then implement the class. Write ** a test program that creates two Time objects (using new Time() and new ** Time(555550000)) and displays their hour, minute, and second in the format ** hour:minute:second. ** (Hint: The first two constructors will extract the hour, minute, and second ** from the elapsed time. For the no-arg constructor, the current time can be ** obtained using System.currentTimeMillis(), as shown in Listing 2.7, ** ShowCurrentTime.java.) **********************************************************************************/public class Exercise_10_01 &#123; /** Main method */ public static void main(String[] args) &#123; // Create two Time objects Time time1 = new Time(); Time time2 = new Time(555550000); // Display Time objects hour, minute, and // second in the format hour:minute:second System.out.println(time1.getHour() + ":" + time1.getMinute() + ":" + time1. getSecond()); System.out.println(time2.getHour() + ":" + time2.getMinute() + ":" + time2. getSecond()); &#125;&#125; Time12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576 //UML diagram/************************************************* Time **-----------------------------------------------** -hour: long ** -minute: long ** -second: long ** Time() ** Time(elapseTime: long) ** Time(hour: long, minute: long, second: long) ** getHour(): long ** getMinute(): long ** getSecond(): long ** setTime(elapseTime: long) *************************************************/// Implement Time classpublic class Time &#123; // Data fields private long hour; private long minute; private long second; // Creates a Time object for the current time Time() &#123; this(0); &#125; // Constructs a Time object with a specified elapsed // time since midnight, January 1, 1970, in milliseconds. Time(long elapseTime) &#123; setTime(elapseTime); &#125; // Constructs a Time object with the specified hour, minute, and second Time(long hour, long minute, long second) &#123; this.hour = hour; this.minute = minute; this.second = second; &#125; // Return hour public long getHour() &#123; return hour; &#125; // Return minute public long getMinute() &#123; return minute; &#125; // Return second public long getSecond() &#123; return second; &#125; // Sets a new time for the object using the elapsed time public void setTime(long elapseTime) &#123; long totalMilliseconds = System.currentTimeMillis(); long totalSeconds = totalMilliseconds / 1000; second = totalSeconds % 60; long totalMinutes = totalSeconds / 60; minute = totalMinutes % 60; long totalHours = totalMinutes / 60; hour = totalHours % 24; if (elapseTime &gt; 0) &#123; totalSeconds = elapseTime / 1000; second += totalSeconds % 60; totalMinutes = totalSeconds / 60; minute += totalMinutes % 60; totalHours = totalMinutes / 60; hour += totalHours % 24; &#125; &#125;&#125; 10.4Test12345678910111213141516171819202122232425262728293031/********************************************************************************** (The MyPoint class) Design a class named MyPoint to represent a point with ** x- and y-coordinates. The class contains: ** ** ■ The data fields x and y that represent the coordinates with getter ** methods. ** ■ A no-arg constructor that creates a point (0, 0). ** ■ A constructor that constructs a point with specified coordinates. ** ■ A method named distance that returns the distance from this point to a ** specified point of the MyPoint type. ** ■ A method named distance that returns the distance from this point to ** another point with specified x- and y-coordinates. ** ** Draw the UML diagram for the class and then implement the class. Write a test ** program that creates the two points (0, 0) and (10, 30.5) and displays the ** distance between them. **********************************************************************************/public class Exercise_10_04 &#123; /** Main method */ public static void main(String[] args) &#123; // Create two points MyPoint point1 = new MyPoint(); MyPoint point2 = new MyPoint(10, 30.5); // Display the distance between point1 and point2 System.out.println("The distance between (" + point1.getX() + ", " + point1.getY() + ") and (" + point2.getX() + ", " + point2.getY() + ") is: " + point1.distance(point2)); &#125;&#125; MyPoint1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253/*********************************** MyPoint **---------------------------------** -x: double ** -y: double ** +MyPoint() ** +MyPoint(x: double, y: double) ** +getX(): double ** +getY(): double ** +distance(myPoint: MyPoint) ** +distance(x: double, y: double) ***********************************/// Implement MyPoint classpublic class MyPoint &#123; // Data fields private double x; private double y; /** Constructor that creates a point (0, 0) */ MyPoint() &#123; this(0, 0); &#125; /** Constructs a point with specified coordinates */ MyPoint(double x, double y) &#123; this.x = x; this.y = y; &#125; /** Return x */ public double getX() &#123; return x; &#125; /** Return y */ public double getY() &#123; return y; &#125; /** Returns the distance from this point to * a specified point of the MyPoint type */ public double distance(MyPoint myPoint) &#123; return Math.sqrt(Math.pow(myPoint.getX() - x, 2) + Math.pow(myPoint.getY() - y, 2)); &#125; /** Returns the distance from this point to another * point with specified x- and y-coordinates. */ public double distance(double x, double y) &#123; return distance(new MyPoint(x, y)); &#125;&#125; 10.7Test1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192/********************************************************************************** (Game: ATM machine) Use the Account class created in Programming Exercise ** 9.7 to simulate an ATM machine. Create ten accounts in an array with id ** 0, 1, . . . , 9, and initial balance $100. The system prompts the user to ** enter an id. If the id is entered incorrectly, ask the user to enter a correct ** id. Once an id is accepted, the main menu is displayed as shown in the sample ** run. You can enter a choice 1 for viewing the current balance, 2 for ** withdrawing money, 3 for depositing money, and 4 for exiting the main menu. ** Once you exit, the system will prompt for an id again. Thus, once the system ** starts, it will not stop. **********************************************************************************/import java.util.Scanner;public class Exercise_10_07 &#123; /** Main method */ public static void main(String[] args) &#123; // Create a Scanner Scanner input = new Scanner(System.in); // Create ten accounts in an array Account[] accounts = new Account[10]; // Initialize accounts with balance initialBalance(accounts); // Once the system starts, it will not stop do &#123; // Prompt user to enter an id System.out.print("Enter an id: "); int id = input.nextInt(); if (isValidID(id, accounts)) &#123; int choice; do &#123; // Get user choice choice = displayMainMenu(input); if (isTransaction(choice)) &#123; executeTransaction(choice, accounts, id, input); &#125; &#125; while (choice != 4); // If 4 exit main menu &#125; // Once you exit, the system will prompt for an id again &#125; while (true); &#125; /** Initialize accounts with balance of 100 */ public static void initialBalance(Account[] a) &#123; int initialBalance = 100; for (int i = 0; i &lt; a.length; i++) &#123; a[i] = new Account(i, initialBalance); &#125; &#125; /** Return true if choice is a transaction */ public static boolean isTransaction(int choice) &#123; return choice &gt; 0 &amp;&amp; choice &lt; 4; &#125; /** Return true if ID is valid */ public static boolean isValidID(int id, Account[] a) &#123; for (int i = 0; i &lt; a.length; i++) &#123; if (id == a[i].getId()) return true; &#125; return false; &#125; /** Display main menu */ public static int displayMainMenu(Scanner input) &#123; System.out.print( "\nMain menu\n1: check balance\n2: withdraw" + "\n3: deposit\n4: exit\nEnter a choice: "); return input.nextInt(); &#125; /** Execute a Transaction */ public static void executeTransaction( int c, Account[] a, int id, Scanner input) &#123; switch (c) &#123; case 1: // Viewing the current balance System.out.println("The balance is " + a[id].getBalance()); break; case 2: // Withdraw money System.out.print("Enter an amount to withdraw: "); a[id].withdraw(input.nextDouble()); break; case 3: // Deposit money System.out.print("Enter an amount to deposit: "); a[id].deposit(input.nextDouble()); &#125; &#125;&#125; Acount123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107/********************************************************* Account **-------------------------------------------------------** -id: int ** -balance: double ** -annualInterestRate: double ** --------------------------- ** -dateCreated: String ** +Account() ** +Account(newid: int, newBalance: double) ** +setId(newId: int) ** +setBalance(newBalance: double) ** +setAnnualInterestRate(newAnnualInterestRate: double) ** +getId(): int ** +getBalance(): double ** +getAnnualInterestRate(): double ** +getDateCreated(): String ** +getMonthlyInterestRate(): double ** +getMonthlyInterest(): double ** +withdraw(amount: double) ** +deposit(amount: double) *********************************************************/// Implement the Account classimport java.util.Date;public class Account &#123; // Data fields private int id; private double balance; private static double annualInterestRate; private Date dateCreated; // Constructors /** Creates a default account */ Account() &#123; id = 0; balance = 0; annualInterestRate = 0; dateCreated = new Date(); &#125; /** Creates an account with the specified id and initial balance */ Account(int newId, double newBalance) &#123; id = newId; balance = newBalance; dateCreated = new Date(); &#125; // Mutator methods /** Set id */ public void setId(int newId) &#123; id = newId; &#125; /** Set balance */ public void setBalance(double newBalance) &#123; balance = newBalance; &#125; /** Set annualInterestRate */ public void setAnnualInterestRate(double newAnnualInterestRate) &#123; annualInterestRate = newAnnualInterestRate; &#125; // Accessor methods /** Return id */ public int getId() &#123; return id; &#125; /** Return balance */ public double getBalance() &#123; return balance; &#125; /** Return annualInterestRate */ public double getAnnualInterestRate() &#123; return annualInterestRate; &#125; /** Return dateCreated */ public String getDateCreated() &#123; return dateCreated.toString(); &#125; /** Return monthly interest rate */ public double getMonthlyInterestRate() &#123; return annualInterestRate / 12; &#125; // Methods /** Return monthly interest */ public double getMonthlyInterest() &#123; return balance * (getMonthlyInterestRate() / 100); &#125; /** Decrease balance by amount */ public void withdraw(double amount) &#123; balance -= amount; &#125; /** Increase balance by amount */ public void deposit(double amount) &#123; balance += amount; &#125;&#125; 10.9Test12345678910111213141516171819202122232425262728293031323334353637/********************************************************************************** (The Course class) Revise the Course class as follows: ** ** ■ The array size is fixed in Listing 10.6. Improve it to automatically ** increase the array size by creating a new larger array and copying the ** contents of the current array to it. ** ■ Implement the dropStudent method. ** ■ Add a new method named clear() that removes all students from the ** course. ** ** Write a test program that creates a course, adds three students, removes one, ** and displays the students in the course. **********************************************************************************/public class Exercise_10_09 &#123; /** Main method */ public static void main(String[] args) &#123; // Create a course Course math101 = new Course("math101"); // Add three students math101.addStudent("Mark"); math101.addStudent("Tom"); math101.addStudent("Joan"); // remove one student math101.dropStudent("Tom"); // Displays the students in the course System.out.println("\nThe students in the course " + math101.getCourseName() + ":"); String[] students = math101.getStudents(); for (int i = 0; i &lt; math101.getNumberOfStudents(); i++) &#123; System.out.print(students[i] + " "); &#125; System.out.println(); &#125;&#125; Course1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374public class Course &#123; private String courseName; private String[] students = new String[1]; private int numberOfStudents; public Course(String courseName) &#123; this.courseName = courseName; &#125; public void addStudent(String student) &#123; // Automatically increases the array size if (numberOfStudents == students.length) &#123; String[] a = new String[students.length + 1]; for (int i = 0; i &lt; numberOfStudents; i++) &#123; a[i] = students[i]; &#125; students = a; &#125; students[numberOfStudents] = student; numberOfStudents++; &#125; public String[] getStudents() &#123; return students; &#125; public int getNumberOfStudents() &#123; return numberOfStudents; &#125; public String getCourseName() &#123; return courseName; &#125; /** Remove a student from a course */ public void dropStudent(String student) &#123; int index = findStudent(student); if (index &gt;= 0) &#123; dropStudent(index); &#125; else &#123; System.out.println(student + " is not in the course: " + courseName); &#125; &#125; /** deletes a Student */ private void dropStudent(int index) &#123; String[] s = new String[students.length - 1]; for (int i = 0, j = 0; i &lt; s.length; i++, j++) &#123; if (i == index) &#123; j++; &#125; s[i] = students[j]; &#125; this.students = s; numberOfStudents--; &#125; /** removes all students from the course */ public void clear() &#123; students = new String[1]; numberOfStudents = 0; &#125; /** Returns the index if student is found. Otherwise returns -1 */ private int findStudent(String student) &#123; for (int i = 0; i &lt; numberOfStudents; i++) &#123; if (students[i].equals(student)) &#123; return i; &#125; &#125; return -1; &#125;&#125; Exercise 511.11 (book inside)12345678910111213141516171819202122232425262728293031public class Circle &#123; private double radius; public Circle (double radius) &#123; //radius = radius;👇 this.radius = radius; &#125; public double getRadius() &#123; return radius; &#125; public double getArea() &#123; return radius * radius * Math.PI; &#125; class B extends Circle &#123; private double length; B(double radius, double length) &#123; //Circle(radius)👇 super(radius); length = length; &#125; @Override public double getArea() &#123; return getArea() * length; &#125; &#125;&#125; 11.20 (book inside)123456789101112131415161718public class Test&#123; public static void main(String[] args) &#123; Integer[] list1 = &#123;12, 24,55, 1&#125;; Double[] list2 = &#123;12.4, 24.0, 55.2, 1.0&#125;; //int[] list3 = &#123;1, 2, 3&#125;;👇 Object[] list3 = &#123;1, 2, 3&#125;; printArray(list1); printArray(list2); printArray(list3); &#125; public static void printArray(Object[] list) &#123; for (Object o: list) &#123; System.out.print(o + " "); &#125; System.out.println(); &#125;&#125; 11.2Test1234567891011121314151617181920212223242526272829303132333435363738394041/********************************************************************************** (The Person, Student, Employee, Faculty, and Staff classes) Design a ** class named Person and its two subclasses named Student and Employee. ** Make Faculty and Staff subclasses of Employee. A person has a name, ** address, phone number, and email address. A student has a class status ** (freshman, sophomore, junior, or senior). Define the status as a constant. An ** employee has an office, salary, and date hired. Use the MyDate class defined ** in Programming Exercise 10.14 to create an object for date hired. A faculty ** member has office hours and a rank. A staff member has a title. Override the ** toString method in each class to display the class name and the person’s name. ** Draw the UML diagram for the classes and implement them. Write a test program ** that creates a Person, Student, Employee, Faculty, and Staff, and invokes ** their toString() methods. **********************************************************************************/public class Exercise_11_02 &#123; // Main method public static void main(String[] args) &#123; // Create a Person, Student, Employee, Faculty, and Staff objects Person person = new Person("name", "adress", "123123123", "anymouse@any.com"); Student student = new Student("name2", "adress2", "1112333321", "anyone@qvq.com", Student.FRESHMAN); Employee employee = new Employee("name3", "Rift", "1008611", "nmsl@nm.com", 910, 60000); Faculty faculty = new Faculty("name4", "Loksas", "123123132", "xxxx@xx.com", 101, 50000, "4pm to 6pm", "Professor"); Staff staff = new Staff("Tom", "90 Country road", "2030000000", "tomcat@aol.com", 12, 65000, "Executive Assistant"); // Invoke toString of Person, Student, Employee, Faculty and Staff System.out.println(person.toString()); System.out.println(student.toString()); System.out.println(employee.toString()); System.out.println(faculty.toString()); System.out.println(staff.toString()); &#125;&#125; Employee1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162/******************************************************************** Employee **------------------------------------------------------------------** -office: int ** -salary: double ** -dateHired: MyDate ** +Employee(name: String, address: String, phone: String, ** email: String, office: int, salary: double, dateHired: MyDate); ** +getOffice(): int ** +getSalary(): double ** +getDateHired(): MyDate ** +setOffice(office: int): void ** +setSalary(salary: double): void ** +setDateHired(dateHired: MyDate): void ** +toString():String ********************************************************************/// Implement Employee classpublic class Employee extends Person &#123; private int office; private double salary; private MyDate dateHired; /** Construct Employee object */ public Employee(String name, String address, String phone, String email, int office, double salary) &#123; super(name, address, phone, email); this.office = office; this.salary = salary; this.dateHired = new MyDate(); &#125; /** Return office */ public int getOffice() &#123; return office; &#125; /** Return salaray */ public String getSalary() &#123; return String.format("%.2f", salary); &#125; /** Return date hired */ public String getDateHired() &#123; return dateHired.getMonth() + "/" + dateHired.getDay() + "/" + dateHired.getYear(); &#125; /** Set new office */ public void setOffice(int office) &#123; this.office = office; &#125; /** Set new salary */ public void setSalary(double salary) &#123; this.salary = salary; &#125; /** Set new dateHired */ public void setDateHired() &#123; dateHired = new MyDate(); &#125; /** Return a string discription of the class */ public String toString() &#123; return super.toString() + "\nOffice: " + office + "\nSalary: $" + getSalary() + "\nDate hired: " + getDateHired(); &#125;&#125; Faculty12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758/*********************************************************** Faculty **---------------------------------------------------------** -officeHours: int ** -rank: String ** +Faculty(name: String, address: String, phone: String, ** email: String, office: int, salary: double, ** officeHours: int, rank: String) ** +getOfficeHours(): int ** +setOfficeHours(officeHours: int): void ** +getRank(): String ** +setRank(rank: String): void ** +toString(): String ***********************************************************/// Implement Faculty classpublic class Faculty extends Employee &#123; // Data fields private String officeHours; private String rank; // Constructors /** Construct a Faculty object with specified name, address, phone number, * email address, office, salary, office hours and rank */ public Faculty(String name, String address, String phone, String email, int office, double salary, String officeHours, String rank) &#123; super(name, address, phone, email, office, salary); this.officeHours = officeHours; this.rank = rank; &#125; /** Return officeHours */ public String getOfficeHours() &#123; return officeHours; &#125; /** Set new officeHours */ public void setOfficeHours(String officeHours) &#123; this.officeHours = officeHours; &#125; /** Return rank */ public String getRank() &#123; return rank; &#125; /** Set new rank */ public void setRank(String rank) &#123; this.rank = rank; &#125; /** Return a string discription of the class */ public String toString() &#123; return super.toString() + "\nOffice hours: " + officeHours + "\nRank: " + rank; &#125;&#125; MyDate123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172/******************************************** MyDate **------------------------------------------** -year: int ** -month: int ** -day: int ** +MyDate() ** +MyDate(elapsedTime: long) ** +MyDate(year: int, month: int, day: int) ** +getYear(): int ** +getMonth(): int ** +getDay(): int ** +setDate(elapsedTime: long) ********************************************/import java.util.GregorianCalendar;// Implement MyDate classpublic class MyDate &#123; // Data Fields private int year; private int month; private int day; /** Creates a MyDate object for the current date */ MyDate() &#123; GregorianCalendar calander = new GregorianCalendar(); year = calander.get(GregorianCalendar.YEAR); month = calander.get(GregorianCalendar.MONTH); day = calander.get(GregorianCalendar.DAY_OF_MONTH); &#125; /** Creates a MyDate object with a specified elapsed time * since midnight, January 1, 1970, in milliseconds */ MyDate(long elapsedTime) &#123; setDate(elapsedTime); &#125; /** Creates a MyDate object with the * specified year, month, and day */ MyDate(int year, int month, int day) &#123; this.year = year; this.month = month; this.day = day; &#125; /** Return year */ public int getYear() &#123; return year; &#125; /** Return month */ public String getMonth() &#123; String m = String.valueOf(month + 1); return (month &lt; 10 ? "0" + m : m); &#125; /** Return day */ public String getDay() &#123; String d = String.valueOf(day); return (day &lt; 10 ? "0" + d : d); &#125; /** Sets a new date for the object using the elapsed time */ public void setDate(long elapsedTime) &#123; GregorianCalendar calander = new GregorianCalendar(); calander.setTimeInMillis(elapsedTime); year = calander.get(GregorianCalendar.YEAR); month = calander.get(GregorianCalendar.MONTH); day = calander.get(GregorianCalendar.DAY_OF_MONTH); &#125; &#125; Person1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586/****************************************** Person **----------------------------------------** -name: String ** -address: String ** -phone: String ** -email: String ** +Person() ** +Person(name: String, address: String, ** phone: String, email: String) ** +getName(): String ** +getAddress(): String ** +getPhone(): String ** +getEmail(): String ** +setName(name: String): void ** +setAddress(address: String): void ** +setPhone(phone: String): void ** +setEmail(email: String): void ** +toString(): String ******************************************/// Implement Person classpublic class Person &#123; private String name; private String address; private String phone; private String email; /** Construct default Person object */ public Person() &#123; this("Unknown","Unknown","Unknown","Unknown"); &#125; /** Construct Person object with specified name, address, phone and email */ public Person(String name, String address, String phone, String email) &#123; this.name = name; this.address = address; this.phone = phone; this.email = email; &#125; /** Return name */ public String getName() &#123; return name; &#125; /** Return address */ public String getAddress() &#123; return address; &#125; /** Return phone */ public String getPhone() &#123; return phone; &#125; /** Return email */ public String getEmail() &#123; return email; &#125; /** Set new name */ public void setName(String name) &#123; this.name = name; &#125; /** Set new address */ public void setAddress(String address) &#123; this.address = address; &#125; /** Set new phone number */ public void setPhone(String phone) &#123; this.phone = phone; &#125; /** Set new email */ public void setEmail(String email) &#123; this.email = email; &#125; /** Return a string discription of the class */ public String toString() &#123; return "\nName: " + name + "\nAddress: " + address + "\nPhone number: " + phone + "\nEmail address: " + email; &#125;&#125; Staff123456789101112131415161718192021222324252627282930313233343536373839/*********************************************************************** Staff **---------------------------------------------------------------------** -title: String ** +Staff(name: String, address: String, phone: String, email: String, ** office: int, salary: double, dateHired: MyDate, title: String) ** +getTitle(): String ** +setTitle(title: String): void ** +toString(): String ***********************************************************************/// Implement Staff classpublic class Staff extends Employee &#123; // Data Fields private String title; // Constructors /** Construct a Staff object */ public Staff(String name, String address, String phone, String email, int office, double salary, String title) &#123; super(name, address, phone, email, office, salary); this.title = title; &#125; /** Return title */ public String getTitle() &#123; return title; &#125; /** Set new title */ public void setTitle(String title) &#123; this.title = title; &#125; /** Return a string discription of the class */ public String toString() &#123; return super.toString() + "\nTitle: " + title; &#125;&#125; Student12345678910111213141516171819202122232425262728293031323334353637383940414243444546/************************************************** Student **------------------------------------------------** -status: String ** --------------- ** +Student(name: String, address: String, ** phone: String, email: String, status: String) ** +getStatus(): String ** +setStatus(status: String): void ** +toString(): String **************************************************/// Implement Student classpublic class Student extends Person &#123; private int status; public final static int FRESHMAN = 1; public final static int SOPHOMORE = 3; public final static int JUNIOR = 2; public final static int SENIOR = 4; public Student(String name, String address, String phone, String email, int status) &#123; super(name, address, phone, email); this.status = status; &#125; /** Set new status */ public void setStatus(int status) &#123; this.status = status; &#125; /** Return status */ public String getStatus() &#123; switch (status) &#123; case 1 : return "freshman"; case 2 : return "sophomore"; case 3 : return "junior"; case 4 : return "senior"; default : return "Unknown"; &#125; &#125; /** Return a string discription of the class */ public String toString() &#123; return super.toString() + "\nStatus: " + getStatus(); &#125;&#125; 11.3Test12345678910111213141516171819202122232425262728293031323334353637383940/********************************************************************************** (Subclasses of Account) In Programming Exercise 9.7, the Account class was ** defined to model a bank account. An account has the properties account number, ** balance, annual interest rate, and date created, and methods to deposit and ** withdraw funds. Create two subclasses for checking and saving accounts. A ** checking account has an overdraft limit, but a savings account cannot be ** overdrawn. ** ** Draw the UML diagram for the classes and then implement them. Write ** a test program that creates objects of Account, SavingsAccount, and ** CheckingAccount and invokes their toString() methods. **********************************************************************************/public class Exercise_11_03 &#123; // Main method public static void main(String[] args) &#123; // Create Account, SavingsAccount and Checking Account objects Account account = new Account(1122, 20000); SavingsAccount savings = new SavingsAccount(1001, 20000); CheckingAccount checking = new CheckingAccount(1004, 20000, -20); // Set annual interest rate of 4.5% account.setAnnualInterestRate(4.5); savings.setAnnualInterestRate(4.5); checking.setAnnualInterestRate(4.5); // Withdraw $2,500 account.withdraw(2500); savings.withdraw(2500); checking.withdraw(2500); // Deposit $3,000 account.deposit(3000); savings.deposit(3000); checking.deposit(3000); // Invoke toString methods System.out.println(account.toString()); System.out.println(savings.toString()); System.out.println(checking.toString()); &#125;&#125; Account123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112/********************************************************* Account **-------------------------------------------------------** -id: int ** -balance: double ** -annualInterestRate: double ** --------------------------- ** -dateCreated: String ** +Account() ** +Account(newid: int, newBalance: double) ** +setId(newId: int) ** +setBalance(newBalance: double) ** +setAnnualInterestRate(newAnnualInterestRate: double) ** +getId(): int ** +getBalance(): double ** +getAnnualInterestRate(): double ** +getDateCreated(): String ** +getMonthlyInterestRate(): double ** +getMonthlyInterest(): double ** +withdraw(amount: double) ** +deposit(amount: double) *********************************************************/// Implement the Account classimport java.util.Date;public class Account &#123; // Data fields private int id; private double balance; private static double annualInterestRate; private Date dateCreated; // Constructors /** Creates a default account */ Account() &#123; this(0, 0); &#125; /** Creates an account with the specified id and initial balance */ Account(int id, double balance) &#123; this.id = id; this.balance = balance; annualInterestRate = 0; dateCreated = new Date(); &#125; // Mutator methods /** Set id */ public void setId(int id) &#123; this.id = id; &#125; /** Set balance */ public void setBalance(double balance) &#123; this.balance = balance; &#125; /** Set annualInterestRate */ public void setAnnualInterestRate(double annualInterestRate) &#123; this.annualInterestRate = annualInterestRate; &#125; // Accessor methods /** Return id */ public int getId() &#123; return id; &#125; /** Return balance */ public double getBalance() &#123; return balance; &#125; /** Return annualInterestRate */ public double getAnnualInterestRate() &#123; return annualInterestRate; &#125; /** Return dateCreated */ public String getDateCreated() &#123; return dateCreated.toString(); &#125; /** Return monthly interest rate */ public double getMonthlyInterestRate() &#123; return annualInterestRate / 12; &#125; // Methods /** Return monthly interest */ public double getMonthlyInterest() &#123; return balance * (getMonthlyInterestRate() / 100); &#125; /** Decrease balance by amount */ public void withdraw(double amount) &#123; balance -= amount; &#125; /** Increase balance by amount */ public void deposit(double amount) &#123; balance += amount; &#125; /** Return a String decription of Account class */ public String toString() &#123; return "\nAccount ID: " + id + "\nDate created: " + getDateCreated() + "\nBalance: $" + String.format("%.2f", balance) + "\nMonthly interest: $" + String.format("%.2f", getMonthlyInterest()); &#125;&#125; CheckingAccount123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354/**************************************************************************** CheckingAccount **--------------------------------------------------------------------------** -overdraftLimit: double ** +CheckingAccount() ** +CheckingAccount(newId: int, newBalance: double, overdraftLimit: double) ** +setOverdraftLimit(overdraftLimit: double): void ** +getOverdraftLimit(): double ** +withdraw(amount: double): boolean ** +toString(): String *****************************************************************************/// Implement Checking classpublic class CheckingAccount extends Account &#123; // Data fields private double overdraftLimit; /** Construct a default CheckingAccount object */ public CheckingAccount() &#123; super(); overdraftLimit = -20; &#125; /** Construct a CheckingAccout with specified id, balance and overdraftLimit */ public CheckingAccount(int id, double balance, double overdraftLimit) &#123; super(id, balance); this.overdraftLimit = overdraftLimit; &#125; /** Set a new overdraft limit */ public void setOverdraftLimit(double overdraftLimit) &#123; this.overdraftLimit = overdraftLimit; &#125; /** Return overdraft limit */ public double getOverdraftLimit() &#123; return overdraftLimit; &#125; /** Decrease balance by amount */ public void withdraw(double amount) &#123; if (getBalance() - amount &gt; overdraftLimit) &#123; setBalance(getBalance() - amount); &#125; else System.out.println("Error! Amount exceeds overdraft limit."); &#125; /** Return a String decription of CheckingAccount class */ public String toString() &#123; return super.toString() + "\nOverdraft limit: $" + String.format("%.2f", overdraftLimit); &#125;&#125; SavingsAccount1234567891011121314151617181920212223242526272829/************************************** SavingsAccount **------------------------------------** +SavingsAccount() ** +withdraw(amount: double): boolean ***************************************/// Implement SavingsAccount classpublic class SavingsAccount extends Account &#123; /** Construct a default CheckingAccount object */ public SavingsAccount() &#123; super(); &#125; /** Construct a SavingsAccount with specified id, balance */ public SavingsAccount(int id, double balance) &#123; super(id, balance); &#125; /** Decrease balance by amount */ public void withdraw(double amount) &#123; if (amount &lt; getBalance()) &#123; setBalance(getBalance() - amount); &#125; else System.out.println( "Error! Savings account overdrawn transtaction rejected"); &#125;&#125; 11.13123456789101112131415161718192021222324252627282930313233343536373839404142434445464748/********************************************************************************** (Remove duplicates) Write a method that removes the duplicate elements from ** an array list of integers using the following header: ** ** public static void removeDuplicate(ArrayList&lt;Integer&gt; list) ** ** Write a test program that prompts the user to enter 10 integers to a list and ** displays the distinct integers separated by exactly one space. **********************************************************************************/import java.util.Scanner;import java.util.ArrayList;public class Exercise_11_13 &#123; /** Main method */ public static void main(String[] args) &#123; // Create a scanner Scanner input = new Scanner(System.in); // Create an ArrayList ArrayList&lt;Integer&gt; list = new ArrayList&lt;Integer&gt;(); // Prompt ther user to enter 10 integers System.out.print("Enter 10 integers: "); for (int i = 0; i &lt; 10; i++) &#123; list.add(input.nextInt()); &#125; // Invoke removeDuplicate method removeDuplicate(list); // Display the distinct integers System.out.print("The distinct integers are "); for (int i = 0; i &lt; list.size(); i++) &#123; System.out.print(list.get(i) + " "); &#125; System.out.println(); &#125; /** Removes the duplicate elements from an array list of integers */ public static void removeDuplicate(ArrayList&lt;Integer&gt; list) &#123; for (int i = 0; i &lt; list.size() - 1; i++) &#123; for (int j = i + 1; j &lt; list.size(); j++) &#123; if (list.get(i) == list.get(j)) list.remove(j); &#125; &#125; &#125;&#125; Exercise 613.1Test12345678910111213141516171819202122232425262728293031323334353637/********************************************************************************** (Triangle class) Design a new Triangle class that extends the abstract ** GeometricObject class. Draw the UML diagram for the classes Triangle and ** GeometricObject and then implement the Triangle class. Write a test program ** that prompts the user to enter three sides of the triangle, a color, and a ** Boolean value to indicate whether the triangle is filled. The program should ** create a Triangle object with these sides and set the color and filled ** properties using the input. The program should display the area, perimeter, ** color, and true or false to indicate whether it is filled or not. **********************************************************************************/import java.util.Scanner;public class Exercise_13_01 &#123; /** Main method */ public static void main(String[] args) &#123; // Create a Scanner Scanner input = new Scanner(System.in); // Prompt the user to enter three sides of a triangle a color // and a Boolean value to indicate whether the triangle is filled System.out.print("Enter three sides of the triangle: "); double side1 = input.nextDouble(); double side2 = input.nextDouble(); double side3 = input.nextDouble(); System.out.print("Enter a color: "); String color = input.next(); System.out.print("Is the triangle filled (true / false)? "); boolean filled = input.nextBoolean(); // Create a Triangle Triangle triangle = new Triangle(side1, side2, side3, color, filled); System.out.println(triangle); &#125;&#125; GeometricObject12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455public abstract class GeometricObject &#123; private String color = "white"; private boolean filled; private java.util.Date dateCreated; /** Construct a default geometric object */ protected GeometricObject() &#123; dateCreated = new java.util.Date(); &#125; /** Construct a geometric object with color and filled value */ protected GeometricObject(String color, boolean filled) &#123; dateCreated = new java.util.Date(); this.color = color; this.filled = filled; &#125; /** Return color */ public String getColor() &#123; return color; &#125; /** Set a new color */ public void setColor(String color) &#123; this.color = color; &#125; /** Return filled. Since filled is boolean, * the get method is named isFilled */ public boolean isFilled() &#123; return filled; &#125; /** Set a new filled */ public void setFilled(boolean filled) &#123; this.filled = filled; &#125; /** Get dateCreated */ public java.util.Date getDateCreated() &#123; return dateCreated; &#125; @Override public String toString() &#123; return "created on " + dateCreated + "\ncolor: " + color + " and filled: " + filled; &#125; /** Abstract method getArea */ public abstract double getArea(); /** Abstract method getPerimeter */ public abstract double getPerimeter();&#125; Triangle1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586/********************************************************** Triangle **--------------------------------------------------------** -side1: double ** -side2: double ** -side3: double **--------------------------------------------------------** +Triangle() ** +Triangle(side1: double, side2: double, side3: double) ** +Triangle(side1: double, side2: double, side3: double, ** color: string, filled: boolean) ** +getSide1(): double ** +getSide2(): double ** +getSide3(): double ** +setSide1(side1: double): void ** +setSide2(side2: double): void ** +setSide3(side3: double): void **********************************************************/public class Triangle extends GeometricObject &#123; private double side1; private double side2; private double side3; public Triangle()&#123; &#125; public Triangle(double side1, double side2, double side3) &#123; this.side1 = side1; this.side2 = side2; this.side3 = side3; &#125; public Triangle(double side1, double side2, double side3, String color, boolean filled) &#123; this(side1, side2, side3); setColor(color); setFilled(filled); &#125; /** Return side1 */ public double getSide1() &#123; return side1; &#125; /** Set side1 to a new lentgh */ public void setSide1(double side1) &#123; this.side1 = side1; &#125; /** Return side2 */ public double getSide2() &#123; return side2; &#125; /** Set side2 to a new lentgh */ public void setSide2(double side2) &#123; this.side2 = side2; &#125; /** Return side3 */ public double getSide3() &#123; return side3; &#125; /** Set side3 to a new lentgh */ public void setSide3(double side3) &#123; this.side3 = side3; &#125; @Override /** Return area of this Triangle */ public double getArea() &#123; double s = (side1 + side2 + side3) / 2; return Math.sqrt(s * (s - side1) * (s - side2) * (s - side3)); &#125; @Override /** Return perimeter of this triangle */ public double getPerimeter() &#123; return side1 + side2 + side3; &#125; @Override /** Return a string discription of the object */ public String toString() &#123; return super.toString() + "\nArea: " + getArea() + "\nPerimeter: " + getPerimeter(); &#125;&#125; 13.5Test123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354/********************************************************************************** (Enable GeometricObject comparable) Modify the GeometricObject class to ** implement the Comparable interface, and define a static max method in the ** GeometricObject class for finding the larger of two GeometricObject objects. ** Draw the UML diagram and implement the new GeometricObject class. Write a test ** program that uses the max method to find the larger of two circles and the ** larger of two rectangles. **********************************************************************************/public class Exercise_13_05 &#123; /** Main method */ public static void main(String[] args) &#123; // Create two Circle objects Circle circle1 = new Circle(15, "red", true); Circle circle2 = new Circle(10, "blue", false); // Display circle1 System.out.println("\nCircle 1: "); print(circle1); // Display circle2 System.out.println("\nCircle 2: "); print(circle2); // Display larger circle print("\nThe larger of the two circles was "); print(Circle.max(circle1, circle2)); // Create two Rectangle objects Rectangle rectangle1 = new Rectangle(4, 5, "green", true); Rectangle rectangle2 = new Rectangle(4.2, 5, "orange", true); // Display circle1 System.out.println("\nRectangle 1: "); print(circle1); // Display circle2 System.out.println("\nRectangle 2: "); print(circle2); // Display larger circle print("\nThe larger of the two rectangles was "); print(Rectangle.max(rectangle1, rectangle2)); &#125; // Displays a string public static void print(String s) &#123; System.out.println(s); &#125; // Displays a GeometricObject public static void print(GeometricObject o) &#123; System.out.println(o); &#125;&#125; Circle12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849public class Circle extends GeometricObject &#123; private double radius; public Circle() &#123; &#125; public Circle(double radius) &#123; this.radius = radius; &#125; public Circle(double radius, String color, boolean filled) &#123; this.radius = radius; setColor(color); setFilled(filled); &#125; /** Return radius */ public double getRadius() &#123; return radius; &#125; /** Set a new radius */ public void setRadius(double radius) &#123; this.radius = radius; &#125; @Override /** Return area */ public double getArea() &#123; return radius * radius * Math.PI; &#125; /** Return diameter */ public double getDiameter() &#123; return 2 * radius; &#125; @Override /** Return perimeter */ public double getPerimeter() &#123; return 2 * radius * Math.PI; &#125; @Override /** Return String discription of Circle object */ public String toString() &#123; return super.toString() + "\nRadius: " + radius + "\nArea: " + getArea() + "\nDiameter: " + getDiameter() + "\nPerimeter: " + getPerimeter(); &#125;&#125; GeometricObject1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192/*************************************************** GeometricObject **-------------------------------------------------** -color: String ** -filled: boolean ** -dateCreated: java.util.Date **-------------------------------------------------** GeometricObject() ** GeometricObject(color: String, filled: boolean) ** +getColor(): String ** +setColor(color: String): void ** +isFilled(): boolean ** +setFilled(filled: boolean): void * * +getDateCreated(): java.util.Date ** +getMax(GeometricObject: o1, ** --------------------------- ** GeometricObject: o2): GeometricObject ** -------------------- ** +getArea(): double ** +getPerimeter(): double ***************************************************/public abstract class GeometricObject implements Comparable&lt;GeometricObject&gt; &#123; private String color = "while"; private boolean filled; private java.util.Date dateCreated; /** Construct a default geometric object */ protected GeometricObject() &#123; dateCreated = new java.util.Date(); &#125; /** Construct a geometric object with color and filled value */ protected GeometricObject(String color, boolean filled) &#123; dateCreated = new java.util.Date(); this.color = color; this.filled = filled; &#125; /** Return color */ public String getColor() &#123; return color; &#125; /** Set a new color */ public void setColor(String color) &#123; this.color = color; &#125; /** Return filled. Since filled is boolean, * the get method is named isFilled */ public boolean isFilled() &#123; return filled; &#125; /** Set a new filled */ public void setFilled(boolean filled) &#123; this.filled = filled; &#125; /** Get dateCreated */ public java.util.Date getDateCreated() &#123; return dateCreated; &#125; @Override public String toString() &#123; return "created on " + dateCreated + "\ncolor: " + color + " and filled: " + filled; &#125; @Override // Implement the compareTo method defined in Comparable public int compareTo(GeometricObject o) &#123; if (this.getArea() &gt; o.getArea()) return 1; else if (this.getArea() &lt; o.getArea()) return -1; else return 0; &#125; /** Abstract method getMax */ public static GeometricObject max(GeometricObject o1, GeometricObject o2) &#123; return o1.compareTo(o2) == 1 ? o1 : o2; &#125; /** Abstract method getArea */ public abstract double getArea(); /** Abstract method getPerimeter */ public abstract double getPerimeter();&#125; Rectangle12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758public class Rectangle extends GeometricObject &#123; private double width; private double height; public Rectangle() &#123; &#125; public Rectangle( double width, double height) &#123; this.width = width; this.height = height; &#125; public Rectangle( double width, double height, String color, boolean filled) &#123; this.width = width; this.height = height; setColor(color); setFilled(filled); &#125; /** Return width */ public double getWidth() &#123; return width; &#125; /** Set a new width */ public void setWidth(double width) &#123; this. width = width; &#125; /** Return height */ public double getheight() &#123; return height; &#125; /** Set a new height */ public void setheight(double height) &#123; this.height = height; &#125; @Override /** Return area */ public double getArea() &#123; return width * height; &#125; @Override /** Return perimeter */ public double getPerimeter() &#123; return 2 * (width * height); &#125; @Override /** Return String discription of this rectangle */ public String toString() &#123; return super.toString() + "\nWidth: " + width + "\nHeight: " + height + "\nArea: " + getArea() + "\nPerimeter: " + getPerimeter(); &#125;&#125; 13.10Test1234567891011121314151617181920212223242526/********************************************************************************** (Enable Rectangle comparable) Rewrite the Rectangle class in Listing 13.3 to ** extend GeometricObject and implement the Comparable interface. Override the ** equals method in the Object class. Two Rectangle objects are equal if their ** areas are the same. Draw the UML diagram that involves Rectangle, ** GeometricObject, and Comparable. **********************************************************************************/public class Exercise_13_10 &#123; /** Main method */ public static void main(String[] args) &#123; // Create three Rectangle objects Rectangle r1 = new Rectangle(3, 5, "blue", true); Rectangle r2 = new Rectangle(5, 3, "gray", false); Rectangle r3 = new Rectangle(3.1, 5, "blue", true); System.out.println("Rectangle1 Area :" + r1.getArea()); System.out.println("Rectangle2 Area :" + r2.getArea()); System.out.println("Rectangle3 Area :" + r3.getArea()); System.out.println("Rectangle1 is " + (r1.equals(r2) ? "" : "not ") + "equal to Rectangle2"); System.out.println("Rectangle1 is " + (r1.equals(r3) ? "" : "not ") + "equal to Rectangle3"); &#125;&#125; GeometricObject1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556public abstract class GeometricObject &#123; private String color = "while"; private boolean filled; private java.util.Date dateCreated; /** Construct a default geometric object */ protected GeometricObject() &#123; dateCreated = new java.util.Date(); &#125; /** Construct a geometric object with color and filled value */ protected GeometricObject(String color, boolean filled) &#123; dateCreated = new java.util.Date(); this.color = color; this.filled = filled; &#125; /** Return color */ public String getColor() &#123; return color; &#125; /** Set a new color */ public void setColor(String color) &#123; this.color = color; &#125; /** Return filled. Since filled is boolean, * the get method is named isFilled */ public boolean isFilled() &#123; return filled; &#125; /** Set a new filled */ public void setFilled(boolean filled) &#123; this.filled = filled; &#125; /** Get dateCreated */ public java.util.Date getDateCreated() &#123; return dateCreated; &#125; @Override public String toString() &#123; return "created on " + dateCreated + "\ncolor: " + color + " and filled: " + filled; &#125; /** Abstract method getArea */ public abstract double getArea(); /** Abstract method getPerimeter */ public abstract double getPerimeter();&#125; Rectangle12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273public class Rectangle extends GeometricObject implements Comparable&lt;Rectangle&gt; &#123; private double width; private double height; public Rectangle() &#123; &#125; public Rectangle( double width, double height) &#123; this.width = width; this.height = height; &#125; public Rectangle( double width, double height, String color, boolean filled) &#123; this.width = width; this.height = height; setColor(color); setFilled(filled); &#125; /** Return width */ public double getWidth() &#123; return width; &#125; /** Set a new width */ public void setWidth(double width) &#123; this. width = width; &#125; /** Return height */ public double getheight() &#123; return height; &#125; /** Set a new height */ public void setheight(double height) &#123; this.height = height; &#125; @Override /** Return area */ public double getArea() &#123; return width * height; &#125; @Override /** Return perimeter */ public double getPerimeter() &#123; return 2 * (width * height); &#125; @Override /** Implement compareTo method */ public int compareTo(Rectangle o) &#123; if (getArea() &gt; o.getArea()) return 1; else if (getArea() &lt; o.getArea()) return -1; else return 0; &#125; @Override /** Return true if both objects are equal */ public boolean equals(Object o) &#123; return this.compareTo((Rectangle)o) == 0; &#125; @Override /** Return String discription of this rectangle */ public String toString() &#123; return super.toString() + "\nWidth: " + width + "\nHeight: " + height + "\nArea: " + getArea() + "\nPerimeter: " + getPerimeter(); &#125;&#125; 13.13Test123456789101112131415161718192021222324252627282930313233343536373839/********************************************************************************** (Enable the Course class cloneable) Rewrite the Course class in Listing 10.6 ** to add a clone method to perform a deep copy on the students field. **********************************************************************************/public class Exercise_13_13 &#123; public static void main(String[] args) throws CloneNotSupportedException &#123; // Create a course object Course course1 = new Course("Data Structures"); // Add three students to course1 course1.addStudent("Peter Jones"); course1.addStudent("Kim Smith"); course1.addStudent("Anne kennedy"); // Clone course1 Course course2 = course1.clone(); // Add three students to course2 course2.addStudent("Jamal Jones"); course2.addStudent("Steve Smith"); // Display students in course1 System.out.println("\nNumber of students in course1: " + course1.getNumberOfStudents()); String[] students = course1.getStudents(); for (int i = 0; i &lt; course1.getNumberOfStudents(); i++) System.out.print(students[i] + ", "); System.out.println(); // Display students in course2 System.out.println("\nNumber of students in course2: " + course2.getNumberOfStudents()); String[] students2 = course2.getStudents(); for (int i = 0; i &lt; course2.getNumberOfStudents(); i++) System.out.print(students2[i] + ", "); System.out.println(); &#125;&#125; Course12345678910111213141516171819202122232425262728293031323334353637383940public class Course implements Cloneable &#123; private String courseName; private String[] students = new String[100]; private int numberOfStudents; public Course(String courseName) &#123; this.courseName = courseName; &#125; public void addStudent(String student) &#123; students[numberOfStudents] = student; numberOfStudents++; &#125; public String[] getStudents() &#123; return students; &#125; public int getNumberOfStudents() &#123; return numberOfStudents; &#125; public String getCourseName() &#123; return courseName; &#125; @Override /** Override the proceted clone method defined in the Object class, and strengthen its accessibility */ public Course clone() throws CloneNotSupportedException &#123; // Perform a shallow copy Course courseClone = (Course)super.clone(); // Deep copy on students courseClone.students = students.clone(); return courseClone; &#125; public void dropStudent(String student) &#123; // Left as an exercise in Programming Exercise 10.9 &#125;&#125; 13.17Test123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687/********************************************************************************** (Math: The Complex class) A complex number is a number in the form a + bi, ** where a and b are real numbers and i is 2-1. The numbers a and b are known as ** the real part and imaginary part of the complex number, respectively. You can ** perform addition, subtraction, multiplication, and division for complex ** numbers using the following formulas: ** ** a + bi + c + di = (a + c) + (b + d)i ** a + bi - (c + di) = (a - c) + (b - d)i ** (a + bi)*(c + di) = (ac - bd) + (bc + ad)i ** (a + bi)/(c + di) = (ac + bd)/(c2 + d2) + (bc - ad)i/(c2 + d2) ** ** You can also obtain the absolute value for a complex number using the ** following formula: ** ** |a + bi| = √(a^2 + b^2) ** ** (A complex number can be interpreted as a point on a plane by identifying the ** (a,b) values as the coordinates of the point. The absolute value of the ** complex number corresponds to the distance of the point to the origin, as ** shown in Figure 13.10b.) ** ** Design a class named Complex for representing complex numbers and the methods ** add, subtract, multiply, divide, and abs for performing complexnumber ** operations, and override toString method for returning a string representation ** for a complex number. The toString method returns (a + bi) as a string. If b ** is 0, it simply returns a. Your Complex class should also implement the ** Cloneable interface. ** ** Provide three constructors Complex(a, b), Complex(a), and Complex(). Complex() ** creates a Complex object for number 0 and Complex(a) creates a Complex object ** with 0 for b. Also provide the getRealPart() and getImaginaryPart() methods ** for returning the real and imaginary part of the complex number, respectively. ** ** Write a test program that prompts the user to enter two complex numbers and ** displays the result of their addition, subtraction, multiplication, division, ** and absolute value. **********************************************************************************/import java.util.Scanner;public class Exercise_13_17 &#123; /** Main method */ public static void main(String[] args) throws CloneNotSupportedException &#123; // Prompt the user to enter two complex numbers System.out.print("Enter the first complex number: "); Complex complexNumber1 = getComplex(); System.out.print("Enter the second complex number: "); Complex complexNumber2 = getComplex(); // displays the result of their addition, subtraction, // multiplication, division, and absolute value System.out.print(complexNumber1 + " + " + complexNumber2 + " = "); print(complexNumber1.add(complexNumber2)); System.out.print(complexNumber1 + " - " + complexNumber2 + " = "); print(complexNumber1.subtract(complexNumber2)); System.out.print(complexNumber1 + " * " + complexNumber2 + " = "); print(complexNumber1.multiply(complexNumber2)); System.out.print(complexNumber1 + " / " + complexNumber2 + " = "); print(complexNumber1.divide(complexNumber2)); System.out.println("|" + complexNumber1 + "| = " + complexNumber1.abs()); &#125; /** Display result */ public static void print(Complex n) &#123; if (n.getImaginaryPart() == 0) System.out.println(n.getRealPart()); else System.out.println(n.getRealPart() + " + " + n.getImaginaryPart() + "i"); &#125; /** Return user input as a complex number */ public static Complex getComplex() &#123; // Create a Scanner object Scanner input = new Scanner(System.in); double[] c = new double[2]; for (int i = 0; i &lt; c.length; i++) c[i] = input.nextDouble(); return new Complex(c[0], c[1]); &#125;&#125; Complex123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475public class Complex implements Cloneable &#123; private double a; private double b; // Constructors /** Creates a complex object for number 0 */ public Complex() &#123; this(0, 0); &#125; /** Create a complex object with 0 for b */ public Complex(double a) &#123; this(a, 0); &#125; /** Creates a complex object with specified a and b */ public Complex(double a, double b) &#123; this.a = a; this.b = b; &#125; // Methods /** Return real part of complex number */ public double getRealPart() &#123; return a; &#125; /** Return imaginary part of complex number */ public double getImaginaryPart() &#123; return b; &#125; /** Add a complex number to this complex number */ public Complex add(Complex secondComplex) &#123; return new Complex(a + secondComplex.a, b + secondComplex.b); &#125; /** Subtract a complex number from this complex number */ public Complex subtract(Complex secondComplex) &#123; return new Complex(a - secondComplex.a, b - secondComplex.b); &#125; /** Multiply a complex number by this complex number */ public Complex multiply(Complex secondComplex) &#123; return new Complex(a * secondComplex.a - b * secondComplex.b, b * secondComplex.a + a * secondComplex.b); &#125; /** Divide a complex number by this complex number */ public Complex divide(Complex secondComplex) &#123; return new Complex((a * secondComplex.a + b * secondComplex.b) / (Math.pow(secondComplex.a, 2) + Math.pow(secondComplex.b, 2)), (b * secondComplex.a - a * secondComplex.b) / (Math.pow(secondComplex.a, 2) + Math.pow(secondComplex.b, 2))); &#125; /** Returns the absolute value of this complex number */ public double abs() &#123; return Math.sqrt(Math.pow(a, 2) + Math.pow(b, 2)); &#125; @Override /** Override the protectec clone method defined in the Object class, and strengthen its accexxibility */ public Complex clone() throws CloneNotSupportedException &#123; return (Complex)super.clone(); &#125; @Override /** Retrun a string description of this complex number */ public String toString() &#123; return b == 0 ? a + "" : "(" + a + " + " + b + "i)"; &#125;&#125; Exercise 712.212345678910111213141516171819202122232425262728293031323334/********************************************************************************** (InputMismatchException) Write a program that prompts the user to read two ** integers and displays their sum. Your program should prompt the user to read ** the number again if the input is incorrect. **********************************************************************************/import java.util.*;public class Exercise_12_02 &#123; public static void main(String[] args) &#123; // Create a Scanner Scanner input = new Scanner(System.in); boolean continueInput = true; // Prompt the user to enter two integers System.out.print("Enter two numbers: "); do &#123; try &#123; int number1 = input.nextInt(); int number2 = input.nextInt(); // Display the result System.out.println( "The sum is " + (number1 + number2)); continueInput = false; &#125; catch (InputMismatchException ex) &#123; System.out.println("Try again. (" + "Incorrect input: two integers are required) "); input.nextLine(); // Discard input &#125; &#125; while (continueInput); &#125;&#125; 12.312345678910111213141516171819202122232425262728293031323334353637383940/********************************************************************************** (ArrayIndexOutOfBoundsException) Write a program that meets the following ** requirements: ** ** ■ Creates an array with 100 randomly chosen integers. ** ■ Prompts the user to enter the index of the array, then displays the ** corresponding element value. If the specified index is out of bounds, ** display the message "Out of Bounds". **********************************************************************************/import java.util.*;public class Exercise_12_03 &#123; public static void main(String[] args) &#123; // Create a Scanner Scanner input = new Scanner(System.in); // Invoke getArray method int[] array = getArray(); // Prompt the user to enter the index of the array System.out.print("Enter the index of the array: "); try &#123; // Display the corresponding element value System.out.println("The corresponding element value is " + array[input.nextInt()]); &#125; catch (ArrayIndexOutOfBoundsException ex) &#123; System.out.println("Out of Bounds."); &#125; &#125; /** Returns an array with 100 randomly chosen integers */ public static int[] getArray() &#123; int[] array = new int[100]; for (int i = 0; i &lt; array.length; i++) &#123; array[i] = (int)(Math.random() * 100) + 1; &#125; return array; &#125;&#125; 12.1112345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364/********************************************************************************** (Remove text) Write a program that removes all the occurrences of a specified ** string from a text file. For example, invoking ** ** java Exercise12_11 John filename ** ** removes the string John from the specified file. Your program should get the ** arguments from the command line. **********************************************************************************/import java.io.*;import java.util.*;public class Exercise_12_11 &#123; /** Main method */ public static void main(String[] args) throws Exception &#123; // Check command line parameter usage if (args.length != 2) &#123; System.out.println("Usage: java RemoveText filename"); System.exit(1); &#125; // Check if file exists File file = new File(args[1]); if (!file.exists()) &#123; System.out.println("File " + args[1] + " does not exist"); System.exit(2); &#125; // Create an ArrayList ArrayList&lt;String&gt; s2 = new ArrayList&lt;&gt;(); try ( // Create input file Scanner input = new Scanner(file); ) &#123; while (input.hasNext()) &#123; String s1 = input.nextLine(); s2.add(removeString(args[0], s1)); &#125; &#125; try ( // Create output file PrintWriter output = new PrintWriter(file); ) &#123; for (int i = 0; i &lt; s2.size(); i++) &#123; output.println(s2.get(i)); &#125; &#125; &#125; public static String removeString(String string, String line) &#123; StringBuilder stringBuilder = new StringBuilder(line); int start = stringBuilder.indexOf(string); // Start index int end = string.length(); // End index while (start &gt;= 0) &#123; end = start + end; stringBuilder = stringBuilder.delete(start, end); start = stringBuilder.indexOf(string, start); &#125; return stringBuilder.toString(); &#125;&#125; 12.1512345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152/********************************************************************************** (Write/read data) Write a program to create a file named Exercise12_15.txt if ** it does not exist. Write 100 integers created randomly into the file using ** text I/O. Integers are separated by spaces in the file. Read the data back ** from the file and display the data in increasing order. **********************************************************************************/import java.util.*;import java.io.*;public class Exercise_12_15 &#123; /** Main method */ public static void main(String[] args) throws Exception &#123; // Check if file exists File file = new File("Exercise12_15.txt"); if (file.exists()) &#123; System.out.println("File already exists"); System.exit(0); &#125; try ( // Create output file PrintWriter output = new PrintWriter(file); ) &#123; // Write 100 integers created radomly to file for (int i = 0; i &lt; 100; i++) &#123; output.print(((int)(Math.random() * 500) + 1)); output.print(" "); &#125; &#125; // Crate and ArrayList ArrayList&lt;Integer&gt; list = new ArrayList&lt;&gt;(); try( // Create input file Scanner input = new Scanner(file); ) &#123; // Read the data back from the file while (input.hasNext()) &#123; list.add(input.nextInt()); &#125; &#125; // Sort array list Collections.sort(list); // Display data in increasing order System.out.print(list.toString()); System.out.println(); &#125;&#125; 12.301234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556/********************************************************************************** (Occurrences of each letter) Write a program that prompts the user to enter a ** file name and displays the occurrences of each letter in the file. Letters are ** case-insensitive. **********************************************************************************/import java.util.*;import java.io.*;public class Exercise_12_30 &#123; /** Main method */ public static void main(String[] args) throws FileNotFoundException &#123; // Create a File object from user input File file = new File(getFileName()); // Check if file exists if (!file.exists()) &#123; System.out.println("File " + file.getName() + " does not exist"); System.exit(0); &#125; int[] count = new int[26]; // Counts each letter try ( // Create input file Scanner input = new Scanner(file); ) &#123; // Read file while (input.hasNext()) &#123; String line = (input.nextLine()).toUpperCase(); countLetters(count, line); &#125; &#125; // Display results for (int i = 0; i &lt; count.length; i++) &#123; System.out.println("Number of " + (char)('A' + i) + "\'s: " + count[i]); &#125; &#125; /** Counts the occurrences of each letter in a string */ public static void countLetters(int[] count, String str) &#123; for (int i = 0; i &lt; str.length(); i++) &#123; if (Character.isLetter(str.charAt(i))) count[(int)(str.charAt(i) - 'A')]++; &#125; &#125; /** Prompts the user to enter a filename * and returns it as a string */ public static String getFileName() &#123; Scanner input = new Scanner(System.in); System.out.print("Enter a filename: "); return input.next(); &#125;&#125; Exercise 817.2123456789101112131415161718192021/********************************************************************************** (Create a binary data file) Write a program to create a file named ** Exercise17_02.dat if it does not exist. Append new data to it if it already ** exists. Write 100 integers created randomly into the file using binary I/O. **********************************************************************************/import java.io.*;public class Exercise_17_02 &#123; public static void main(String[] args) throws IOException &#123; try ( // Create an output stream to the file // Append new data if file already exists FileOutputStream output = new FileOutputStream("Exercise17_02.dat", true); ) &#123; // Output 100 integers created randomly into the file for (int i = 0; i &lt; 100; i++) output.write((int)(1 + Math.random() * 100)); &#125; &#125;&#125; 17.312345678910111213141516171819202122232425/********************************************************************************** (Sum all the integers in a binary data file) Suppose a binary data file named ** Exercise17_03.dat has been created and its data are created using ** writeInt(int) in DataOutputStream. The file contains an unspecified number of ** integers. Write a program to find the sum of the integers. **********************************************************************************/import java.io.*;public class Exercise_17_03 &#123; public static void main(String[] args) throws IOException &#123; int sum = 0; // Sum of the integers try ( // Create an data input stream for file Exercise17_03.dat DataInputStream input = new DataInputStream(new FileInputStream("Exercise17_03.dat")); ) &#123; // Read and sum the integers from the file while (true) sum += input.readInt(); &#125; catch (EOFException ex) &#123; // Detect end of file System.out.println("Sum of the integers is: " + sum); &#125; &#125;&#125; 17.41234567891011121314151617181920212223242526272829303132333435363738/********************************************************************************** (Convert a text file into UTF) Write a program that reads lines of characters ** from a text file and writes each line as a UTF-8 string into a binary file. ** Display the sizes of the text file and the binary file. Use the following ** command to run the program: ** ** java Exercise17_04 Welcome.java Welcome.utf **********************************************************************************/import java.io.*;import java.util.Scanner;public class Exercise_17_04 &#123; public static void main(String[] args) throws IOException &#123; // Check java usage if (args.length != 2) &#123; System.out.println("Usage: java Exercise_17_04 SourceFile TargetFile"); System.exit(1); &#125; // Create a file and check if it exists File file = new File(args[0]); if (!file.exists()) &#123; System.out.println("The File " + args[0] + " does not exist."); System.exit(2); &#125; try ( // Read lines of characters from text file and // write each line as UTF-8 string to binary file Scanner input = new Scanner(file); DataOutputStream output = new DataOutputStream(new FileOutputStream(args[1])); ) &#123; while (input.hasNext()) output.writeUTF(input.nextLine()); &#125; &#125;&#125; 17.1412345678910111213141516171819202122232425262728293031323334/********************************************************************************** (Encrypt files) Encode the file by adding 5 to every byte in the file. Write a ** program that prompts the user to enter an input file name and an output file ** name and saves the encrypted version of the input file to the output file. **********************************************************************************/import java.util.Scanner;import java.io.*;public class Exercise_17_14 &#123; public static void main(String[] args) throws IOException &#123; // Create a scanner Scanner input = new Scanner(System.in); // Prompt the user to enter an input file name and an output flie name System.out.print("Enter input flie name: "); String inFile = input.next(); System.out.print("Enter output flie name: "); String outFile = input.next(); try ( // Create two random access files RandomAccessFile source = new RandomAccessFile(inFile, "r"); RandomAccessFile target = new RandomAccessFile(outFile, "rw"); ) &#123; // Add 5 to every byte read from source file // then write it to the target file int r = 0; source.seek(0); // Move the file pointer to the beginning while ((r = source.read()) != -1) &#123; target.write(((byte)r) + 5); &#125; &#125; &#125;&#125; 17.151234567891011121314151617181920212223242526272829303132333435/********************************************************************************** (Decrypt files) Suppose a file is encrypted using the scheme in Programming ** Exercise 17.14. Write a program to decode an encrypted file. Your program ** should prompt the user to enter an input file name for the encrypted file and ** an output file name for the unencrypted version of the input file. **********************************************************************************/import java.io.*;import java.util.Scanner;public class Exercise_17_15 &#123; public static void main(String[] args) throws IOException &#123; // Create a scanner Scanner input = new Scanner(System.in); // Prompt the user to enter the input file for the encrypted file // and the output file name for the unencrypted version of the input file System.out.print("Enter the encrypted file name: "); String inFile = input.next(); System.out.print("Enter the file name for the decrypted file: "); String outFile = input.next(); try ( // Create two random access files RandomAccessFile encrypted = new RandomAccessFile(inFile, "r"); RandomAccessFile decrypted = new RandomAccessFile(outFile, "rw"); ) &#123; // Subtract 5 from every byte in the encrypted file // the write to decrypted file int r; encrypted.seek(0); // Move the file pointer to beginning while ((r = encrypted.read()) != -1) &#123; decrypted.write(((byte)r) - 5); &#125; &#125; &#125;&#125; 17.1612345678910111213141516171819202122232425262728293031323334353637383940/********************************************************************************* (Frequency of characters)** Write a program that prompts the user to enter the name** of an ASCII text file and displays the frequency of the** characters in the file.**********************************************************************************/import java.io.BufferedInputStream;import java.io.File;import java.io.FileInputStream;import java.util.Scanner;public class Exercise_16 &#123; public static void main(String[] args) throws Exception &#123; System.out.print("ASCII UTF-8 counter"); System.out.print("Enter filename: "); File file = new File(new Scanner(System.in).nextLine()); int[] ascii = new int[128]; try (BufferedInputStream in = new BufferedInputStream(new FileInputStream(file))) &#123; int buffer; while ((buffer = in.read()) != -1) ascii[buffer]++; &#125; // Display occurrences System.out.printf("%10s %10s %10s\n", "Character", "ASCII code", "Count"); for (int i = 0; i &lt; ascii.length; i++) &#123; if (ascii[i] != 0) System.out.printf("%10c %10d %10d\n", i, ascii[i], i); &#125; &#125;&#125; Exercise 914.112345678910111213141516171819202122232425262728293031/********************************************************************************** (Display images) Write a program that displays four images in a grid pane, as ** shown in Figure 14.43a. **********************************************************************************/import javafx.application.Application;import javafx.scene.Scene;import javafx.scene.control.Label;import javafx.scene.layout.GridPane;import javafx.scene.image.Image;import javafx.scene.image.ImageView;import javafx.stage.Stage;public class Exercise_14_01 extends Application &#123; @Override // Override the start method in the Application class public void start(Stage primaryStage) &#123; // Create a pane to hold the images views GridPane pane = new GridPane(); // Place nodes in the pane pane.add(new ImageView(new Image("image/uk.gif")), 0, 0); pane.add(new ImageView(new Image("image/ca.gif")), 1, 0); pane.add(new ImageView(new Image("image/china.gif")), 0, 1); pane.add(new ImageView(new Image("image/us.gif")), 1, 1); // Create a scene and place it in the stage Scene scene = new Scene(pane); primaryStage.setTitle("Exercise_14_01"); // Set the stage title primaryStage.setScene(scene); // Place the scene in the stage primaryStage.show(); // Display the stage. &#125;&#125; 14.11123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114/********************************************************************************** (Paint a smiley face) Write a program that paints a smiley face, as shown in ** Figure 14.46a. **********************************************************************************/import javafx.application.Application;import javafx.scene.Scene;import javafx.stage.Stage;import javafx.scene.shape.Circle;import javafx.scene.shape.Polygon;import javafx.scene.shape.Arc;import javafx.scene.shape.ArcType;import javafx.scene.shape.Ellipse;import javafx.scene.layout.StackPane;import javafx.scene.layout.StackPane;import javafx.scene.layout.Pane;import javafx.scene.paint.Color;import javafx.collections.ObservableList;import javafx.geometry.Insets;public class Exercise_14_11 extends Application &#123; @Override // Override the start method in the Application class public void start(Stage primaryStage) &#123; // Create a stack pane StackPane stackPane = new StackPane(); StackPane stackPane2 = new StackPane(); // Crate a pane Pane pane = new Pane(); stackPane2.setPadding(new Insets(40, 40, 40, 40)); // Create a circle and place it in a stack pane Circle circle = getCircle(); stackPane.getChildren().add(circle); // Create a Polygon and place it in a stack pane Polygon polygon = getPolygon(circle); stackPane.getChildren().add(polygon); // Create two ellipse Ellipse ellipse1 = getEllipse(circle); ellipse1.setCenterX(circle.getRadius() - circle.getRadius() / 2.5); Ellipse ellipse2 = getEllipse(circle); ellipse2.setCenterX(circle.getRadius() + circle.getRadius() / 2.5); // Create two circles Circle circle2 = getCircle(ellipse1); Circle circle3 = getCircle(ellipse2); // Create an Arc Arc arc = getArc(circle); // Place nodes in a pane pane.getChildren().addAll(stackPane, ellipse1, ellipse2, circle2, circle3, arc); // Place pane in a stack pane stackPane2.getChildren().add(pane); // Create a scene and place it in the stage Scene scene = new Scene(stackPane2); primaryStage.setTitle("Exercise_14_11"); // Set the stage title primaryStage.setScene(scene); // Place the scene in the stage primaryStage.show(); // Display the stage &#125; /** Return a Arc of specified properties */ private Arc getArc(Circle c) &#123; Arc a = new Arc(c.getRadius(), c.getRadius() * 1.30, c.getRadius() / 2, c.getRadius() / 4, 0, -180); a.setType(ArcType.OPEN); a.setFill(Color.WHITE); a.setStroke(Color.BLACK); return a; &#125; /** Return a circle of specified properties */ private Circle getCircle(Ellipse e) &#123; Circle c = new Circle(e.getCenterX(), e.getCenterY(), e.getRadiusY() - (e.getRadiusX() - e.getRadiusY())); return c; &#125; /** Return an Ellipse of specified properties */ private Ellipse getEllipse(Circle c) &#123; Ellipse e = new Ellipse(); e.setCenterY(c.getRadius() - c.getRadius() / 3); e.setRadiusX(c.getRadius() / 4); e.setRadiusY(c.getRadius() / 3 - 20); e.setStroke(Color.BLACK); e.setFill(Color.WHITE); return e; &#125; /** Return a Polygon of specified properties */ private Polygon getPolygon(Circle c) &#123; double length = c.getRadius() / 4; Polygon p = new Polygon(c.getCenterX(), c.getCenterY() - length, c.getCenterX() - length, c.getCenterY() + length, c.getCenterX() + length, c.getCenterY() + length); p.setFill(Color.WHITE); p.setStroke(Color.BLACK); return p; &#125; /** Returns a circle of specified properties */ private Circle getCircle() &#123; Circle c = new Circle(); c.setRadius(150); c.setStroke(Color.BLACK); c.setFill(Color.WHITE); return c; &#125;&#125; 14.181234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677/************************************************************************************ (Plot the square function) Write a program that draws a diagram for the function ** f(x) = x2 (see Figure 14.48b). ** ** Hint: Add points to a polyline using the following code: ** ** Polyline polyline = new Polyline(); ** ObservableList&lt;Double&gt; list = polyline.getPoints(); ** double scaleFactor = 0.0125; ** for (int x = -100; x &lt;= 100; x++) &#123; ** list.add(x + 200.0); ** list.add(scaleFactor * x * x); ** &#125; ************************************************************************************/import javafx.application.Application;import javafx.collections.ObservableList;import javafx.scene.Scene;import javafx.stage.Stage;import javafx.scene.shape.Polyline;import javafx.scene.shape.Line;import javafx.scene.layout.Pane;import javafx.geometry.Insets;import javafx.scene.text.Text;public class Exercise_14_18 extends Application &#123; @Override // Override the start method in the Application class public void start(Stage primaryStage) &#123; // Create two panes Pane pane1 = new Pane(); pane1.setRotate(180); pane1.setPadding(new Insets(72, 0, 0, 75)); Pane pane2 = new Pane(); // Create a polyline Polyline polyline1 = new Polyline(); pane1.getChildren().add(polyline1); ObservableList&lt;Double&gt; list = polyline1.getPoints(); double scaleFactor = 0.0125; for (int x = -100; x &lt;= 100; x++) &#123; list.add(x + 200.0); list.add(scaleFactor * x * x); &#125; // Create two lines Line lineX = new Line(10, 200, 350, 200); //pane.getChildren().addAll(stackPane, lineX); Line lineY = new Line(lineX.getEndX() / 2, 250, lineX.getEndX() / 2, 30); pane2.getChildren().addAll(pane1, lineX, lineY); // Create two polylines Polyline polyline2 = new Polyline(); pane2.getChildren().add(polyline2); ObservableList&lt;Double&gt; list2 = polyline2.getPoints(); list2.addAll(lineY.getEndX() - 10, lineY.getEndY() + 20, lineY.getEndX(), lineY.getEndY(), lineY.getEndX() + 10, lineY. getEndY() + 20); Polyline polyline3 = new Polyline(); pane2.getChildren().add(polyline3); ObservableList&lt;Double&gt; list3 = polyline3.getPoints(); list3.addAll(lineX.getEndX() - 20, lineX.getEndY() - 10, lineX.getEndX(), lineX.getEndY(), lineX.getEndX() - 20, lineX. getEndY() + 10); // Create two text objects Text textX = new Text(lineX.getEndX() - 10, lineX.getEndY() - 20, "X"); Text textY = new Text(lineY.getEndX() + 20, lineY.getEndY() + 10, "Y"); pane2.getChildren().addAll(textX, textY); // Create a scene and place it in the stage Scene scene = new Scene(pane2); primaryStage.setTitle("Exercise_14_18"); // Set the stage title primaryStage.setScene(scene); // Place the scene in the stage primaryStage.show(); // Display the stage &#125;&#125; 14.27Test123456789101112131415161718192021222324252627282930313233343536373839404142/***************************************************************** * Chapter 14 Exercise 27: * * * * (Draw a detailed clock) * * Modify the ClockPane class in Section 14.12 to draw the * * clock with more details on the hours and minutes, * * as shown in Figure 14.52a. * * * * Created by Luiz Arantes Sa on 9/14/14. * ***************************************************************** */import javafx.application.Application;import javafx.scene.Scene;import javafx.scene.layout.HBox;import javafx.stage.Stage;public class Exercise_27 extends Application &#123; @Override public void start(Stage primaryStage) &#123; double height = 400; double width = 400; ClockPane clock1 = new ClockPane(4, 20, 45, width, height); HBox hBox = new HBox(clock1); Scene scene = new Scene(hBox, width, height); primaryStage.setScene(scene); primaryStage.setTitle("Draw a detailed clock"); primaryStage.show(); &#125; public static void main(String[] args) &#123; Application.launch(args); &#125;&#125; ClockPane123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251/** * Taken from the book example. */import javafx.animation.KeyFrame;import javafx.animation.Timeline;import javafx.collections.ObservableList;import javafx.geometry.Point2D;import javafx.scene.Node;import javafx.scene.layout.Pane;import javafx.scene.paint.Color;import javafx.scene.shape.Circle;import javafx.scene.shape.Line;import javafx.scene.text.Text;import javafx.util.Duration;import java.util.Calendar;import java.util.Collections;import java.util.GregorianCalendar;public class ClockPane extends Pane &#123; private int hour; private int minute; private int second; private boolean hourHandVisible = true; private boolean minuteHandVisible = true; private boolean secondHandVisible = true; private Timeline timeline; // Clock pane's width and height private double w = 250, h = 250; /** Construct a default clock with the current time*/ public ClockPane() &#123; setPrefHeight(h); setPrefWidth(w); timeline = new Timeline(new KeyFrame(Duration.seconds(1), e -&gt; update())); timeline.setCycleCount(Timeline.INDEFINITE); setCurrentTime(); &#125; /** Construct a clock with specified hour, minute, and second */ public ClockPane(int hour, int minute, int second) &#123; this(); this.hour = hour; this.minute = minute; this.second = second; paintClock(); &#125; public ClockPane(int hour, int minute, int second, double width, double height) &#123; this(hour, minute, second); this.w = width; this.h = height; paintClock(); &#125; /** Return hour */ public int getHour() &#123; return hour; &#125; /** Set a new hour */ public void setHour(int hour) &#123; this.hour = hour; paintClock(); &#125; /** Return minute */ public int getMinute() &#123; return minute; &#125; /** Set a new minute */ public void setMinute(int minute) &#123; this.minute = minute; paintClock(); &#125; /** Return second */ public int getSecond() &#123; return second; &#125; /** Set a new second */ public void setSecond(int second) &#123; this.second = second; paintClock(); &#125; /** Return clock pane's width */ public double getW() &#123; return w; &#125; /** Set clock pane's width */ public void setW(double w) &#123; this.w = w; paintClock(); &#125; /** Return clock pane's height */ public double getH() &#123; return h; &#125; /** Set clock pane's height */ public void setH(double h) &#123; this.h = h; paintClock(); &#125; public boolean isHourHandVisible() &#123; return hourHandVisible; &#125; public void setHourHandVisible(boolean hourHandVisible) &#123; this.hourHandVisible = hourHandVisible; paintClock(); &#125; public boolean isMinuteHandVisible() &#123; return minuteHandVisible; &#125; public void setMinuteHandVisible(boolean minuteHandVisible) &#123; this.minuteHandVisible = minuteHandVisible; paintClock(); &#125; public boolean isSecondHandVisible() &#123; return secondHandVisible; &#125; public void setSecondHandVisible(boolean secondHandVisible) &#123; this.secondHandVisible = secondHandVisible; paintClock(); &#125; /* Set the current time for the clock */ public void setCurrentTime() &#123; // Construct a calendar for the current date and time Calendar calendar = new GregorianCalendar(); // Set current hour, minute and second this.hour = calendar.get(Calendar.HOUR_OF_DAY); this.minute = calendar.get(Calendar.MINUTE); this.second = calendar.get(Calendar.SECOND); paintClock(); // Repaint the clock &#125; /** Paint the clock */ private void paintClock() &#123; // Initialize clock parameters double clockRadius = Math.min(w, h) * 0.8 * 0.5; double centerX = w / 2; double centerY = h / 2; Point2D center = new Point2D(centerX, centerY); // Draw circle Circle circle = new Circle(centerX, centerY, clockRadius); circle.setFill(Color.WHITE); circle.setStroke(Color.BLACK); // Draw time numbers Text[] texts = new Text[12]; for (int i = 0; i &lt; 12; i++) &#123; int time = (i + 3 &gt; 12) ? i + 3 - 12 : i + 3; Point2D b = new Point2D( centerX + clockRadius * Math.cos(i * 2 * Math.PI / 12), centerY + clockRadius * Math.sin(i * 2 * Math.PI / 12)); b = getPointBCloserToA(center, b, 0.82); texts[i] = new Text(b.getX() - (clockRadius * 0.03125), b.getY() + (clockRadius * 0.025), "" + time); &#125; // Draw dashes Line[] dashes = new Line[60]; for (int i = 0; i &lt; dashes.length; i++) &#123; Point2D start = new Point2D( centerX + clockRadius * Math.cos(i * 2 * Math.PI / 60), centerY + clockRadius * Math.sin(i * 2 * Math.PI / 60)); double coefficient = (i % 5 == 0) ? 0.91 : 0.955; Point2D end = getPointBCloserToA(center,start, coefficient); dashes[i] = new Line(start.getX(), start.getY(), end.getX(), end.getY()); &#125; // Draw second hand double sLength = clockRadius * 0.8; double secondX = centerX + sLength * Math.sin(second * (2 * Math.PI / 60)); double secondY = centerY - sLength * Math.cos(second * (2 * Math.PI / 60)); Line sLine = new Line(centerX, centerY, secondX, secondY); sLine.setStroke(Color.RED); sLine.setVisible(isSecondHandVisible()); // Draw minute hand double mLength = clockRadius * 0.65; double xMinute = centerX + mLength * Math.sin(minute * (2 * Math.PI / 60)); double minuteY = centerY - mLength * Math.cos(minute * (2 * Math.PI / 60)); Line mLine = new Line(centerX, centerY, xMinute, minuteY); mLine.setStroke(Color.BLUE); mLine.setVisible(isMinuteHandVisible()); // Draw hour hand double hLength = clockRadius * 0.5; double hourX = centerX + hLength * Math.sin((hour % 12 + minute / 60.0) * (2 * Math.PI / 12)); double hourY = centerY - hLength * Math.cos((hour % 12 + minute / 60.0) * (2 * Math.PI / 12)); Line hLine = new Line(centerX, centerY, hourX, hourY); hLine.setStroke(Color.GREEN); hLine.setVisible(isHourHandVisible()); // Draw time HH:MM:SS String s = "" + getHour() + ":" + getMinute() + ":" + getSecond(); Text timeText = new Text(getW() * 0.4, getH() - 10, s); // Adding nodes to pane getChildren().clear(); ObservableList&lt;Node&gt; list = getChildren(); list.add(circle); Collections.addAll(list, dashes); Collections.addAll(list, texts); list.addAll(sLine, mLine, hLine, timeText); &#125; public void start()&#123; timeline.play(); &#125; public void stop()&#123; timeline.pause(); &#125; private void update()&#123; setCurrentTime(); paintClock(); &#125; private Point2D getPointBCloserToA(Point2D a, Point2D b, double coefficient) &#123; double deltaX = b.getX() - a.getX(); double deltaY = b.getY() - a.getY(); return new Point2D( a.getX() + coefficient * deltaX, a.getY() + coefficient * deltaY); &#125;&#125; Exercise 1015.3Test123456789101112131415161718192021222324252627282930313233343536373839404142434445464748/********************************************************************************** (Move the ball) Write a program that moves the ball in a pane. You should ** define a pane class for displaying the ball and provide the methods for moving ** the ball left, right, up, and down, as shown in Figure 15.24c. Check the ** boundary to prevent the ball from moving out of sight completely. **********************************************************************************/import javafx.application.Application;import javafx.stage.Stage;import javafx.scene.Scene;import javafx.scene.control.Button;import javafx.scene.layout.HBox;import javafx.scene.layout.BorderPane;import javafx.geometry.Pos;import javafx.geometry.Insets;public class Exercise_15_03 extends Application &#123; private BallPane ballPane = new BallPane(); @Override // Override the start method in the Application class public void start(Stage primaryStage) &#123; // Hold four buttons in a HBox HBox hBox = new HBox(5); hBox.setAlignment(Pos.CENTER); Button btLeft = new Button("Left"); Button btRight = new Button("Right"); Button btUp = new Button("Up"); Button btDown = new Button("Down"); hBox.getChildren().addAll(btLeft, btRight, btUp, btDown); // Create and register the handler btLeft.setOnAction(e -&gt; ballPane.left()); btRight.setOnAction(e -&gt; ballPane.right()); btUp.setOnAction(e -&gt; ballPane.up()); btDown.setOnAction(e -&gt; ballPane.down()); // Create a border pane BorderPane pane = new BorderPane(); pane.setPadding(new Insets(0, 10, 5, 10)); pane.setCenter(ballPane); pane.setBottom(hBox); // Create a scene and place it in the stage Scene scene = new Scene(pane, 250, 250); primaryStage.setTitle("Exercise_15_03"); // Set the stage title primaryStage.setScene(scene); // Place the scene in the stage primaryStage.show(); // Display the stage &#125;&#125; BallPane12345678910111213141516171819202122232425262728293031323334353637383940414243444546import javafx.application.Application;import javafx.scene.Scene;import javafx.scene.paint.Color;import javafx.scene.layout.Pane;import javafx.scene.shape.Circle;import javafx.scene.control.Button;import javafx.stage.Stage;public class BallPane extends Pane &#123; private Circle circle = new Circle(20, 20, 20); // Construct a default ball pane public BallPane() &#123; circle.setFill(Color.WHITE); circle.setStroke(Color.BLACK); getChildren().add(circle); // Place a ball into this pane &#125; // Move ball left public void left() &#123; circle.setCenterX(circle.getCenterX() &gt; circle.getRadius() ? circle.getCenterX() - 20 : circle.getCenterX()); circle.setCenterY(circle.getCenterY()); &#125; // Move ball right public void right() &#123; circle.setCenterX(circle.getCenterX() &lt; getWidth() - circle.getRadius() ? circle.getCenterX() + 20 : circle.getCenterX()); circle.setCenterY(circle.getCenterY()); &#125; // Move ball up public void up() &#123; circle.setCenterY(circle.getCenterY() &gt; circle.getRadius() ? circle.getCenterY() - 20 : circle.getCenterY()); circle.setCenterX(circle.getCenterX()); &#125; // Move ball down public void down() &#123; circle.setCenterX(circle.getCenterX()); circle.setCenterY(circle.getCenterY() &lt; getHeight() - circle.getRadius() ? circle.getCenterY() + 20 : circle.getCenterY()); &#125;&#125; 15.4123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081/********************************************************************************** (Create a simple calculator) Write a program to perform addition, subtraction, ** multiplication, and division, as shown in Figure 15.25a. **********************************************************************************/import javafx.application.Application;import javafx.scene.Scene;import javafx.scene.control.Button;import javafx.scene.layout.HBox;import javafx.scene.layout.VBox;import javafx.scene.control.TextField;import javafx.scene.control.Label;import javafx.geometry.Pos;import javafx.geometry.Insets;import javafx.stage.Stage;public class Exercise_15_04 extends Application &#123; private TextField tfNumber1 = new TextField(); private TextField tfNumber2 = new TextField(); private TextField tfResult = new TextField(); private Button btAdd = new Button("Add"); private Button btSubtract = new Button("Subtract"); private Button btMultiply = new Button("Mulitply"); private Button btDivide = new Button("Divide"); @Override // Override the start method in the Application class public void start(Stage primaryStage) &#123; // Create UI HBox hBox1 = new HBox(5); HBox hBox2 = new HBox(5); VBox vBox = new VBox(15); hBox1.getChildren().addAll(new Label("Number1: "), tfNumber1, new Label("Number2: "), tfNumber2, new Label("Result: "), tfResult); hBox2.getChildren().addAll(btAdd, btSubtract, btMultiply, btDivide); vBox.getChildren().addAll(hBox1, hBox2); // Set UI properties hBox1.setAlignment(Pos.CENTER); hBox2.setAlignment(Pos.CENTER); tfNumber1.setPrefColumnCount(4); tfNumber2.setPrefColumnCount(4); tfResult.setPrefColumnCount(4); tfResult.setEditable(false); vBox.setPadding(new Insets(2, 5, 0, 0)); // Process events btAdd.setOnAction(e -&gt; add()); btSubtract.setOnAction(e -&gt; subtract()); btMultiply.setOnAction(e -&gt; multiply()); btDivide.setOnAction(e -&gt; divide()); // Create a scene and place it in the stage Scene scene = new Scene(vBox); primaryStage.setTitle("Exercise_15_04"); // Set the stage title primaryStage.setScene(scene); // Place the scene in the stage primaryStage.show(); // Display the stage &#125; // Add number1 to number2 private void add() &#123; tfResult.setText(String.valueOf(Double.parseDouble(tfNumber1.getText()) + Double.parseDouble(tfNumber2.getText()))); &#125; // Subtract number1 from number2 private void subtract() &#123; tfResult.setText(String.valueOf(Double.parseDouble(tfNumber1.getText()) - Double.parseDouble(tfNumber2.getText()))); &#125; // Mulitply number1 and number2 private void multiply() &#123; tfResult.setText(String.valueOf(Double.parseDouble(tfNumber1.getText()) * Double.parseDouble(tfNumber2.getText()))); &#125; // Divide number 1 from number2 private void divide() &#123; tfResult.setText(String.valueOf(Double.parseDouble(tfNumber1.getText()) / Double.parseDouble(tfNumber2.getText()))); &#125;&#125; 15.812345678910111213141516171819202122232425262728293031323334/********************************************************************************** (Display the mouse position) Write two programs, such that one displays the ** mouse position when the mouse button is clicked (see Figure 15.26a) and the ** other displays the mouse position when the mouse button is pressed and ceases ** to display it when the mouse button is released. **********************************************************************************/import javafx.application.Application;import javafx.scene.Scene;import javafx.scene.layout.Pane;import javafx.scene.text.Text;import javafx.stage.Stage;public class Exercise_15_08b extends Application &#123; @Override // Override the start method on the Application class public void start(Stage primaryStage) &#123; // Create a pane Pane pane = new Pane(); // Create and register the handler pane.setOnMousePressed(e -&gt; &#123; pane.getChildren().add(new Text(e.getX(), e.getY(), "(" + e.getX() + ", " + e.getY() + ")")); &#125;); pane.setOnMouseReleased(e -&gt; &#123; pane.getChildren().clear(); &#125;); // Create a scene and place it in the stage Scene scene = new Scene(pane, 200, 200); primaryStage.setTitle("Exercise_15_08b"); // Set the stage title primaryStage.setScene(scene); // Place the scene in the stage primaryStage.show(); // Display the stage &#125; 15.10123456789101112131415161718192021222324252627282930313233343536373839404142434445464748/********************************************************************************** (Enter and display a string) Write a program that receives a string from the ** keyboard and displays it on a pane. The Enter key signals the end of a string. ** Whenever a new string is entered, it is displayed on the pane. * *********************************************************************************/import javafx.application.Application;import javafx.scene.Scene;import javafx.scene.control.Label;import javafx.scene.input.KeyCode;import javafx.scene.layout.StackPane;import javafx.stage.Stage; public class Exercise_10 extends Application &#123; @Override // Override the start method on the Application class public void start(Stage primaryStage) &#123; double width = 400; double height = 400; Label label = new Label(); // Create a pane StackPane pane = new StackPane(label); StringBuilder s = new StringBuilder(); // Create and register the handler pane.setOnKeyPressed(e -&gt; &#123; if (e.getCode().equals(KeyCode.ENTER)) &#123; label.setText(s.toString()); s.delete(0, s.length()); &#125; else &#123; s.append(e.getText()); &#125; &#125;); // Create a scene and place it in the stage primaryStage.setScene(new Scene(pane, width, height)); primaryStage.setTitle("Click to see position..");// Set the stage title primaryStage.show();// Display the stage pane.requestFocus(); &#125; public static void main(String[] args) &#123; Application.launch(args); &#125;&#125; 15.15123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051/********************************************************************************** (Geometry: add and remove points) Write a program that lets the user click on ** a pane to dynamically create and remove points (see Figure 15.28a). When the ** user left-clicks the mouse (primary button), a point is created and displayed ** at the mouse point. The user can remove a point by pointing to it and right- ** clicking the mouse (secondary button). **********************************************************************************/import javafx.application.Application;import javafx.scene.input.MouseButton;import javafx.collections.ObservableList;import javafx.scene.Scene;import javafx.scene.control.Button;import javafx.scene.layout.Pane;import javafx.scene.Node;import javafx.scene.shape.Circle;import javafx.scene.paint.Color;import javafx.stage.Stage;public class Exercise_15_15 extends Application &#123; @Override // Override the start method in the Application class public void start(Stage primaryStage) &#123; // Create a pane Pane pane = new Pane(); // Create and register the handle pane.setOnMouseClicked(e -&gt; &#123; // Create a circle Circle circle = new Circle(e.getX(), e.getY(), 5); circle.setFill(Color.WHITE); circle.setStroke(Color.BLACK); if (e.getButton() == MouseButton.PRIMARY) &#123; pane.getChildren().add(circle); &#125; else if (e.getButton() == MouseButton.SECONDARY) &#123; ObservableList&lt;Node&gt; list = pane.getChildren(); for (int i = 0; i &lt; list.size(); i++) &#123; Circle c = (Circle)list.get(i); if (circle.contains(c.getCenterX(), c.getCenterY())) &#123; list.remove(i); &#125; &#125; &#125; &#125;); // Create a scene and place it in the stage Scene scene = new Scene(pane); primaryStage.setTitle("Exercise_15_15"); // Set the stage title primaryStage.setScene(scene); // Place the scene in the stage primaryStage.show(); // Display the stage &#125;&#125; Exercise 1116.412345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061/********************************************************************************** (Create a miles/kilometers converter) Write a program that converts miles and ** kilometers, as shown in Figure 16.37b. If you enter a value in the Mile text ** field and press the Enter key, the corresponding kilometer measurement is ** displayed in the Kilometer text field. Likewise, if you enter a value in the ** Kilometer text field and press the Enter key, the corresponding miles is ** displayed in the Mile text field. **********************************************************************************/import javafx.application.Application;import javafx.stage.Stage;import javafx.scene.Scene;import javafx.scene.layout.GridPane;import javafx.scene.control.Label;import javafx.scene.control.TextField;import javafx.scene.text.Text;import javafx.geometry.Pos;import javafx.scene.input.KeyCode;public class Exercise_16_04 extends Application &#123; final double KILOMETERS_PER_MILE = 1.602307322544464; protected TextField tfMile = new TextField(); protected TextField tfKilometer = new TextField(); @Override // Override the start method in the Application class public void start(Stage primaryStage) &#123; // Set text fields alignment tfMile.setAlignment(Pos.BOTTOM_RIGHT); tfKilometer.setAlignment(Pos.BOTTOM_RIGHT); // Create a gridpane and place nodes into it GridPane pane = new GridPane(); pane.setAlignment(Pos.CENTER); pane.add(new Label("Mile"), 0, 0); pane.add(tfMile, 1, 0); pane.add(new Label("Kilometer"), 0, 1); pane.add(tfKilometer, 1, 1); // Create and register the handlers tfMile.setOnKeyPressed(e -&gt; &#123; if (e.getCode() == KeyCode.ENTER &amp;&amp; tfMile.getText().length() &gt; 0) &#123; double miles = Double.parseDouble(tfMile.getText()); tfKilometer.setText(String.valueOf(miles * KILOMETERS_PER_MILE)); &#125; &#125;); tfKilometer.setOnKeyPressed(e -&gt; &#123; if (e.getCode() == KeyCode.ENTER &amp;&amp; tfKilometer.getText().length() &gt; 0) &#123; double kilometers = Double.parseDouble(tfKilometer.getText()); tfMile.setText(String.valueOf(kilometers / KILOMETERS_PER_MILE)); &#125; &#125;); // Create a scene and place it in the stage Scene scene = new Scene(pane, 250, 60); primaryStage.setTitle("Exercise_16_04"); // Set the stage title primaryStage.setScene(scene); // Place the scene in the stage primaryStage.show(); // Display the stage &#125;&#125; 16.16123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384/********************************************************************************** (Use ComboBox and ListView) Write a program that demonstrates selecting items ** in a list. The program uses a combo box to specify a selection mode, as shown ** in Figure 16.43a. When you select items, they are displayed in a label below ** the list. **********************************************************************************/import javafx.application.Application;import javafx.stage.Stage;import javafx.scene.Scene;import javafx.scene.control.ComboBox;import javafx.scene.control.Label;import javafx.scene.control.ListView;import javafx.scene.control.ScrollPane;import javafx.scene.control.SelectionMode;import javafx.scene.control.ContentDisplay;import javafx.scene.layout.BorderPane;import javafx.geometry.Pos;import javafx.geometry.Orientation;import javafx.collections.FXCollections;import javafx.collections.ObservableList;public class Exercise_16_16 extends Application &#123; protected ObservableList&lt;String&gt; items = FXCollections.observableArrayList("China", "Japan", "Korea", "India", "Malaysia", "Vitnam"); protected ListView&lt;String&gt; lv = new ListView&lt;&gt;(items); protected ComboBox&lt;String&gt; cbo = new ComboBox&lt;&gt;(); protected Label lblSelectedItems = new Label("Selected items are "); @Override // Override the start method in the Application class public void start(Stage primaryStage) &#123; // Set combo box properties cbo.getItems().addAll("SINGLE", "MULTIPLE"); cbo.setValue("SINGLE"); // Create a label and set its content display Label lblSelectionMode = new Label("Choose Selection Mode:", cbo); lblSelectionMode.setContentDisplay(ContentDisplay.RIGHT); // Set defaut list view as single lv.getSelectionModel().setSelectionMode(SelectionMode.SINGLE); // Create and register the handlers cbo.setOnAction(e -&gt; &#123; setMode(); setText(); &#125;); lv.getSelectionModel().selectedItemProperty().addListener( ov -&gt; &#123; setMode(); setText(); &#125;); // Place nodes in the pane BorderPane pane = new BorderPane(); pane.setTop(lblSelectionMode); pane.setCenter(new ScrollPane(lv)); pane.setBottom(lblSelectedItems); pane.setAlignment(lblSelectionMode, Pos.CENTER); // Create a scene and place it in the stage Scene scene = new Scene(pane, 268, 196); primaryStage.setTitle("Exercise_16_16"); // Set the stage title primaryStage.setScene(scene); // Place the scene in the stage primaryStage.show(); // Display the stage &#125; /** Set list view selection mode */ private void setMode() &#123; if (cbo.getValue().equals("SINGLE")) lv.getSelectionModel().setSelectionMode(SelectionMode.SINGLE); else lv.getSelectionModel().setSelectionMode(SelectionMode.MULTIPLE); &#125; /** Set label text to list view selected items */ private void setText() &#123; String items = "Selected items are "; for (String i: lv.getSelectionModel().getSelectedItems()) items += i + " "; lblSelectedItems.setText(items); &#125;&#125; 16.2212345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758/********************************************************************************** (Play, loop, and stop a sound clip) Write a program that meets the following ** requirements: ** ** ■ Get an audio file from the class directory using AudioClip. ** ■ Place three buttons labeled Play, Loop, and Stop, as shown in Figure 16.46a. ** ■ If you click the Play button, the audio file is played once. If you click ** the Loop button, the audio file keeps playing repeatedly. If you click the ** Stop button, the playing stops. **********************************************************************************/import javafx.application.Application;import javafx.stage.Stage;import javafx.scene.Scene;import javafx.scene.layout.HBox;import javafx.scene.control.Button;import javafx.geometry.Pos;import javafx.geometry.Insets;import javafx.scene.media.AudioClip;import javafx.util.Duration;public class Exercise_16_22 extends Application &#123; @Override // Override the start method in the Application class public void start(Stage primaryStage) &#123; // Create three buttons Button play = new Button("Play"); Button loop = new Button("Loop"); Button stop = new Button("Stop"); // Create a pane and set its properties HBox pane = new HBox(5); pane.setAlignment(Pos.CENTER); pane.setPadding(new Insets(10, 10, 10, 10)); pane.getChildren().addAll(play, loop, stop); // Create a audio clip AudioClip audio = new AudioClip( "http://118.24.173.45/suwei.mp3"); // Create and register handlers play.setOnAction(e -&gt; &#123; audio.play(); &#125;); stop.setOnAction(e -&gt; &#123; audio.stop(); &#125;); loop.setOnAction(e -&gt; &#123; audio.setCycleCount(AudioClip.INDEFINITE); &#125;); // Create a scene and place it in the stage Scene scene = new Scene(pane); primaryStage.setTitle("Exercise_16_22"); // Set the stage title primaryStage.setScene(scene); // Place the scene in the stage primaryStage.show(); // Display the stage &#125;&#125; 16.25Test12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788/********************************************************************************** (Racing cars) Write a program that simulates four cars racing, as shown in ** Figure 16.47b. You can set the speed for each car, with maximum 100. **********************************************************************************/import javafx.application.Application;import javafx.stage.Stage;import javafx.scene.Scene;import javafx.scene.layout.HBox;import javafx.scene.layout.VBox;import javafx.scene.layout.BorderPane;import javafx.scene.control.Label;import javafx.scene.control.TextField;import javafx.geometry.Pos;import javafx.collections.ObservableList;import javafx.scene.Node;import javafx.scene.input.KeyCode;public class Exercise_16_25 extends Application &#123; protected HBox paneForSpeed = new HBox(5); protected VBox paneForCars = new VBox(5); protected ObservableList&lt;Node&gt; textFields = paneForSpeed.getChildren(); protected ObservableList&lt;Node&gt; cars = paneForCars.getChildren(); @Override // Override the start method in the Application class public void start(Stage primaryStage) &#123; final int NUMBER_OF_CARS = 4; final int PREF_COLUMN_COUNT = 2; paneForSpeed.setAlignment(Pos.CENTER); // Place labels and text fields in a pane for (int i = 0; i &lt; NUMBER_OF_CARS; i++) &#123; paneForSpeed.getChildren().addAll( new Label("Car " + (i + 1) + ":"), new TextField()); &#125; // Set specified properties for each text field in a list for (int i = 1; i &lt; textFields.size(); i+= 2) &#123; ((TextField)textFields.get(i)).setPrefColumnCount(PREF_COLUMN_COUNT); &#125; // Place nodes in a pane for cars for (int i = 0; i &lt; NUMBER_OF_CARS; i++) &#123; paneForCars.getChildren().add(new CarPane()); &#125; // Set specified properties for each element in a list for (Node car: cars) &#123; ((CarPane)car).setStyle("-fx-border-color: black"); ((CarPane)car).setY(40); &#125; // Create and register handlers for (int i = 1; i &lt; textFields.size(); i += 2) &#123; ((TextField)textFields.get(i)).setOnKeyPressed(e -&gt; &#123; if (e.getCode() == KeyCode.ENTER) &#123; setSpeed(); &#125; &#125;); &#125; // Create a border pane BorderPane pane = new BorderPane(); pane.setTop(paneForSpeed); pane.setCenter(paneForCars); // Create a scene and place it in the stage Scene scene = new Scene(pane, 400, 200); primaryStage.setTitle("Exercise_16_25"); // Set the stage title primaryStage.setScene(scene); // Place the scene in the stage primaryStage.show(); // Display the stage &#125; /** Set specified rate for a CarPane list */ private void setSpeed() &#123; for (int i = 1, j = 0; i &lt; textFields.size(); i += 2, j++) &#123; if (((TextField)textFields.get(i)).getText().length() &gt; 0) &#123; ((CarPane)cars.get(j)).setSpeed( Double.parseDouble(((TextField)textFields.get(i)).getText())); ((CarPane)cars.get(j)).play(); &#125; else &#123; ((CarPane)cars.get(j)).pause(); &#125; &#125; &#125;&#125; CarPane1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495import javafx.animation.KeyFrame;import javafx.animation.Timeline;import javafx.scene.Scene;import javafx.scene.layout.Pane;import javafx.scene.shape.Polygon;import javafx.scene.shape.Rectangle;import javafx.scene.shape.Circle;import javafx.scene.paint.Color;import javafx.util.Duration;public class CarPane extends Pane &#123; private double x; private double y = 40; private double radius = 5; private Rectangle rectangle; private Polygon polygon; private Circle circle1; private Circle circle2; private Timeline animation; /** Construct and animate a default CarPane */ CarPane() &#123; drawCar(); animation = new Timeline( new KeyFrame(Duration.millis(50), e -&gt; moveCar())); animation.setCycleCount(Timeline.INDEFINITE); &#125; /** Create a car an place it in the pane */ private void drawCar() &#123; getChildren().clear(); rectangle = new Rectangle(x, y - 20, 50, 10); polygon = new Polygon(x + 10, y - 20, x + 20, y - 30, x + 30, y - 30, x + 40, y - 20); circle1 = new Circle(x + 15, y - 5, radius); circle2 = new Circle(x + 35, y - 5, radius); getChildren().addAll(rectangle, circle1, circle2, polygon); &#125; /** Set y to specified value */ public void setY(double y) &#123; this.y = y; &#125; /** Set x to specified value */ public void setX(double x) &#123; this.x = x; &#125; /** return x */ public double getX() &#123; return x; &#125; /** return y */ public double getY() &#123; return y; &#125; /** Pause animation */ public void pause() &#123; animation.pause(); &#125; /** Play animation */ public void play() &#123; animation.play(); &#125; /** Set the animation rate to a specified amount */ public void setSpeed(double speed) &#123; if (speed &lt;= 100) animation.setRate(speed); &#125; /** Increase rate by 1 */ public void increaseSpeed() &#123; animation.setRate(animation.getRate() + 1); &#125; /** decrease rate by 1 */ public void decreaseSpeed() &#123; animation.setRate(animation.getRate() &gt; 0 ? animation.getRate() - 1 : 0); &#125; /** Redraw car with new x value */ protected void moveCar() &#123; if (x &lt;= getWidth()) &#123; x += 1; &#125; else x = 0; drawCar(); &#125;&#125; 16.27123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158/** * (Display country flag and flag description) * Listing 16.4, ComboBoxDemo.java, gives a program that * lets the user view a country’s flag image and description * by selecting the country from a combo box. * The description is a string coded in the program. * Rewrite the program to read the text description from a file. * Suppose that the descriptions are stored in the files description0.txt, . . . , and * description8.txt under the text directory for the nine countries Canada, * China, Denmark, France, Germany, India, Norway, United Kingdom, * and United States, in this order. * */import javafx.application.Application;import javafx.collections.FXCollections;import javafx.collections.ObservableList;import javafx.geometry.Insets;import javafx.scene.Scene;import javafx.scene.control.*;import javafx.scene.image.ImageView;import javafx.scene.layout.BorderPane;import javafx.scene.text.Font;import javafx.stage.Stage;import java.io.File;import java.io.FileNotFoundException;import java.util.Scanner;public class Exercise_27 extends Application &#123; // Declare an array of Strings for flag titles private String[] flagTitles = &#123;"Canada", "China", "Denmark", "France", "Germany", "India", "Norway", "United Kingdom", "United States of America"&#125;; // Declare an ImageView array for the national flags of 9 countries private ImageView[] flagImage = &#123;new ImageView("image/ca.gif"), new ImageView("image/china.gif"), new ImageView("image/denmark.gif"), new ImageView("image/fr.gif"), new ImageView("image/germany.gif"), new ImageView("image/india.gif"), new ImageView("image/norway.gif"), new ImageView("image/uk.gif"), new ImageView("image/us.gif")&#125;; // Declare an array of strings for flag descriptions private String[] flagDescription = new String[9]; // Declare and create a description pane private DescriptionPane descriptionPane = new DescriptionPane(); // Create a combo box for selecting countries private ComboBox&lt;String&gt; cbo = new ComboBox&lt;&gt;(); // flagTitles); @Override // Override the start method in the Application class public void start(Stage primaryStage) &#123; // Set text description for (int i = 0; i &lt; flagDescription.length; i++) &#123; Scanner input; String s = ""; try &#123; input = new Scanner(new File("src/Text Files/description" + i + ".txt")); while (input.hasNext()) &#123; s += input.nextLine() + "\n"; &#125; flagDescription[i] = s; &#125; catch (FileNotFoundException e) &#123; e.printStackTrace(); &#125; &#125; // Set the first country (Canada) for display setDisplay(0); // Add combo box and description pane to the border pane BorderPane pane = new BorderPane(); BorderPane paneForComboBox = new BorderPane(); paneForComboBox.setLeft(new Label("Select a country: ")); paneForComboBox.setCenter(cbo); pane.setTop(paneForComboBox); cbo.setPrefWidth(400); cbo.setValue("Canada"); ObservableList&lt;String&gt; items = FXCollections.observableArrayList(flagTitles); cbo.getItems().addAll(items); pane.setCenter(descriptionPane); // Display the selected country cbo.setOnAction(e -&gt; setDisplay(items.indexOf(cbo.getValue()))); // Create a scene and place it in the stage Scene scene = new Scene(pane, 450, 170); primaryStage.setTitle("ComboBoxDemo"); // Set the stage title primaryStage.setScene(scene); // Place the scene in the stage primaryStage.show(); // Display the stage &#125; /** Set display information on the description pane */ public void setDisplay(int index) &#123; descriptionPane.setTitle(flagTitles[index]); descriptionPane.setImageView(flagImage[index]); descriptionPane.setDescription(flagDescription[index]); &#125; public static void main(String[] args) &#123; launch(args); &#125; private class DescriptionPane extends BorderPane &#123; /** Label for displaying an image and a title */ private Label lblImageTitle = new Label(); /** Text area for displaying text */ private TextArea taDescription = new TextArea(); public DescriptionPane() &#123; // Center the icon and text and place the text under the icon lblImageTitle.setContentDisplay(ContentDisplay.TOP); lblImageTitle.setPrefSize(200, 100); // Set the font in the lbl and the text field lblImageTitle.setFont(new Font("SansSerif", 16)); taDescription.setFont(new Font("Serif", 14)); taDescription.setWrapText(true); taDescription.setEditable(false); // Create a scroll pane to hold the text area ScrollPane scrollPane = new ScrollPane(taDescription); // Place lbl and scroll pane in the border pane setLeft(lblImageTitle); setCenter(scrollPane); setPadding(new Insets(5, 5, 5, 5)); &#125; /** Set the title */ public void setTitle(String title) &#123; lblImageTitle.setText(title); &#125; /** Set the image view */ public void setImageView(ImageView icon) &#123; lblImageTitle.setGraphic(icon); &#125; /** Set the text description */ public void setDescription(String text) &#123; taDescription.setText(text); &#125; &#125;&#125;]]></content>
      <tags>
        <tag>Java Homework</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[How to Convert a Caffe Model to a .mlmodel File]]></title>
    <url>%2F2018%2F03%2FHow-to-Convert-a-Caffe-Model-to-a-mlmodel-File%2F</url>
    <content type="text"><![CDATA[Recommend reading on the computer Before StartThe purpose of this article is to introduce how to use Apple’s Core ML Tools (hereafter referred to as CMT) to convert Caffe’s model to a .mlmodel file. Caffe is a framework for deep learning. If you want to know more about it, you can go to Caffe’s official website and you won’t see any details here. Install PythonAs a Python tool, CMT first has to have a Python environment. If you have already installed Python 2.7, this step can be skipped; Python environment can be Download Here Here you will find that Python has two versions, one is 2.7 and another is 3.6. In general, I would suggest that you should go straight to install the 3.6 version, but this time it is different because CMT this weird thing can only supports Python 2.7, so you must download the 2.7 version Install VirtualenvVirtualenv is a tool for creating isolated Python environments. All of our subsequent operations need to be done in the virtual environment which is created by this stuff. This step is not an optional step. Without this step,your Python environments will crash. (The word “virtual environment” is not as nice as it sounds. It’s better to change the name. I called this Reality Marble. Now open Terminal Pip install virtualenv Since everything was installed before, it would be normal if your output was different from mine, as long as a “successful installation” can be achieved. Create a Reality MarbleEnter the following two lines of command: virtualenv -p /usr/bin/python2.7 source env/bin/activate The first line creates an Reality Marble named “env” with a Python version of 2.7. The name of the Reality Marble is set by yourself, and you can change the name as your wish. The second line enters the Reality Marble. After entering the Reality Marble, you can see that there is more (env) in the front line. This is the sign that enters Reality Marble. Install CoremltoolsEnter the following line of command: Pip install coremltools Waiting for installationWaiting for the installation time is relatively boring, this time you can go to Caffe’s model .There is a list of ready-to-use models. I used Oxford102 in this article here. This is a model for identifying flower species. Here I will introduce this Caffe model. class_labels.txt: It contains all the forecast results Deploy.prototxt: This document describes the neural network structure of this model Oxford102.caffemodel: This is a data training model in Caffe format Why should I say this first? This is because you can only find the download address of .caffemodel directly on this page. You cannot find two other files. If you want a .prototxt file, you need to go to AlexNet . What about class_labels.txt? This is not readily available. There is only one class_labels.py in the root directory. You need to change the contents of this file to the following, and then change the suffix name to txt. Conversion CodeAfter you get these three files and finish installing coremltools, you can write the conversion code. import coremltools The first line refers to the coremltools you just installed. coreml_model = coremltools.converters.caffe.convert((‘oxford102.caffemodel’, ‘deploy.prototxt’), image_input_names=’data’, class_labels=’class_labels.txt’) The second line is to convert the Caffe model ,image_input names=’data’ means to set the input data type to image. coreml_model.save(‘Flowers.mlmodel’) The third line names the file Flowers.mlmodel and saves RunNow put the written Python file in the same folder as the three files. Then cd to this folder in Terminal. Then use python converter.py Although there are only three lines of code, but the conversion time is very long. You will get this after the conversion: Then you just throw it into the project and use it. Close Reality Marbleinput the command: deactivate This article does not introduce but is also worth learning about CMT convertible model type Other framework conversion methods Perfection of the basic information of the converted model …… Referencehttps://goo.gl/YYH8Yh]]></content>
      <tags>
        <tag>Python</tag>
        <tag>Deep Learning</tag>
        <tag>CMT</tag>
        <tag>Virtualenv</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Guide on Packaging and Import 3rd party plugins to Chrome]]></title>
    <url>%2F2018%2F03%2FGuide-on-Packaging-and-Import-3rd-party-plugins-to-Chrome%2F</url>
    <content type="text"><![CDATA[It’s been a loooooong time since the last update. Just cause I’m too lazy. XP.And now,I will use English as much as I can. TL;DRChrome removed many 3rd party plugins from Chrome App Store due to some unknown Python transaction recently. Due to security reason Chrome will disable extensions import locally with unknown source. You will get annoying popups every time launching Chrome if unpacked extensions are loaded. So in this thread I’ll provide a better solution to load 3rd party plugins with the latest build using Windows Group Policy or using configuration profiles for macOS. Package the extension This step is unnecessary if you have the complied version. Launch Chrome, open chrome://extensions, click Pack extension on top-left. Browse the code you just downloaded, click Pack Extension. The newly built extension will be found in the source folder with a *.pem file, keep them all, you will need that .pem file if you want to update the extension in the furture. Drag the *.crx file to the chrome://extension page to install it. Select the Developer Modecheckbox to show the hidden extension ID, save it somewhere. Apply Chrome policy using Group Policy EditorSee For MacOS Users if you are using MacOS. Download the zip file of Chrome templates from here. Extract the following files or folders into %SystemRoot%\PolicyDefinitions: ./Windows/admx/chrome.admx; ./Windows/admx/google.admx; ./Windows/admx/en-US/; ./Windows/admx/zh-CN. Press Win+R and run: gpedit.msc. A sub-folder named Google / Google Chrome can be found under Local Computer Policy &gt; Computer Configuration &gt; Administrative Templates. (Ps. The group policy editor is not embeded with starter and home editions. Follow this guide to install it first. (Thanks @metafaniel for refering this issue.)) Add the extension ID to whitelistAdd the extension ID by the following steps: Navigate to Administrative Templates / Google / Google Chrome / Extensions section. Double click to open Configure extension installation whitelist on the right side. Enable the policy and click Show... to add the extension ID. The extension will be enabled by default after Chrome relaunched. For MacOS UsersThis solution inspired by free1x, thanks. Download the following policy template. Download configuration profiles Now OR copy this 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd"&gt;&lt;plist version="1.0"&gt;&lt;dict&gt; &lt;key&gt;PayloadContent&lt;/key&gt; &lt;array&gt; &lt;dict&gt; &lt;key&gt;PayloadContent&lt;/key&gt; &lt;dict&gt; &lt;key&gt;com.google.Chrome&lt;/key&gt; &lt;dict&gt; &lt;key&gt;Forced&lt;/key&gt; &lt;array&gt; &lt;dict&gt; &lt;key&gt;mcx_preference_settings&lt;/key&gt; &lt;dict&gt; &lt;key&gt;ExtensionInstallWhitelist&lt;/key&gt; &lt;array&gt; &lt;string&gt;value01&lt;/string&gt; &lt;string&gt;value02&lt;/string&gt; &lt;string&gt;value03&lt;/string&gt; &lt;/array&gt; &lt;/dict&gt; &lt;/dict&gt; &lt;/array&gt; &lt;/dict&gt; &lt;/dict&gt; &lt;key&gt;PayloadEnabled&lt;/key&gt; &lt;true/&gt; &lt;key&gt;PayloadIdentifier&lt;/key&gt; &lt;string&gt;MCXToProfile.7e2bec75-299e-44ff-b405-628007abffff.alacarte.customsettings.bdac4880-d25f-4cdd-8472-05473f005e7e&lt;/string&gt; &lt;key&gt;PayloadType&lt;/key&gt; &lt;string&gt;com.apple.ManagedClient.preferences&lt;/string&gt; &lt;key&gt;PayloadUUID&lt;/key&gt; &lt;string&gt;bdac4880-d25f-4cdd-8472-05473f005e7e&lt;/string&gt; &lt;key&gt;PayloadVersion&lt;/key&gt; &lt;integer&gt;1&lt;/integer&gt; &lt;/dict&gt; &lt;/array&gt; &lt;key&gt;PayloadDescription&lt;/key&gt; &lt;string&gt;Included custom settings:com.google.Chrome&lt;/string&gt; &lt;key&gt;PayloadDisplayName&lt;/key&gt; &lt;string&gt;MCXToProfile: com.google.Chrome&lt;/string&gt; &lt;key&gt;PayloadIdentifier&lt;/key&gt; &lt;string&gt;com.google.Chrome&lt;/string&gt; &lt;key&gt;PayloadOrganization&lt;/key&gt; &lt;string&gt;&lt;/string&gt; &lt;key&gt;PayloadRemovalDisallowed&lt;/key&gt; &lt;true/&gt; &lt;key&gt;PayloadScope&lt;/key&gt; &lt;string&gt;System&lt;/string&gt; &lt;key&gt;PayloadType&lt;/key&gt; &lt;string&gt;Configuration&lt;/string&gt; &lt;key&gt;PayloadUUID&lt;/key&gt; &lt;string&gt;7e2bec75-299e-44ff-b405-628007abffff&lt;/string&gt; &lt;key&gt;PayloadVersion&lt;/key&gt; &lt;integer&gt;1&lt;/integer&gt;&lt;/dict&gt;&lt;/plist&gt;view rawcom.google.Chrome.mobileconfig hosted with ❤ by GitHub Add the extension ID to line 19, delete line 20 and 21 if you don’t need it. Save. Double click to import this policy. REBOOT Referenceshttps://steemit.com/chrome/@free1x/chrome http://xclient.info/a/1ddd2a3a-d34b-b568-c0d0-c31a95f0b309.html?_=c15d0db4b6cd8c32262ffbacc7695d50 https://gist.github.com/Explorare/be3dd598289252698cd37bca04abd0fe#file-com-google-chrome-mobileconfig]]></content>
      <tags>
        <tag>Browser</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[An intersting problem with Swift]]></title>
    <url>%2F2018%2F01%2FAn-intersting-problem-with-Swift%2F</url>
    <content type="text"><![CDATA[Paul Hudson‏ He recently posted a question about Swift Language on twitter,quite interesting Q1: All three match - how many ways can you think of to make this true in Swift? You’ll learn by trying 👍 PS:Code or it didn’t happen 😘 My idea is to change the way “get” works A1:Several methods have been collected so far Rewrite ‘==’Joe Groff‏ 1234func == (a: inout Int, b: Int) -&gt; Bool &#123; defer &#123; a += 1 &#125; return ! (a != b)&#125; Andy Lee‏ 1234567var a = 1extension Int &#123; static func == (left: Int, right: Int) -&gt; Bool &#123; a += 1 return !(left != right) &#125;&#125; Marius Fanu 12345extension Int &#123; static func == (lhs: Int, rhs: Int) -&gt; Bool &#123; return true &#125;&#125; Nate Cook 1234567891011var fakedOut = falsefunc == (lhs: Double, rhs: Int) -&gt; Bool &#123; if !fakedOut &#123; print("All three match!") fakedOut = true &#125; return Int(lhs) == rhs&#125;let a = 0.0let b = 0.0 Using UnicodeToni Suter 123let a = 1 // 'a'let a = 2 // 'a' + ZERO WIDTH SPACElet a = 3 // 'a' + ZERO_WIDTH_SPACE + ZERO_WIDTH_SPACE Other waysToni Suter 12345678enum Foo: ExpressibleByIntergerLiteral &#123; case bar init (integerLiteral value: Int) &#123; self = .bar &#125;&#125;let a = Foo.bar Toni Suter 12345var _a = 0var a:Int &#123; _a += 1 return _a&#125; Q2: Lots of folks are using operator overloading, so for them here’s hard mode !😈 A2:Rewrite ‘&amp;&amp;’John Payne 1234567extension Bool &#123; static func &amp;&amp;(lhs: Bool, rhs: Bool) -&gt; Bool &#123; return lhs || rhs ? true : false &#125;&#125;let a = 2let b = 5 BoolApollo Zhu‏ 123456extension Bool: ExpressibleByInterLiteral &#123; public init (integerLiteral value: Int) &#123; srlf = value != 0 &#125;&#125;let a: Bool = 1, b = 1 If you know more ways, please let me know in the comments below～]]></content>
      <tags>
        <tag>Swift</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Collection of answers for C Language homework]]></title>
    <url>%2F2018%2F01%2FCollection-of-answers-for-C-Language-homework%2F</url>
    <content type="text"><![CDATA[Summarize the previous homework answers,perhaps loading will be slow,I guess XD Experiment 2Because The Experiment 1 is too easy so there is no upload (not my lazy) If the code has somewhere different………maybe I increased the difficulty of the question. Advanced3.2123456789#include &lt;stdio.h&gt;int main(int argc, const char * argv[]) &#123; char a, b, c; int sum; scanf("%c%c%c",&amp;a,&amp;b,&amp;c); sum = (a-'0')*100+(b-'0')*10+(c-'0'); printf("the number is %d\n",sum); return 0;&#125; 3.41234567891011121314151617#include &lt;stdio.h&gt;int main(int argc, const char * argv[]) &#123; while(1)&#123; float x; printf("Please enter a number from[1.0 , 100.0]\n"); if (!scanf("%f", &amp;x))&#123; printf("Input error ,please enter again\n"); while(getchar()!='\n');&#125; else if (x&lt;1.0||x&gt;100.0)&#123; printf("The number is not correct\n");&#125; else&#123; printf("The number is %lf\n",(x*x*x*x*x)); break; &#125; &#125; return 0;&#125; 3.11 Super Power Plus1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include &lt;stdio.h&gt;int main(int argc, const char * argv[]) &#123; char a[1000]; int i; gets(a); puts(a); printf("\n"); for(i=0;a[i]!='\0';i++) &#123; if(a[i]&gt;='A'&amp;&amp;a[i]&lt;='V') a[i]+=4; else if(a[i]&gt;='a'&amp;&amp;a[i]&lt;='v') a[i]+=4; &#125; for (i=0;a[i]!='\0';i++) &#123; switch(a[i])&#123; case 'w': a[i] = 'a'; break; case 'x': a[i] = 'b'; break; case 'y': a[i] = 'c'; break; case 'z': a[i] = 'd'; break; case 'W': a[i] = 'A'; break; case 'X': a[i] = 'B'; break; case 'Y': a[i] = 'C'; break; case 'Z': a[i] = 'D'; break; &#125; &#125; for (i=0;a[i]!='\0';i++) &#123; printf("%c",a[i]); &#125; printf("\n"); return 0;&#125; 3.12123456789101112#include &lt;stdio.h&gt;int main(int argc, const char * argv[]) &#123; int a,b,x,y,z; printf("Please input a number from (10~99):"); scanf("%d",&amp;a); b=a*a; x=b%10; y=b/10%10; z=10*y+x; printf("The number is:%d\n",z); return 0;&#125; Experiment 3Here added A bubbling algorithm Basis2.2（Plus）123456789101112131415161718192021222324252627//这是一个很简单的冒泡算法，利用循环解决问题字符串输出最小ascii码对应的字符#include &lt;stdio.h&gt;#include &lt;string.h&gt;int main()&#123; int a,temp; char c[50]; printf("请输入一串字符/n"); gets(c); a=strlen(c); printf("长度是：%d/n",a); for(int i=0;i&lt;a;i++) &#123; for(int j=i+1;j&lt;a;j++) //j&lt;a 如果等于a的话 数组就超过了，因为从0开始的，比如a[4] 就是a[0],a[1],a[2],a[3] 四个引用,不懂就去翻书 &#123; if(c[i]&gt;c[j]) &#123; temp=c[j];//temp提供一个交换作用 c[j]=c[i]; c[i]=temp; &#125; &#125; &#125; printf("排序后：%s/n",c); return 0;&#125; Advanced3.51234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859//解决此问题有更简单的办法，利用数组和循环，请自己思考#include &lt;stdio.h&gt;int main()&#123; int day,month,year,sum = 0,leap; printf("please input year,month,day\n"); scanf("%d%d%d",&amp;year,&amp;month,&amp;day); switch(month) /*先计算某月以前月份的总天数*/ &#123; case 1: sum=0; break; case 2: sum=31; break; case 3: sum=59; break; case 4: sum=90; break; case 5: sum=120; break; case 6: sum=151; break; case 7: sum=181; break; case 8: sum=212; break; case 9: sum=243; break; case 10: sum=273; break; case 11: sum=304; break; case 12: sum=334; break; default: printf("data error"); break; &#125; sum=sum+day; /*再加上某天的天数*/ if(year%400==0||(year%4==0&amp;&amp;year%100!=0)) /*判断是不是闰年*/ leap=1; else leap=0; if(leap==1&amp;&amp;month&gt;2) /*如果是闰年且月份大于2,总天数应该加一天*/ sum++; printf("It is the %dth day of %d year\n",sum,year); return 0;&#125; Experiment 4本文章涉嫌剧透，请紧张的往下看 说在前面，今天一位在腾讯搞开发工作的大佬给我指点了一下，”批评“了我printf(“\n”);的不良用法，然后还讲了一些其他的东西，在这里和大家先分享一下。 (仅供参考，请辩证的往下看） printf(“%s\n”,s)是一种很蠢的写法，某些实现会把printf(“%s\n”,s)自动优化为puts(s)。这说明连编译器都对printf(“%s\n”,s)看不下去了，原因是很多人上来学的就是printf()，有一种先入为主的惯性。加上对自己的代码质量没有太高的要求，所以只要输出就想到用printf()。类似的还有输出新行符写成printf(“\n”) （才写printf(“\n”)的我：汗。。。。。） 就K&amp;R而言，在讲hello,world时还介绍了\n，以及 123printf(&quot;hello,&quot;);printf(&quot;world&quot;);printf(&quot;\n&quot;); 这种等价写法。 这两个知识是用puts()不胜任的。 比如，puts()本身，“不用加’\n’就自动换行”(实际是遇到\0输出\n)，这就很难引入对\n的介绍，因为不需要。如果硬要引入(比如在字符串中间加\n)则显得很不自然，而且很难解释\0转成\n的问题。用用puts()的另一个问题是没法把”hello,world“分成几段逐次输出。而把”hello,world“分成几段逐次输出对于学习者深入理解“程序”这个概念、学习美化C程序格式以及领略C语言灵活的特点的是很有意义的。So，如果教材介绍了相关的知识，那么使用printf()讲hello,world无可非议；如果没介绍相关知识，那就是东施效颦，还不如用puts()。 但是，puts()有一个很重要的问题就是缺少额外的格式检查和维护优势。使用printf()并不仅仅在于其带有返回值可以方便格式检查，同时还在于避免hardwriting完成代码开发维护和运营更新的分离。（我：看不懂= =） 另外，scanf(“%s”,str)在遇到’\n’（回车）或’ ‘（空格）时输入结束，但’\n’（回车）或’ ‘（空格）停留在出入缓冲区，如处理不慎会影响下面的输入；gets(str)遇到’\n’（回车）时输入结束，但’\n’（回车）已被替换为’\0’，存储于字符串中，输入缓冲中没有遗留的’\n’（回车），不会影响后续的输入。 (仅供参考，请辩证的往上看） Basis2.5（Plus）突然想起这题还有另一种输出方式，推荐亲自运行一下，看看是什么结果～ 1234567891011121314151617181920#include &lt;stdio.h&gt;int main()&#123; int i,j,m; for(i=1;i&lt;=9;i++) &#123; for(j=1;j&lt;=i;j++) printf("%dx%d=%2d\t",j,i,j*i); printf("\n"); &#125; for(i=1;i&lt;=9;i++) &#123; for(m=1;m&lt;=9-i;m++) printf(" \t"); for(j=i;j&gt;=1;j--) printf("%dx%d=%2d\t",j,i,j*i); printf("\n"); &#125; return 0;&#125; Advanced3.3利用递归解决此类问题 123456789101112131415161718192021222324#include &lt;stdio.h&gt;#include &lt;math.h&gt;double Func(double x);//定义功能函数int main()&#123; double j,i=0,x=1; do&#123; i+=1.0/Func(x);//调用函数 j=1.0/Func(x); x++; &#125; while(j&gt;1e-6);//定义精度 printf("%f\n",i); return 0;&#125; double Func(double n)&#123; double f; if(n==0||n==1)//检测 f=1; else f=Func(n-1)*n;//反复调用自身达到阶乘的效果 return(f); //返回结果&#125; 3.13（Plus）若题目多一个非数字时停止，能否用一行代码实现判断和输入呢？ 12345678910111213#include &lt;stdio.h&gt;int main()&#123; float a,b; while (scanf("%f%f",&amp;a,&amp;b)==2&amp;&amp;a&gt;=0&amp;&amp;b&gt;=0)//一行解决输入和判断 &#123; printf("%f\n",a-b); &#125; return 0;&#125;/*continue:其实对于scanf这样的一些库函数其实对其来讲，他们使用起来并不是很友好，比如在不同的编译环境中，他们得到的结果数值是不一样的，这就需要如果我们需要在实际应用使用他们的话，就需要我们对他进行一些实际考证，这样才可以放心使用，可移植性并不优秀*/ 1.scanf（）函数返回成功读入的项目的个数。即在下面程序中scanf的返回值为1。如果没有读取任何项目（如它期望一个数字但是出入了一个非数字字符），它会返回值0。当它检测到“文件结尾”时，它返回EOF（EOF是文件stdio.h中定义的特殊值。一般，#define 指令把EOF 的值定义为 -1）。 1234int n;float p;n= scanf("%f",&amp;p);printf("%d,%f",n,p); 用%c读入空格和字符的问题。 如果在格式字符串中%c之前有一个空格，那么scanf()会跳到第一个非空白字符处。也就是说，命令scanf(“%c”,&amp;ch)读取在输入中遇到的第一个字符，而scanf(“ %c”,&amp;ch)（%c前有个空格）则读取遇到的第一个非空白字符。 对于同时输入几个字符，如果逗号（或任何非空格字符）和第一个%c之间没有间隔，则输入时，第一个字符与逗号之间也不能有间隔；如果有空格，则输入时，第一个字符和逗号之间可以有任意多个字符，也可以是0个。如果逗号和第二个%c之间没有间隔，则逗号和第二个输入字符间也不能有间隔。如果有空格，则输入时，第二个字符和逗号之间可以有任意多个字符，也可以是0个。 3.16（补充）问题分析： 如果说n和m是一个亲密数对，那么它们必须满足以下条件\1. n的全部因子之和（不包括n）必须等于m\2. m的全部因子之和（不包括m）必须等于n 例如：220的全部因子之和为：1+2+4+5+10+11+20+22+44+55+110=284 284的全部因子之和为：1+2+4+71+142=220 所以220和284是一对个亲密数对，输出格式：220-&gt;284 1234567891011121314151617181920212223242526272829#include &lt;stdio.h&gt;#include &lt;math.h&gt;int GFS(int n)&#123; int i, sum = 0; for (i = 1; i * i &lt;= n; i++) &#123; if (n % i == 0) &#123; if (i == 1 || i * i == n) sum += i; else sum += i + n / i; &#125; &#125; return sum;&#125;int main()&#123; int i, num; for (i = 2; i &lt;= 2000; i++) &#123; num = GFS(i); if (GFS(num) == i &amp;&amp; i &lt; num) printf("%d-&gt;%d\n", i, num); &#125; return 0;&#125; 3.17123456789101112131415161718#include&lt;stdio.h&gt;int main()&#123; int getsum(int n);//定义函数 int x,y; for(x=2;x&lt;1000;x++) for(y=2;y&lt;1000;y++)//循环开始 if((x==getsum(y))&amp;&amp;(y==getsum(x))&amp;&amp;x!=y)//条件判断 printf("%-5d%-5d%\n",x,y);&#125;int getsum(int n)&#123; int i,a=1; for(i=2;i&lt;=n/2;i++) if(!(n%i)) a=a+i; return a;//返回值&#125; 3.26（拓展）用三种方法来解答次题 1234567891011121314151617181920//普通算法#include &lt;stdio.h&gt;int main()&#123; int p,i,n,m,temp; printf("输入两个正整数 n 和 m："); scanf("%d,%d",&amp;n,&amp;m); if(n&lt;m)&#123; temp=n; n=m; m=temp; &#125; /*把大数放在 n 中，小数放在 m 中*/ for (i=m;i&gt;=2;i--) /*求 n 和 m 的最大公约数*/ &#123; if (m%i==0 &amp;&amp; n%i==0) break ; &#125; printf("最大公约数%d\n",i); printf("最小公倍数%d\n",m*n/i); /*p 是原来两个整数的乘积*/&#125; 当然，也可以用递归的方法 123456789101112131415161718192021//递归求两个整数最大公约数 最小公倍数#include &lt;stdio.h&gt;int gbs(int x,int y);int main() &#123; int m,n,t1; printf("please input two integer number:"); scanf("%d%d",&amp;m,&amp;n); t1=gbs(m,n); printf("The highest common divisor is %d\n",t1); printf("The least common multiple is %d\n",m*n/t1); return 0;&#125;int gbs(int a,int b)&#123; if(a%b==0) return b; else return gbs(b,a%b); &#125; 重头戏来了：辗转相除法关于辗转相除法： 在我国古代的《九章算术》中就有记载，现摘录如下: 约分术曰：“可半者半之，不可半者，副置分母、子之数，以少减多，更相减损，求其等也。以等数约之。” 其中所说的“等数”，就是最大公约数。求 “等数”的办法是“更相减损”法，实际上就是辗转相除法。 辗转相除法求最大公约数，是一种比较好的方法，比较快。 对于 52317 和 75569 两个数。先用较大的 75569 除以 52317，得商 1，余数 23252，再以 52317 除以 23252，得商 2，余数是 5813，再用 23252 做被除数，5813 做除数，正好除尽得商数 4。这样 5813 就是 75569 和 52317 的最大公约数。 比如说有要求 a、b 两个整数的最大公约数，a＞b，那么我们先用 a 除以 b，得到商 8，余数 r1：a÷b ＝q1…r1 我们当然也可以把上面这个式子改写成乘法式：a＝bq1＋r1——l） 如果 r1＝0，那么 b 就是 a、b 的最大公约数 3。要是 r1≠0，就继续除，用 b 除以 r1，我们也可以有和上面一样的式子： b＝r1q2＋r2——-2） 如果余数 r2＝0，那么 r1 就是所求的最大公约数 3。为什么呢？因为如果 2）式变成了 b＝r1q2，那么 b1r1 的公约数就一定是 a1b 的公约数。这是因为一个数能同时除尽 b 和 r1，那么由 l）式，就一定能整除 a，从而也是 a1b 的公约数。 反过来，如果一个数 d，能同时整除 a1b，那么由 1）式，也一定能整除 r1，从而也有 d 是 b1r1 的公约数。 这样，a 和 b 的公约数与 b 和 r1 的公约数完全一样，那么这两对的最大公约数也一定相同。那 b1r1 的最大公约数，在 r1＝0 时，不就是 r1 吗？所以 a 和 b 的最大公约数也是 r1 了。 有人会说，那 r2 不等于 0 怎么办？那当然是继续往下做，用 r1 除以 r2，…… 直到余数为零为止。 在这种方法里，先做除数的，后一步就成了被除数，这就是辗转相除法名字的来历。 12345678910111213141516171819#include &lt;stdio.h&gt;int main()&#123; int p,r,n,m,temp; printf("输入两个正整数 n 和 m："); scanf("%d,%d",&amp;n,&amp;m); if(n&lt;m) &#123;temp=n;n=m;m=temp;&#125; /*把大数放在 n 中，小数放在 m 中*/ p=n*m; /*先将 n 和 m 的乘积保存在 p 中，以便求最小公倍数时用*/ r=n%m; while(r!=0) /*求 n 和 m 的最大公约数*/ &#123; n=m;m=r;r=n%m;&#125; printf("最大公约数%d\n",m); printf("最小公倍数%d\n",p/m); /*p 是原来两个整数的乘积*/ return 0;&#125; Experiment 5Ps：之前群里有人问一道oj题，然而本人基本没做过oj，就点简单的写了些（在底部），其中我用了struct，会单独放一篇文章讲解。 感觉实验5没啥需要po出来的=。= Basis2.7只是添加了一个自己输入行数的功能而已= 。= 123456789101112131415161718192021222324252627282930#include &lt;stdio.h&gt;int main(int argc, const char * argv[])&#123; int arr[30][30]= &#123;0&#125;; int n; printf("input n:"); scanf("%d",&amp;n); for(int i=1; i&lt;=n; i++) &#123; arr[i][1]=1; arr[i][i]=1; if(i&gt;=2) &#123; for(int j=1; j&lt;=i; j++) &#123; arr[i][j]=arr[i-1][j-1]+arr[i-1][j]; &#125; &#125; &#125; for(int i=1; i&lt;=n; i++) &#123; for(int j=1; j&lt;=i; j++) &#123; printf("%3d ",arr[i][j]); &#125; putchar('\n'); &#125; return 0; &#125; Advanced3.2既然是要同时输出之前的顺序，不如设定两个数组。(坐下！基本操作而已。) 1234567891011121314151617181920212223242526272829303132333435363738#include &lt;stdio.h&gt;int main(int argc, const char * argv[])&#123; int i, j,k,l,t1,t2; int a[20], b[20]; printf("please enter 20 numbers:"); for( i=0, j=1; i&lt;20; i++, j++) &#123; scanf("%d", &amp;a[i]); b[i] = j; &#125; for( k = 0; k&lt;20; k++)&#123; for( l =k+1; l&lt;=19; l++) &#123; if(a[k]&gt;a[l]) &#123; t1 = a[l];a[l] = a[k];a[k] = t1; t2 = b[l];b[l] = b[k];b[k] = t2; &#125; &#125; &#125; for( i=0; i&lt;20; i++) &#123; printf("%d", a[i]); if(i&lt;19) printf(" "); &#125; printf("\n"); for(i=0; i&lt;20; i++) &#123; printf("%d", b[i]); if(i&lt;19) printf(" "); &#125; printf("\n"); return 0;&#125; 3.81234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768//代码写得很不规范，不过我懒得改了=。=#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;//改进版冒泡排序void bubbleSortPlus(int a[10]) &#123; int i,j,flag; for(i = 0;i &lt; 9; i++) &#123; flag = 1; for(j = 0;j &lt; 9-i; j++) &#123; if(a[j] &lt; a[j+1]) &#123; int tmp = a[j]; a[j] = a[j+1]; a[j+1] = tmp; flag = 0; &#125; &#125; if(flag == 1) break; &#125; for(i = 10;i &gt; 0; i--)&#123; printf("%d ",a[i]); &#125; putchar('\n');&#125;//快速排序void quikSort(int a[],int low,int high) &#123; int i = low; int j = high; int temp = a[i]; if( low &lt; high) &#123; while(i &lt; j) &#123; while((a[j] &gt;= temp) &amp;&amp; (i &lt; j)) &#123; j--; &#125; a[i] = a[j]; while((a[i] &lt;= temp) &amp;&amp; (i &lt; j)) &#123; i++; &#125; a[j]= a[i]; &#125; a[i] = temp; quikSort(a,low,i-1); quikSort(a,j+1,high); &#125; else &#123; return; &#125; for(i=0;i&lt;10;i++)&#123; printf("%d ",a[i]); &#125; putchar('\n');&#125;int main(void) &#123; int i = 0, a[10]; printf("Please enter 10 numbers:"); for (i = 0; i &lt; 10; i++) &#123; scanf("%d", &amp;a[i]); &#125; bubbleSortPlus(a);//调用冒泡 quikSort(a,0,4);//调用快速排序 return 0;&#125; 杭电（hdu）2085 核反应堆题Time Limit: 1000/1000 MS (Java/Others) Memory Limit: 32768/32768 K (Java/Others)Total Submission(s): 12219 Accepted Submission(s): 5547 Problem Description 某核反应堆有两类事件发生：高能质点碰击核子时，质点被吸收，放出3个高能质点和1个低能质点；低能质点碰击核子时，质点被吸收，放出2个高能质点和1个低能质点。假定开始的时候（0微秒）只有一个高能质点射入核反应堆，每一微秒引起一个事件发生(对于一个事件，当前存在的所有质点都会撞击核子)，试确定n微秒时高能质点和低能质点的数目。 Input 输入含有一些整数n(0≤n≤33)，以微秒为单位，若n为-1表示处理结束。 Output 分别输出n微秒时刻高能质点和低能质点的数量，高能质点与低能质点数量之间以逗号空格分隔。每个输出占一行。 Sample Input 125 2-1 Sample Output 12571, 20911, 4 简单分析分析题目得到，某秒的高能质点数是它的前一秒乘3再加上前一秒的低能质点数乘2。 所以不难写出 12345678910111213141516171819202122#include &lt;stdio.h&gt;struct nuclearReactor&#123; long long high,low;&#125;;int main(void)&#123; int i,n; struct nuclearReactor narr[35]; narr[0].high=1; narr[0].low=0; for(i=1; i&lt;=33; i++) &#123; narr[i].high=narr[i-1].high*3+narr[i-1].low*2; narr[i].low=narr[i-1].high+narr[i-1].low; &#125; while((void)(scanf("%d",&amp;n)!=EOF),n!=-1) &#123; printf("%lld, %lld\n",narr[n].high,narr[n].low); &#125; return 0;&#125; Experiment 6Advanced3.1没啥好说的，老师上课也讲了。 123456789101112131415161718192021222324252627282930313233343536373839404142434445#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;#define N 1024int main()&#123; char str[N]; int num[26][2]; int i,j,t; for (i =0 ; i&lt;26; i++) &#123; num[i][0] = 'a'+i; num[i][1] = 0; &#125; gets(str); for ( i = 0; i&lt;strlen(str); i++) &#123; if (str[i]&gt;='a' &amp;&amp; str[i]&lt;='z') &#123; num[str[i]-'a'][1]++; &#125; &#125; for ( i = 0; i&lt;26-1; i++) &#123; for ( j = 0; j&lt;26-1; j++) &#123; if (num[j][1]&lt;num[j+1][1]) &#123; t = num[j+1][1]; num[j+1][1] = num[j][1]; num[j][1] = t; &#125; &#125; &#125; for (i = 0; i&lt;26; i++) &#123; if (num[i][1]&gt;0) &#123; printf("%c\t%d\n",num[i][0],num[i][1]); &#125; &#125; return 0;&#125; 3.212345678910111213141516171819202122232425262728293031323334353637383940414243#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;int main()&#123; char str[3][81]; int upper = 0,lower = 0,digit = 0,space = 0,other = 0; int i,j; printf ("请输入三行字符：\n"); for (i=0;i&lt;3;i++) gets(str[i]); for (i=0;i&lt;3;i++) &#123; for (j=0;j&lt;strlen(str[i]);j++)//注意这里要用strlen来计算长度作为循环的标准 &#123; if (str[i][j]&gt;='A' &amp;&amp; str[i][j]&lt;='Z')&#123; upper++; &#125; else if (str[i][j]&gt;='a' &amp;&amp; str[i][j]&lt;='z')&#123; lower++; &#125; else if (str[i][j]&gt;='0' &amp;&amp; str[i][j]&lt;='9')&#123; digit++; &#125; else if ((str[i][j]=' '))&#123; space++; &#125; else&#123; other++; &#125; &#125; &#125; printf("大写字母：%d 个\n",upper); printf("小写字母：%d 个\n",lower); printf("数 字：%d 个\n",digit); printf("空 格：%d 个\n",space); printf("其 它：%d 个\n",other); return 0;&#125; 3.312345678910111213141516171819#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;int main()&#123; char str[1024]; gets(str); for (int i =0; i&lt;strlen(str);i++) &#123; if (str[i]==',') &#123; str[i]='\n';//直接检测到逗号就替换为换行，这是最简单办法 &#125; else ; &#125; puts(str); return 0;&#125; 3.412FIB WARRING:practice is missing，the police is searching..... &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;/// OOO ///警方突袭进行中/// OOO ///&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt; 我也不知哪里去了，或许3.4逃走了吧。。。 3.512345678910111213141516171819202122232425262728293031323334353637383940//貌似有点不美观，不过再次懒得改了- -！#include&lt;stdio.h&gt;#include&lt;string.h&gt;int main()&#123; int i,flag,top=0; unsigned long len;//编译器提示：Implicit conversion loses integer precision: 'unsigned long' to 'int'，说明推荐我们使用unsigned long，因为len可能会超出限制长度 char str1[1024],str2[1024];//st2存放的只有字母 gets(str1); len=strlen(str1); for(i=0;i&lt;len;i++)//用来判断字符，如果是字母就移动位置到前一个地方 &#123; if((str1[i]&gt;='a'&amp;&amp;str1[i]&lt;='z')||(str1[i]&gt;='A'&amp;&amp;str1[i]&lt;='Z')) str2[top++]=str1[i]; &#125; flag = 1; len = strlen(str2); for(i = 0; i &lt; len/2; i ++)//此时开始从两头往中间开始判断 &#123; if(str2[i] != str2[len - 1 -i]) &#123; flag = 0; break; &#125; &#125; if(flag)&#123; printf("Yes!\n"); &#125; else&#123; printf("No!\n"); &#125; return 0;&#125; Experiment 7ps：实验3.1和实验3.3实际是一样的，顺序有点乱（其实我懒得重新写了，逃 Advanced3.3程序中指定个数，再进行分配的办法12345678910111213141516171819202122232425262728#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;int main()&#123; int n,i,sum = 0; double avg; printf("先输入个数："); scanf("%d",&amp;n); int *in = (int *)malloc(sizeof(int) * n); printf("输入数："); for(i = 0;i &lt; n;i++) &#123; scanf("%d",in+i); &#125; for(i = 0;i &lt; n;i++) &#123; sum += *(in + i); &#125; avg = (double)sum / n printf("和为：%d，平均值为:%.2lf\n",sum,avg); &#125; for(i = 0;i &lt; n;i++) &#123; printf("%d 对应的差值是 %.2lf \n",in+i,avg-*(in+i); &#125; free(in); return 0;&#125; 但实际上，题目要求的是“键盘输入若干个整数”，而没有提到要预先输入个数，严格来说，这样是错误的，没有达到题目要求。 123456789101112131415161718192021222324252627282930313233//于是 ”一个惊叹号“ 同学在我的提醒下开始看书，查找方法解决这个问题，终于。。。#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;int main ()&#123; int *p = NULL; float ave; int sum = 0, count = 0;//count用来计数 int room = 5, temp;//保证第一次输入有空间 int i; p = (int*)malloc(room*sizeof(int));//分配第一次输入的内存 printf("输入整数 一个整数输入后按下回车进行下一次输入\n"); printf("输入-1，结束输入，开始运行程序\n"); for(i = 0; ; i++) &#123; scanf("%d",&amp;temp); if(temp == -1) break; p[count] = temp; sum+=p[count]; count++; if(count == room)//判断内存是否已满 room+=5;//待申请内存新的大小 p = realloc(p,room*sizeof(int));//realloc 拓展内存 &#125; ave = (float)sum/count; printf("平均数为%f\n",ave); for(i = 0; i&lt;count; i++)&#123; printf("第%d个数与平均数的差值为%f\n", i+1, p[i]-ave); &#125; free(p); return 0;&#125; 不过还有些小东西没有完善。。具体是什么，请看实验3.1 3.2常规操作1234567891011121314151617#include &lt;stdio.h&gt;#include &lt;ctype.h&gt;int main() &#123; char s[1024]; int i,j; printf("输入字符串:\n"); while(fgets(s,1024,stdin)) &#123; for(i = 0,j = 0;s[i];++i)&#123; if(isalpha(s[i]))&#123; s[j++] = s[i]; &#125; &#125; s[j] = '\0'; printf("%s\n",s); &#125; return 0;&#125; 只有常规操作，坐下 3.1好好体会（逃 12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;ctype.h&gt;#define ROOM 5int main()&#123; double *values = NULL; int capacity = 0; double *temp = NULL; double sum = 0.0; int count = 0; char answer = 'n'; do &#123; if(count == capacity) &#123; capacity += ROOM; temp = realloc(values, capacity*sizeof(double)); if(!temp) &#123; printf("Memory allocation failed.Bye"); exit(1); &#125; values = temp; temp = NULL; &#125; printf("Enter a value: "); scanf("%lf", values+count++); printf("Do you want to enter another(y/Y or n/N)? "); scanf(" %c", &amp;answer); &#125;while(tolower(answer) == 'y'); for(size_t i = 0 ; i &lt; count ; ++i) sum += *(values + i); printf("The average is %f.\n", sum/count); for(size_t i = 0 ; i &lt; count ; ++i)&#123; printf("%f -&gt; %f\n",(*(values + i)),((*(values + i))-(sum/count))); &#125; printf("\n"); free(values); return 0;&#125; Experiment 8考完四级，心态如下 答案只有函数，在一个文件里面 Basis123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150//就只写了函数/*2.1*/double carea(double r)&#123; return r*r*3.1415926;&#125;/*2.2*/int gcd(int numa, int numb)&#123; int i; for(i=numa;i&gt;=1;i--)&#123; if(numa%i==0&amp;&amp;numb%i==0) break; &#125; return i; &#125;/*2.3*/double distance(int x1, int y1, int x2, int y2)&#123; double resul; resul=sqrt((double)pow(x1-x2,2)+pow(y1-y2,2)); return resul;&#125;/*2.4*/double tempt(double temp,char ctype)&#123; if (islower(ctype)=='C') &#123; temp = (temp-32)/1.8; return temp; &#125; if (islower(ctype)=='F') &#123; temp = (32+temp)*1.8; return temp; &#125; else return 0;&#125;/*2.5*/int isOE(int number)&#123; if( (number%2)==0 )&#123; return -1; &#125; else return 1;&#125;/*2.6*/int answer()&#123; printf("答案是：2 3 \n 3 4"); return 0;&#125;/*2.7*/void sa(int x1,int x2,int *sum,int *mul)&#123; *sum=(x1+x2); *mul=(x1*x2);&#125;/*2.8*/void exchange(int *n1,int *n2)&#123; int x; x=*n1; *n1=*n2; *n2=x;&#125;/*2.9*/int isprime(int *data,int *primes,int len)&#123; int i,j,number=0; for (i = 0,j=0; i&lt;=len; i++) &#123; int t=1; for (j = 2;j&lt;i ; j++) &#123; if (*(data+i)%j==0) &#123; t=0; break; &#125; &#125; if (t==1) &#123; primes[j++]=*(data+i); number++; &#125; &#125; return number;&#125;/*2.10*/void MatrixSearch(double matrix[][], double *pMax, double *pMin, int n)&#123; *pMax=*pMin=matrix[0][0]; for(i=0;i&lt;(*matrix);i++)&#123; for(j=0;j&lt;(**matrix);j++)&#123; if(matrix[i][j]&gt;*pMax) *pMax=matrix[i][j]; if(matrix[i][j]&lt;*pMin) *pMin=matrix[i][j]; &#125; &#125;&#125;/*2.11*/void sort(int *arry,int len)&#123; int i,j; int flag = 1; for (i = 0; i &lt; len &amp;&amp; flag; i++) &#123; flag = 0; //只要flag在下一次外循环条件检测的时候值为0，就说明已经排好序，不用继续循环 for (j = len-1; j &gt; i; j--) &#123; if (array[j] &lt; array[j-1]) &#123; temp = array[j]; array[j] = array[j-1]; array[j-1] = temp; lag = 1; //如果有交换，就将标记变量赋1 &#125; &#125; &#125; for (i = 0; i &lt; len; i++) &#123; printf("%d\n", array[i]); &#125; return 0;&#125;/*2.12*/int search(char *list,char c,int len)&#123; int low=0,high=len-1,k; while (low=high) &#123; k=(low+high)/2; if (list[k]==c) &#123; high=k-1; &#125; else if(list[k]&gt;c) high=k-1; &#125; return -1;&#125;//importFucint main()&#123; return 0;&#125; Advanced123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156#include "stdio.h"#include "stdlib.h"#include &lt;stdbool.h&gt;#include "math.h"/*3.2*/int findmax(int n1,int n2,int n3)&#123; return ((((n1&gt;n2)?n1:n2)&gt;n3)?((n1&gt;n2)?n1:n2):n3);&#125;/*3.3*/double cvolume(double r,double h)&#123; return (3.1415926*r*r*h);&#125;/*3.4*/int lcm(int x1,int x2)&#123; int x, y, temp; if(x1 &lt; x2)&#123; temp = x1; x1 = x2; x2 = temp; &#125; x = x1; y = x2; while(y != 0)&#123; temp = x%y; x = y; y = temp; &#125; return x1*x2/x; //return x1;//the max&#125;/*3.5*/long fact(int n)&#123; if (n&gt;0) &#123; return n*fact(n-1); &#125; else if (n==0) return 1; else return 0;&#125;/*3.6*/double power(double n,int p)&#123; return pow(n,p);&#125;/*3.7*/int cday(int year,int month,int day)&#123; int i, num,d[12]; d[0] = 31; d[1] = 28; d[2] = 31; d[3] = 30; d[4] = 31; d[5] = 30; d[6] = 31; d[7] = 31; d[8] = 30; d[9] = 31; d[10] = 30; d[11] = 31; num = 0; if (year % 4 == 0)&#123; d[1] = 29; &#125; for (i = 0; i &lt; month - 1; i++)&#123; num += d[i]; &#125; num += day; printf("是%d年第%d天",year,num); return 0;&#125;/*3.8*/void data(int num,int *month,int *day,int *year)&#123; /*int main()&#123; int num=20170412,m=0,d=0,y=0; int *month=&amp;m; int *day=&amp;d; int *year=&amp;y; data(num, month, day, year); return 0; &#125;*/ *day = num % 100; num /= 100; *month = num % 100; *year = num / 100; printf("%4d-%02d-%02d\n",*year,*month,*day);&#125;/*3.9*/long fun(int k)&#123; if (k&gt;0) &#123; return k*fun(k-1); &#125; else if (k==0)&#123; return 1; &#125; else return 0;&#125;/*3.10*/int fibonacci(int n)&#123; if (n &lt;= 2)&#123; return 1 ; &#125; else&#123; return fibonacci(n-1) + fibonacci(n-2) ; &#125;&#125;/*3.11*/void hanoi(int n, char x, char y, char z)&#123; if(n == 1) printf("%d. %c -&gt; %c\n",n,x,z); else &#123; hanoi(n-1,x,y,z); printf("%d. %c -&gt; %c\n",n,x,z); hanoi(n-1,y,x,z); &#125; &#125;/*int main()&#123; //A,B,C分别代表三个柱子 char ch1 = 'A'; char ch2 = 'B'; char ch3 = 'C'; int n; //n代表圆盘的个数 printf("请输入圆盘的个数："); scanf("%d",&amp;n); move(n,ch1,ch2,ch3); return 0; */ int main()&#123; return 0;&#125; 话说，最近好累啊，马上实验室招新活动= = Experiment 9今天算是见识到了某人的恶心之处 Basis以后基本上都只会放源码了，因为我想把这个博客做得更具有偏向性，可能以后会全部单独在一篇文章中更新 甚至未来有可能会删除作业内容 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;#include &lt;ctype.h&gt;/*2.1*/void maxmin(int *data, int *max, int *min, int len)&#123; int i; *max=data[0]; *min=data[0]; for(i=0;i&lt;len;i++) &#123; if(data[i]&gt;*max) *max=data[i]; if(data[i]&lt;*min) *min=data[i]; &#125;&#125;/*2.2*/int count(char* string)&#123; int i; int c=0; for(i=0;string[i]!=0;i++) if((string[i]&gt;='a'&amp;&amp;string[i]&lt;='z')||(string[i]&gt;='A'&amp;&amp;string[i]&lt;='Z')) c++; return c;&#125;/*2.3*/int del(int *data,int n,int en)&#123; int i,j; int m=0; for(i=0;i&lt;en;i++) if(data[i]==n) &#123; for (j=i; j&lt;en-i; j++) &#123; data[j]=data[j+1]; &#125; m++; &#125; return en-m;&#125;/*2.4*/int search(int *data, int n, int len)&#123; int i; for(i=0;i&lt;len;i++) &#123; if(n==data[i]) return i; &#125; return -1;&#125;/*2.5*/void delch1(char* string)&#123; int i,j; char ch; fflush(stdin); printf("输入要删除的字符"); scanf("%c",&amp;ch); fflush(stdin); for(i=0;i&lt;strlen(string);i++) &#123; if(string[i]==ch) &#123; j=i; break; &#125; &#125; for(i=j;i&lt;strlen(string)-1;i++) string[i]=string[i+1]; string[strlen(string)-1]=0;&#125;/*2.6*/int searchch(char* string, char ch)&#123; int i; for (i = 0; string[i]; i++) &#123; if (string[i] == ch) return i; &#125; return -1;&#125;/*2.7*/void reverse(int *data, int len)&#123; int i; int a; for(i=0;i&lt;len/2;i++) &#123; a=data[i]; data[i]=data[len-i-1]; data[len-i-1]=a; &#125;&#125;/*2.8*/int changeS(char *string)&#123; unsigned int i; int j=0; int num=0; int a[1024]; for(i=0;string[i];i++) if(string[i]&gt;='0'&amp;&amp;string[i]&lt;='9') a[j++]=string[i]-48; if(string[0]=='-') &#123; for(i=0;i&lt;strlen(string)-1;i++) num+=a[i]*(int)pow(10,strlen(string)-i-2); num=num*-1; &#125; else &#123; for(i=0;i&lt;strlen(string);i++) num+=a[i]*(int)pow(10,strlen(string)-i-1); &#125; return num; &#125;/*2.9*/void swap(int *data,int len)&#123; int n; int i; int j=0,k=0; for(i=0;i&lt;len;i++) &#123; if(data[k]&gt;data[i]) k=i; if(data[j]&lt;data[i]) j=i; &#125; n=data[0]; data[0]=data[k]; data[k]=n; n=data[len-1]; data[len-1]=data[j]; data[j]=n; &#125;/*2.10*//*#include &lt;stdio.h&gt; #include &lt;string.h&gt; #include &lt;stdlib.h&gt; #define N 10 void strsort(char* s[],int n) &#123; int i,j,k; char* temp=NULL; for(i=0;i&lt;n-1;i++) &#123; k=i; for(j=i+1;j&lt;n;j++) if(strcmp(s[j],s[k])&lt;0) k=j; if(k!=i) &#123; temp=s[i]; s[i]=s[k]; s[k]=temp; &#125; &#125; &#125; void main() &#123; char *s[N],**p=NULL; int i; for(i=0; i&lt;N; i++) &#123; s[i]=(char*)malloc(sizeof(char)*20); gets(s[i]); &#125; strsort(s,N); p=s; for(i=0; i&lt;N; i++) &#123; printf("%s\n",*p++); free(s[i]); &#125; &#125;*//*2.11*/char *strin(char* s1,char* s2)&#123; int i,j; int k; for(i=0;s1[i];i++) &#123; j=1; if(s2[0]==s1[i]) &#123; for(k=0;s2[k];k++) if(s2[k]!=s1[i+k]) j=0; if(j!=0) return &amp;s1[i]; &#125; &#125; return 0;&#125;/*2.12*/void change(char *string)&#123; int i; for(i=0;string[i];i++) string[i]=isupper(string[i]);&#125;/*2.13*/int stringlen(char* string)&#123; int i; for(i=0;string[i];i++); return i; &#125;int main()&#123; return 0;&#125; 提醒大家一句，老师只是一个职业 Advanced123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480//Xcode自动添加的时候就是双引号，懒得改，反正都一样#include "stdio.h"#include "stdlib.h"#include "string.h"#include "ctype.h"/*3.1*/void stringcpy(char *to, char *from)&#123; while((*(to++)=*(from++))!=0);&#125;/*3.2*/void merge(int *a,int n,int *b,int m,int *c)&#123; int i,j; for(i=j=0; i&lt;n&amp;&amp;j&lt;m; ) *c++=a[i]&lt;b[j]?a[i++]:b[j++]; while(i&lt;n) *c++=a[i++]; while(j&lt;m) *c++=b[j++]; &#125;/*3.3*/void mstrcpy(char *src,char *des,int m)&#123; int i,j; for(i=0, j=m; src[j-1]; i++, j++) des[i]=src[j];&#125;/*3.4（1）*/int FindMax1(int (*data)[4])&#123; int i,j; int m=0,n=0; for(i=0;i&lt;3;i++) for(j=0;j&lt;4-1;j++) if(*(*(data+m)+n)&lt;*(*(data+i)+j)) &#123; n=j; m=i; &#125; return data[m][n];&#125;/*3.4（2）*/int FindMax2(int *data)&#123; int i; int n=0; for(i=0;i&lt;12;i++) if(*(data+n)&lt;*(data+i)) n=i; return data[n];&#125;/*3.5*/void minvert(int (*maxtrix)[5])&#123; int i,j; int t; for(i=0;i&lt;5;i++) for(j=i;j&lt;5;j++) &#123; t=maxtrix[i][j]; maxtrix[i][j]=maxtrix[j][i]; maxtrix[j][i]=t; &#125;&#125;/*3.6*/void dresort(int *data, int len)&#123; int i,j=0,k=0; int m[4]; int n[5]; for(i=0;i&lt;len-1;i+=2) &#123; n[j++]=data[i]; m[k++]=data[i+1]; &#125; if(len%2==1) &#123; n[j]=data[len-1]; for(i=0;i&lt;len/2;i++) &#123; data[i]=n[i]; data[len/2+i+1]=m[i]; &#125; data[len/2]=n[len/2]; &#125; else &#123; for(i=0;i&lt;len/2;i++) &#123; data[i]=n[i]; data[len/2+i]=m[i]; &#125; &#125;&#125;/*3.7*/void change(int (*m)[5])&#123; int t; int a=0,b=0; int i,j; for(i=0;i&lt;5;i++) for(j=0;j&lt;5;j++) if(m[a][b]&gt;m[i][j]) &#123; a=i; b=j; &#125; if(a!=0||b!=0) &#123; t=m[a][b]; m[a][b]=m[0][0]; m[0][0]=t; &#125; a=0,b=4; for(i=0;i&lt;5;i++) for(j=0;j&lt;5;j++) if(m[a][b]&gt;m[i][j]&amp;&amp;(i!=0||j!=0)) &#123; a=i; b=j; &#125; if(a!=0||b!=4) &#123; t=m[a][b]; m[a][b]=m[0][4]; m[0][4]=t; &#125; a=4,b=0; for(i=0;i&lt;5;i++) for(j=0;j&lt;5;j++) if(m[a][b]&gt;m[i][j]&amp;&amp;(i!=0||j!=0)&amp;&amp;(i!=0||j!=4)) &#123; a=i; b=j; &#125; if(a!=4||b!=0) &#123; t=m[a][b]; m[a][b]=m[4][0]; m[4][0]=t; &#125; a=4,b=4; for(i=0;i&lt;5;i++) for(j=0;j&lt;5;j++) if(m[a][b]&gt;m[i][j]&amp;&amp;(i!=0||j!=0)&amp;&amp;(i!=0||j!=4)&amp;&amp;(i!=4||j!=0)) &#123; a=i; b=j; &#125; if(a!=0||b!=0) &#123; t=m[a][b]; m[a][b]=m[4][4]; m[4][4]=t; &#125; a=2,b=2; for(i=0;i&lt;5;i++) for(j=0;j&lt;5;j++) if(m[a][b]&lt;m[i][j]) &#123; a=i; b=j; &#125; if(a!=0||b!=0) &#123; t=m[a][b]; m[a][b]=m[2][2]; m[2][2]=t; &#125; &#125;/*3.8(1)*/void stuave(float (*score)[5],float ave[10],int n)&#123; int i,j; float sum=0.0; for(i=0;i&lt;n;i++) &#123; sum=0; for(j=0;j&lt;5;j++) sum+=score[i][j]; ave[i]=sum/5; &#125;&#125;/*3.8(2)*/void mscore(float(*score)[5],int *s, int *c)&#123; int i,j; float m=score[0][0]; for(i=0;i&lt;5;i++) for(j=0;j&lt;5;j++) if(m&lt;score[i][j]) &#123; m=score[i][j]; *s=i; *c=j; &#125;&#125;/*3.9*/void sorts(char *(string[1024]),int n)&#123; int i,j; char *t; for(i=0;i&lt;n-1;i++) for(j=0;j&lt;n-1-i;j++) if(strcmp(string[j],string[j+1])&gt;0) &#123; t=string[j]; string[j]=string[j+1]; string[j+1]=t; &#125;&#125;/*3.10*/int fnums(char *str, int *num)&#123; int i,m; int j=0; int k=0; char n[10]=&#123;0&#125;; for(i=0;i&lt;30;i++) num[i]=0; for(i=0;str[i];i++) &#123; for(k=0;str[i]&gt;='0'&amp;&amp;str[i]&lt;='9';i++,k++) &#123; n[k]=str[i]; &#125; if(k!=0) &#123; for(m=k-1;m&gt;=0;m--) num[j]+=(n[m]-'0')*(int)pow(10,k-1-m); j++; &#125; for(;k&gt;=0;k--) n[k]=0; &#125; return j;&#125;/*3.11*/int scmp(char *p1,char *p2)&#123; int i; for(i=0;p1[i]&amp;&amp;p2[i];i++) if(p1[i]-p2[i]!=0) return p1[i]-p2[i]; if(strlen(p1)&gt;strlen(p2)) return p1[i]; else return p2[i]; return 0;&#125;/*3.12*//*#include &lt;stdio.h&gt;char* pMonth[12]=&#123;&#123;"January"&#125;,&#123;"February"&#125;,&#123;"March"&#125;,&#123;"April"&#125;,&#123;"May"&#125;,&#123;"Jule"&#125;,&#123;"July"&#125;,&#123;"August"&#125;,&#123;"September"&#125;,&#123;"October"&#125;,&#123;"November"&#125;,&#123;"December"&#125;&#125;;int main()&#123; while(1) &#123; int nMonth; scanf("%d",&amp;nMonth); if(nMonth&gt;12||nMonth&lt;1) &#123; printf("not found"); break; &#125; printf("\t%s\n",pMonth[nMonth-1]); &#125;&#125;*//*3.13*/void josephu(int *people)&#123; int n=0; int j=0; int m=0; for(;;j++) &#123; if(j&gt;29) j=0; if(people[j]!=0) m++; else continue; if(m==9) &#123; people[j]=0; m=0; n++; &#125; if(n&gt;=15) break; &#125;&#125;/*3.14*/int fact(int x,int *f)&#123; int i; int n=0; for(i=2;i&lt;x;i++) &#123; if(i%2==0) if(x%i==0) f[n++]=i; &#125; f[n]=0; return n;&#125;/*3.15*/void zprocess(int *data,int len)&#123; int i,j; int t; for(i=0;i&lt;len;i++) if(data[i]==0) for(j=i;j&lt;len-1;j++) &#123; t=data[j]; data[j]=data[j+1]; data[j+1]=t; &#125;&#125;/*3.16*/int fwords(char *string,char (*words)[1024])&#123; int i,j; int count=0; for(i=0;string[i];i++) if(string[i]&gt;='a'&amp;&amp;string[i]&lt;='z'||string[i]&gt;='A'&amp;&amp;string[i]&lt;='Z') &#123; for(j=0;string[i]&gt;='a'&amp;&amp;string[i]&lt;='z'||string[i]&gt;='A'&amp;&amp;string[i]&lt;='Z';i++,j++) words[count][j]=string[i]; words[count][j]=0; count++; &#125; return count;&#125;/*3.17*/void stringcat(char *str1,char *str2)&#123; int i; int n; for(n=0;str1[n];n++); for(i=0;str2[i];i++) str1[n-1+i]=str2[i]; str1[n-1+i]=0;&#125;/*3.18*/void stringvert(char *str)&#123; int i,j; char t; for(i=0;str[i];i++); for(j=0;j&lt;i/2;j++) &#123; t=str[j]; str[j]=str[i-1-j]; str[i-j-1]=t; &#125; str[i]=0; &#125;/*3.19*/void svowel(char *s1,char *s2)&#123; int i,j=0; for(i=0;s1[i];i++) if(s1[i]=='a'||s1[i]=='e'||s1[i]=='i'||s1[i]=='o'||s1[i]=='u') s2[j++]=s1[i]; s2[j]=0;&#125;/*3.20*/void strsta(char* string,int* num)&#123; int i; for(i=0;string[i];i++) &#123; if((string[i]&gt;='a'&amp;&amp;string[i]&lt;='z')||string[i]&gt;='A'&amp;&amp;string[i]&lt;='Z') num[0]++; else if(string[i]&gt;='0'&amp;&amp;string[i]&lt;='9') num[1]++; else if(string[i]==' ') num[2]++; else num[3]++; &#125;&#125;/*3.21*/void wpos(char *string, int *begin, int *end)&#123; int i,j; int m=0; for(i=0;string[i];i++) &#123; for(j=0;string[i]&gt;='a'&amp;&amp;string[i]&lt;='z'||string[i]&gt;='A'&amp;&amp;string[i]&lt;='Z';j++,i++); if(j&gt;m) &#123; m=j; *begin=i-j; *end=i-1; &#125; &#125;&#125;/*3.22*/void sortno(char (*stuno)[11],int n)&#123; int i,j; char num[11]; for(i=0;i&lt;n-1;i++) for(j=0;j&lt;n-1-i;j++) if(strcmp(stuno[j],stuno[j+1])&gt;0) &#123; strcpy(num,stuno[j]); strcpy(stuno[j],stuno[j+1]); strcpy(stuno[j+1],num); &#125;&#125;/*3.23*/int searchno(char (*stuno)[11],char *no,int n)&#123; int i,j; int m; for(i=0;i&lt;n;i++) &#123; m=0; for(j=0;j&lt;11;j++) if(stuno[i][j]!=no[j]) &#123; m=1; break; &#125; if(m==0) return i; &#125; return -1;&#125;int main()&#123; return 0;&#125; Experiment 10这可能是最近最简单的作业如对结构体抱有疑问，请看往期介绍（逃 随便挑几个溜了 Basis2.112345678910111213141516171819#include &lt;stdio.h&gt;struct people&#123; char name[10]; int age; int money;&#125;;int main(void)&#123; int i; struct people per[3]=&#123; &#123;"李明",25,2500&#125;, &#123;"王利",22,2300&#125;, &#123;"赵勇",30,3000&#125; &#125;; printf("姓名 年龄 月薪\n"); for(i=0;i&lt;3;i++)&#123; printf(" %s %d %d\n",per[i].name,per[i].age,per[i].money); &#125; return 0;&#125; 2.4123456789101112#include &lt;stdio.h&gt;typedef struct tada&#123; int year; int month; int day;&#125;;int main(void)&#123; struct tada a; printf("输入年、月、日："); scanf("%d%d%d",&amp;a.year,&amp;a.month,&amp;a.day); printf(" %d年 %d月 %d日\n",a.year,a.month,a.day);&#125; Advanced3.112345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758#include &lt;stdio.h&gt;struct studentInformationOne&#123; char studentID[11]; int credit; int score; float average;&#125;;struct studentInformationTwo&#123; char name[10]; char data[15]; int credit; int score; float average;&#125;;struct list&#123; char name[10]; char address[100];&#125;;struct stock&#123; char name[10]; int value; char data[15];&#125;;struct inventory&#123; char number[10]; char name[10]; int itemIn; int theID;&#125;;int main()&#123; struct studentInformationOne a; struct studentInformationTwo b; struct list c; struct stock d; struct inventory e; printf("输入学生学号、完成的学分、累积成绩分数、平均值组。"); scanf("%s%d%d%f",a.studentID,&amp;a.credit,&amp;a.score,&amp;a.average); printf("输入学生姓名、出生日期、完成的学分数、累积成绩分数、平均值。"); scanf("%s%s%d%d%f",b.name,b.data,&amp;b.credit,&amp;b.score,&amp;b.average); printf("输入人名、地址。"); scanf("%s%s",c.name,c.address); printf("输入股票名称、股票价格、购买日期"); scanf("%s%d%s",d.name,&amp;d.value,d.data); printf("输入零件号码、零件名称、库存量、记录员编号"); scanf("%s%s%d%d",e.number,e.name,&amp;e.itemIn,&amp;e.theID); printf("学生学号%s 完成的学分%d 累积成绩分数%d 平均值组%f。\n",a.studentID,a.credit,a.score,a.average); printf("学生姓名%s 出生日期%s 完成的学分数%d 累积成绩分数%d 平均值%f.\n",b.name,b.data,b.credit,b.score,b.average); printf("人名%s 地址%s。\n",c.name,c.address); printf("输入股票名称%s 股票价格%d 购买日期%s.\n",d.name,d.value,d.data); printf("输入零件号码%s 零件名称%s 库存量%d 记录员编号%d.\n",e.number,e.name,e.itemIn,e.theID); return 0;&#125; 3.21234567891011121314151617#include &lt;stdio.h&gt;struct data&#123; int house; int fen;&#125;;int main(void)&#123; struct data a; scanf("%d %d",&amp;a.house,&amp;a.fen); if(a.fen==59)&#123; if(a.house==12)&#123; printf("1 00"); &#125; else &#123; printf("%d 00",a.house+1); &#125; &#125; else printf("%d %d",a.house,a.fen+1);&#125; 3.10123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110#include &lt;stdio.h&gt;struct Data&#123; int year; int month; int day;&#125;;typedef struct Data DATA;DATA larger(DATA d1,DATA d2);int days(DATA data);int main(void)&#123; DATA m; DATA data1,data2; scanf("%d%d%d",&amp;data1.year,&amp;data1.month,&amp;data1.day); scanf("%d%d%d",&amp;data2.year,&amp;data2.month,&amp;data2.day); m=larger(data1,data2); printf("%d %d %d \n",m.year,m.month,m.day);&#125;DATA larger(DATA d1,DATA d2)&#123; if(days(d1)-days(d2)&gt;0) return d1; else return d2;&#125;int days(DATA data)&#123; int m; if(data.year%4==0)&#123; m=(data.year-1900)/4*1461; switch (data.month)&#123; case 1: m+=0; break; case 2: m+=31; break; case 3: m+=60; break; case 4: m+=91; break; case 5: m+=121; break; case 6: m+=152; break; case 7: m+=182; break; case 8: m+=213; break; case 9: m+=244; break; case 10: m+=274; break; case 11: m+=305; break; default : m+=335; &#125; return (m+data.day); &#125; else&#123; m=(data.year-1900)/4*1461+(data.year-1900)%4*365; switch (data.month)&#123; case 1: m+=0; break; case 2: m+=31; break; case 3: m+=61; break; case 4: m+=92; break; case 5: m+=122; break; case 6: m+=153; break; case 7: m+=183; break; case 8: m+=214; break; case 9: m+=245; break; case 10: m+=275; break; case 11: m+=306; break; default : m+=336; &#125; return (m+data.day); &#125;&#125; Experiment 11文件总是问题最多的是不是觉得每次都要手动排序很麻烦？qsort()函数可以帮你解决这个问题～ qsort()标准库函数的使用qsort函数包含在&lt;stdlib.h&gt;中 qsort函数声明如下： void qsort(void * base,size_t nmemb,size_t size ,int(*compar)(const void *,const void *)); 参数说明： base,要排序的数组 nmemb,数组中元素的数目 size,每个数组元素占用的内存空间，可使用sizeof函数获得 compar,指向函数的指针也即函数指针。这个函数用来比较两个数组元素，第一个参数大于，等于，小于第二个参数时，分别显示正值，零，负值。 下面看几个例子： 123456789101112131415161718192021222324252627282930313233343536#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;math.h&gt;#include &lt;string.h&gt;int main(void)&#123; int i; int a[10]=&#123;0,1,2,3,4,5,6,7,8,9&#125;; char b[10]=&#123;'a','b','c','d','e','f','g','h','i','j'&#125;; double c[10]=&#123;0.1,0.2,0.9,0.5,0.3,0.6,0.7,0.8,1.1,1.2&#125;; int cmp1(const void * a,const void * b)&#123; return (*(int*)a-*(int*)b);//a&gt;b 返回正值 &#125; int cmp2(const void * a,const void *b)&#123; return(*(char*)a-*(char*)b); &#125; int cmp3(const void * a,const void * b)&#123; if(fabs(*(double*)a-*(double *)b)&lt;1*exp(-20)) return 0; else return(((*(double*)a-*(double*)b)&gt;0)?1:-1); &#125; qsort(a,10,sizeof(int),&amp;cmp1);//对于函数指针（指向函数的指针），直接传入函数名和函数名进行&amp; //运算都是可以的，因为在调用函数时也是取的函数的地址 qsort(b,10,sizeof(char),cmp2); qsort(c,10,sizeof(double),cmp3); for(i=0;i&lt;10;i++) printf("%d ",a[i]); for(i=0;i&lt;10;i++) printf("%c ",b[i]); for(i=0;i&lt;10;i++) printf("%lf ",c[i]); return 0;&#125; Basis2.312345678910111213141516171819202122232425262728#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;int main(void)&#123; FILE *fp; char str[100]; int i = 0; if ((fp = fopen("test.dat", "wb")) == NULL) &#123; printf("Can not open the file\n"); return 1; &#125; printf("Input a string:\n"); gets(str); while (str[i] != '!') &#123; if (str[i] &gt;= 'a' &amp;&amp; str[i] &lt;= 'z') &#123; str[i] = str[i]-32; &#125; fputc(str[i], fp); i++; &#125; fclose(fp); fp = fopen("test.dat", "rb"); fgets(str, (int)(strlen(str)+1), fp); printf("%s\n",str); fclose(fp); return 0;&#125; 2.5使用qsort（）函数1234567891011121314151617181920212223242526272829#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;time.h&gt;int cmp1(const void * a,const void * b);int main(void)&#123; FILE *fp=fopen("rand.txt","w"); /*要写入的文件*/ FILE *fp2=NULL ; int i; int a[10000]; srand((unsigned int)time(NULL)); /*不可放在循环内，否则每次得到相同的“随机数”*/ for (i = 0; i&lt;10000; i++) &#123; a[i]=rand(); fprintf(fp,"%d ",a[i]); &#125; fclose(fp); qsort(a, 10000, sizeof(int), &amp;cmp1);/*排序函数，调用qsort()标准库函数进行排序*/ fp2=fopen("sort_rand.txt","w"); /*排序之后要写入的文件*/ for (i = 0; i&lt;10000; i++) &#123; fprintf(fp,"%d ",a[i]); &#125; fclose(fp2); return 0;&#125;int cmp1(const void * a,const void * b) &#123; return (*(int*)a-*(int*)b);//a&gt;b 返回正值&#125; Advanced3.61234567891011121314151617181920212223242526272829303132#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;struct information &#123; char a[15]; char b[10]; int c; double d; char e[10];&#125;;int main(void) &#123; struct information inf[5]; int i; FILE *fp; for (i = 0; i &lt; 5; i++) &#123; scanf("%s%s%d%lf%s", inf[5].a, inf[5].b, &amp;inf[5].c, &amp;inf[5].d, inf[5].e); &#125; fp = fopen("emloy.txt", "wb"); for (i = 0; i &lt; 5; i++) &#123; fwrite(&amp;inf[i], sizeof(struct information), 1, fp); &#125; fclose(fp); fp = fopen("emloy.txt", "rb"); for (i = 0; i &lt; 5; i++) &#123; fread(&amp;inf[i], sizeof(struct information), 1, fp); printf("%s\t%s\t%d\t%.2lf\t%s\n",inf[5].a,inf[5].b,inf[5].c,inf[5].d,inf[5].e); &#125; fclose(fp); return 0;&#125; 3.71234567891011121314151617181920212223242526#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;int main(void) &#123; FILE *fp; char ch1,ch2; fp = fopen("test", "r"); if (fp == NULL) &#123; printf("open file failed !\n"); return 1; &#125; ch1 = ch2 = 49; //ascii码 while (ch1 != EOF) &#123; if (ch1 == '\n')&#123; ch2++; putchar(ch1); putchar(ch2); ch1 = fgetc(fp); &#125; else &#123; putchar(ch1); ch1 = fgetc(fp); &#125; &#125; putchar('\n'); return 0;&#125; 3.91234567891011121314151617181920212223242526272829303132333435#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;int main(void) &#123; int a[18] = &#123;5,96,87,78,93,21,4,92,82,85,87,6,72,69,85,75,81,73&#125;; FILE *fp; int i,avg = 0,j,temp; fp = fopen("dat", "wb"); fwrite(a, sizeof(a), 1, fp); fclose(fp); fp = fopen("dat", "rb"); fread(&amp;j, sizeof(int), 1, fp); for (i = 0; i &lt; j; i++) &#123; fread(&amp;temp, sizeof(int), 1, fp); avg += temp; &#125; printf("%d\n",avg/j); fread(&amp;j, sizeof(int), 1, fp); avg = 0; for (i = 0; i &lt; j; i++) &#123; fread(&amp;temp, sizeof(int), 1, fp); avg += temp; &#125; printf("%d\n",avg/j); avg = 0; fread(&amp;j, sizeof(int), 1, fp); for (i = 0; i &lt; j; i++) &#123; fread(&amp;temp, sizeof(int), 1, fp); avg += temp; &#125; printf("%d\n",avg/j); fclose(fp); return 0;&#125; 3.10123456789101112131415#include &lt;stdio.h&gt;int main(void)&#123; char a; FILE *fp; if((fp=fopen("text.txt","r"))==NULL)&#123; printf("open failed"); return 1; &#125; while((a=fgetc(fp))!=EOF)&#123; printf("%c",a); fseek(fp,1,1);//偏移一位 &#125; fclose(fp); return 0;&#125; 3.131234567891011121314151617181920212223242526272829303132#include &lt;stdio.h&gt;int main(void)&#123; float sum; int i,j; FILE *fp; float a; if((fp=fopen("grades.bin","wb"))==NULL)&#123; printf("open failed"); return 1; &#125; for(i=0;i&lt;5;i++)&#123; for(j=0;j&lt;4;j++)&#123; scanf("%f",&amp;a); fwrite(&amp;a,sizeof(float),1,fp); &#125; &#125; fclose(fp); if((fp=fopen("grades.bin","rb"))==NULL)&#123; printf("¥Úø™ ß∞‹"); return 2; &#125; for(i=0;i&lt;5;i++)&#123; sum=0; for(j=0;j&lt;4;j++)&#123; fread(&amp;a,sizeof(float),1,fp); sum+=a; &#125; printf("%.2f\t",sum/4); &#125; fclose(fp); return 0;&#125; 怎样提高效率才是我们最应该想的事情，不要舍本逐末 Experiment 12Basis2.11234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#include &lt;stdio.h&gt;#include &lt;termios.h&gt;#include &lt;unistd.h&gt;#include &lt;stdlib.h&gt;#include &lt;time.h&gt;#include &lt;stdbool.h&gt;#include &lt;errno.h&gt;int min=0;int choose[5] = &#123;0&#125;;int clocks[3][3] = &#123;&#123;10,9,6&#125;,&#123;9,12,5&#125;,&#123;14,10,8&#125;&#125;;int main(void)&#123; int i,j,k,l,m; int c = 0; for(i = 0;i &lt; 3; i++)&#123; c = 0; for(j = 0;j &lt; 3; j++)&#123; c += clocks[i][j]; for(k = 0;k &lt; 3; k++)&#123; c += clocks[j][k]; for(l = 0;l &lt; 3; l++)&#123; c += clocks[k][l]; for(m = 0;m &lt; 3; m++)&#123; c += clocks[l][m]; if(i == 0)&#123; choose[0] = i; choose[1] = j; choose[2] = k; choose[3] = l; choose[4] = m; min = c; &#125; else if (min &gt; c) &#123; min = c; choose[0] = i; choose[1] = j; choose[2] = k; choose[3] = l; choose[4] = m; &#125; c -= clocks[l][m]; &#125; c -= clocks[k][l]; &#125; c -= clocks[j][k]; &#125; c -= clocks[i][j]; &#125; &#125; for(i = 0;i &lt; 5; i++)&#123; printf("%d ",choose[i]+1); &#125; putchar('\n'); printf("%d\n",min); return 0;&#125; Advanced3.1(Unix/Linux)1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162#include &lt;stdio.h&gt;#include &lt;termios.h&gt;#include &lt;unistd.h&gt;#include &lt;stdlib.h&gt;#include &lt;stdbool.h&gt;#include &lt;errno.h&gt;#define ECHOFLAGS (ECHO | ECHOE | ECHOK | ECHONL)int set_disp_mode(int fd,int option)&#123; int err; struct termios term; if(tcgetattr(fd,&amp;term)==-1)&#123; perror("Cannot get the attribution of the terminal"); return 1; &#125; if(option) term.c_lflag|=ECHOFLAGS; else term.c_lflag &amp;=~ECHOFLAGS; err=tcsetattr(fd,TCSAFLUSH,&amp;term); if(err==-1 &amp;&amp; err==EINTR)&#123; perror("Cannot set the attribution of the terminal"); return 1; &#125; return 0;&#125;int getpasswd(char* passwd, int size)&#123; int c; int n = 0; printf("Please Input password:"); do&#123; c=getchar(); if (c != '\n'|c!='\r')&#123; passwd[n++] = c; &#125; &#125; while (c != '\n' &amp;&amp; c !='\r' &amp;&amp; n &lt; (size - 1)); passwd[n] = '\0'; return n;&#125;int main(void)&#123; char *p,passwd[20],corectPass[20] = &#123;"nothingissafe"&#125;; int n = 3; set_disp_mode(STDIN_FILENO,0); while (n--) &#123; getpasswd(passwd, sizeof(passwd)); p=passwd; while(*p!='\n') &#123; p++; &#125; *p='\0'; if (strcmp(passwd,corectPass) == 0) &#123; printf("Welcome!\n"); break; &#125; printf("Wrong Password!\n"); &#125; set_disp_mode(STDIN_FILENO,1); return 0;&#125; 3.21234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#include &lt;stdio.h&gt;#include &lt;termios.h&gt;#include &lt;unistd.h&gt;#include &lt;stdlib.h&gt;#include &lt;time.h&gt;#include &lt;stdbool.h&gt;#include &lt;errno.h&gt;int randNumber(void);int main(void) &#123; srand((unsigned)time(NULL)); int a[10000],count = 0; FILE *fp1,*fp2 = NULL; if ((fp1 = fopen("data.txt", "w+")) == NULL) &#123; printf("Can't open file:%s\n", "data.txt"); exit(0); &#125; for (int i = 0; i&lt;10000; i++) &#123; a[i] = randNumber(); fprintf(fp1,"%d ",a[i]); &#125; fclose(fp1); for (int i = 0; i &lt; 10000; i++) &#123; int unitPlace = (a[i]/1)%10; int thousandPlace = (a[i]/1000)%10; if (unitPlace == thousandPlace) &#123; count++; &#125; if (a[i]%2 == 0) &#123; a[i] = a[i]*10; &#125; &#125; fp2=fopen("data.txt","w+"); for (int i = 0; i &lt; 10000; i++) &#123; fprintf(fp1,"%d ",a[i]); &#125; fclose(fp2); printf("The number of unitPlace equls to unitPlace:%d\n",count); return 0;&#125;int randNumber() &#123; return rand()%9000 + 1000;&#125; 3.5123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129#include &lt;stdio.h&gt;#include &lt;termios.h&gt;#include &lt;unistd.h&gt;#include &lt;stdlib.h&gt;#include &lt;time.h&gt;#include &lt;stdbool.h&gt;#include &lt;errno.h&gt;typedef struct TeleType&#123; char data[30]; struct TeleType *next;&#125; NODE;NODE *createList(void);//1void prn(NODE *head);//2NODE *first_insert(NODE *head);//3NODE *reverse_copy(NODE *head);//4void free_link(NODE *head);//5void countstr(NODE* head);//6int main(void) &#123; NODE *head = NULL; NODE *head1 = NULL; printf("put '0' to end\n"); head = createList(); prn(head); first_insert(head); prn(head); reverse_copy(head); prn(head1); free_link(head); return 0;&#125;NODE *createList()&#123; NODE *head = NULL,*p, *p1 = NULL; p = (NODE*)malloc(sizeof(NODE)); p-&gt;next = NULL; head = p; p1 = head; while(true)&#123; p = (NODE*)malloc(sizeof(NODE)); scanf("%s", p-&gt;data); p-&gt;next = NULL; if(strcmp(p-&gt;data , "0") == 0)&#123; free(p); break; &#125; p1-&gt;next = p; p1 = p; &#125; return head;&#125;NODE *first_insert(NODE* head)&#123; NODE *p1, *p2, *p; int index = 1,count = 0; p1 = head; p2 = p1-&gt;next; p = (NODE*)malloc(sizeof(NODE)); scanf("%s", p-&gt;data); p-&gt;next = NULL; while(p2 != NULL) &#123; count++; if(count == index)&#123; p -&gt; next = p2; p1 -&gt; next = p; break; &#125; p1 = p2; p2 = p2-&gt;next; &#125; return head;&#125;NODE *reverse_copy(NODE *head1)&#123; NODE *head = NULL,*p,*p2,*p1 = NULL; p = (NODE*)malloc(sizeof(NODE)); p-&gt;next = NULL; head = p; p1 = head; p2 = head1-&gt;next; while(p2 != NULL)&#123; p = (NODE*)malloc(sizeof(NODE)); strcpy(p-&gt;data,p2-&gt;data); p = p -&gt;next; &#125; p-&gt;next = NULL; return head;&#125;void free_link(NODE *head)&#123; NODE *p, *p1; p = head; while(p != NULL)&#123; p1 = p; p = p -&gt; next; free(p1); &#125;&#125;void prn(NODE *head)&#123; NODE *p; p = head-&gt;next; while(p != NULL)&#123; printf("data is %s\n", p-&gt;data); p = p-&gt;next; &#125;&#125;void countstr(NODE* head) &#123; char a[30]; int count = 0; printf("\nPut string which you wanna cheak:"); gets(a); NODE *p; p = head-&gt;next; while(p != NULL)&#123; if (strcmp(a, p-&gt;data) == 0) &#123; count++; &#125; p = p-&gt;next; &#125; printf("It shows %d times\n",count);&#125; DONE!XDDDDDDDDDDDDDD]]></content>
      <tags>
        <tag>C Language Homework</tag>
        <tag>C Language</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[install WebDriverAgent on the real iOS device]]></title>
    <url>%2F2018%2F01%2Finstall-WebDriverAgent-on-the-real-iOS-device%2F</url>
    <content type="text"><![CDATA[Documented problems during the installation process and be sure to use a network proxy WebDriverAgent On the last year’s ‘SeleniumConf’, Facebook introduced a new iOS mobile testing framework - WebDriverAgent Now it is able to support real device for test. README.md on Github WebDriverAgent is a WebDriver server implementation for iOS that can be used to remote control iOS devices. It allows you to launch &amp; kill applications, tap &amp; scroll views or confirm view presence on a screen. This makes it a perfect tool for application end-to-end testing or general purpose device automation. It works by linking XCTest.framework and calling Apple’s API to execute commands directly on a device. WebDriverAgent is developed and used at Facebook for end-to-end testing and is successfully adopted by Appium. Features Works with device &amp; simulator Implements most of WebDriver Spec Implements part of Mobile JSON Wire Protocol Spec USB support for devices Inspector endpoint with friendly user interface to inspect current device state Easy development cycle as it can be launched &amp; debugged directly via Xcode Unsupported yet, but works with tvOS &amp; OSX StartIf you did not install Node.js and brew, please click here The first is to install Carthage,the script file will use Carthage to download all the dependencies, and use npm package to corresponding js files. 1$ brew install carthage Try to upgrade to the latest version of Xcode, keep iOS version is greater than 9.3 Download the source code from github 1$ git clone https://github.com/facebook/WebDriverAgent Run the script 12$ cd WebDriverAgent$ ./Scripts/bootstrap.sh *error? The terminal gives the following prompt: 1$ npm WARN deprecated minimatch@2.0.10: Please update to minimatch 3.0.2 or higher to avoid a RegExp Dos issue Although it is to remind me to upgrade for ignoring the warning, and not necessarily wrong, Emm,it will really be the reason that the version is too low? So running： 123$ npm update minimatch@3.0.2$ npm update -d$ npm -v minimatch The version number has not changed? ? Tying to Reinstall： 123$ npm install -g npm@3$ npm -v minimatch3.10.10 Upgrade successfully, run again 1$ ./Scripts/bootstrap.sh Upgrade successfully！ Configure Double-click to openWebDriverAgent.xcodeproj Product Bundle identifier Change the contents of this column casually,just do not like everyone else. These three choose your own personal free development certificate，same withProduct Bundle identifier. Follow TARGETS to change the content Run and Test Connect iPhone, then choose your own device Choose Scheme -&gt; WebDriverAgentRunner The run Product -&gt; Test If the issue appears in the upper right corner, click issue, the system will help you upgrade At this point the desktop will appear such an icon, automatically open and will also automatically minimized. Check Xcode console at this time: Through the IP and port given above, plus / status to your address synthesis. For example http://192.168.2.2:8100/status, then the browser will open. If a bunch of JSON appears, WDA installation is successful. Port forwardingMany Chinese-made iPhones do not have direct access to the phone’s IP and port, the solution is to forward it to the Mac. 12$ brew install imobiledevice$ iproxy 8100 8100 Use iproxy —help to find more specific usage. At this time by visitinghttp://192.168.2.2:8100/statusto confirm WDA is running successfully or not. The inspector address is http://192.168.2.2:8100/inspector, inspector is used to view the UI layer, easy to write test scripts Terminal instead of XcodeIn general, it is better to be fully automated for continuous integration 123456789# Unlock keychain so that it can be signed normallyPASSWORD="replace-with-your-password"security unlock-keychain -p $PASSWORD ~/Library/Keychains/login.keychain# Get the device's UDIDUDID=$(idevice_id -l | head -n1)# Run to testxcodebuild -project WebDriverAgent.xcodeproj -scheme WebDriverAgentRunner -destination "id=$UDID" test OQ:There are some strange problems, for example Failed to authorize rights (0x1) with status: -60007 The bundle “WebDriverAgentRunner” couldn’t be loaded because it is damaged or missing necessary resources Find solutions in THIS official wiki. If the above methods can not solve the problem. Try these steps git pullupgrade WebDriverAgent Uninstall WebDriverAgent Updated Xcode Updated macOS Restart Mac At lastBased on the Python Automation Framework Addresshttps://github.com/NetEaseGame/ATX Reference： https://testerhome.com/topics/7220 https://github.com/facebook/WebDriverAgent/blob/master/README.md https://testerhome.com/topics/4904]]></content>
      <tags>
        <tag>iOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[认识文本文件与二进制文件]]></title>
    <url>%2F2017%2F12%2F%E8%AE%A4%E8%AF%86%E6%96%87%E6%9C%AC%E6%96%87%E4%BB%B6%E4%B8%8E%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%96%87%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[C Primer Plus第六版 417页有这样一段话：“像Unix和Linux这样只有一种文件类型的系统，带b字母的模式和不带b字母的模式相同” 不讨论最底层，因为我太菜 发现问题总所周知，fopen()的函数原型是：FILE *fopen(const char filename, const char mode) 关于char *mode在 C primer Plus(第六版) 这本书对做出了介绍 模式字符串 含义 “r” （read）以只读模式打开文件 “w” （write）以写模式打开文件，把现有的文件长度截成0，如果文件不存在，则创建对应的一个新文件 “a” （append）以写模式打开文件，在现有文件末尾添加内容，如果文件不存在，则创建对应的一个新文件 “r+” 以更新模式打开文件（即可以读写文件） “w+” 以更新模式打开文件（即读和写），如果文件存在，则将其长度截成0；如果文件不存在，则创建一个新文件 “a+” 以更新模式打开文件（即读和写），在现有文件末尾添加内容，如果文件不存在，则创建一个新文件；可以读整个文件，但是只能从末尾添加内容 “rb”、”wb”、”ab”、”rb+”、”r+b”、 “wb+”、”w+b”、”ab+”、”a+b” 与上一个模式类似，但是是以二进制模式而不是文本模式打开文件 “wx”、”wbx”、”w+x”、”wb+x”或”w+bx” （c11）类似非x模式，但是如果文件已存在或以独占模式打开文件，则打开文件失败 但下方有一段话： “像Unix和Linux这样只有一种文件类型的系统，带b字母的模式和不带b字母的模式相同” 那么，译者的意思是，Windows不只有一种文件类型的系统，而Linux只有一种？那是什么差异导致的呢？ 探索上机首先自然是在不同环境下测试啦 测试代码123456789#include &lt;stdio.h&gt;int main(void)&#123; FILE *fp = NULL; fp = fopen("test.txt", "wb+");//使用二进制格式保存 fprintf(fp, "This is testing for fprintf...\n"); fputs("This is testing for fputs...\n", fp); fclose(fp); return 0;&#125; 测试环境windows 10 -1709 -VC6++ 可以发现文本模式并不能正确识别 Kail Linux -2017.3-GCC 7.2 Linux可以识别 macOS -High Sierra-Xcode 9.3 macOS上也可以识别 实践证明fopen()函数在Linux和UNIX下的确不需要带“b”的模式 疑问一顿Google猛如虎，结果下来啥没有。任何系统本质都是二进制文件，那书上这句话究竟想表达什么呢？或者说为什么Linux不需要带“b”字母的模式呢？ 总结比较广义上的二进制文件包括文本文件，这里讨论的是狭义上的二进制文件与文本文件的比较： 能存储的数据类型不同文本文件只能存储char型字符变量。二进制文件可以存储char/int/short/long/float/……各种变量值。 每条数据的长度文本文件每条数据通常是固定长度的。以ASCII为例，每条数据(每个字符)都是1个字节。二进制文件每条数据不固定。如short占两个字节，int占四个字节，float占8个字节…… 读取的软件不同文本文件编辑器就可以读写。比如记事本、NotePad++、Vim等。二进制文件需要特别的解码器。比如bmp文件需要图像查看器，rmvb需要播放器 文件读写过程明白二者的区别，也需要知道文件的读写过程。 以读文件为例，实际上是磁盘 》》 文件缓冲区》》应用程序内存空间 这两个转化过程。我们说“文本文件和二进制文件没有区别”，实际上针对的是第一个过程；既然没有区别，那么打开方式不同，为何显示内容就不同呢？这个区别实际上是第二个过程造成的。 文件实际上包括两部分，控制信息和内容信息。纯文本文件仅仅是没有控制格式信息罢了；实际上也是一种特殊的二进制文件。所以，我们很难区分二者的不同，因为他们的概念上不是完全互斥的。 在Windows和DOS系统中，狭义的文本文件是指扩展名为txt的文件。实际上，那些没有规定格式的，由可理解的的ASCII以及其他编码文字组成的文件都是文本文件，如C源程序文件，HTML超文本，XML。除此之外的其他文件都是二进制文件，如Word文件DOCX，图象格式文件JPG。 但是，所谓使用fopen标志打开文本文件与二进制文件的说法并不准确。正确的说法应该是: 以文本方式和二进制方式打开文件。因为我们用两种方式都可以打开任意的文件。 即使这样，为什么还要区分两种方式呢? 操作差异这是因为这两种方式在读写文件时的操作是不一样的。 二进制方式很简单，读文件时，会原封不动的读出文件的全部內容，写的時候，也是把內存缓冲区的內容原封不动的写到文件中。 而文本方式就不一样了，在读文件时，会将换行符号CRLF(0x0D 0x0A)全部转换成单个的0x0A，并且当遇到结束符CTRLZ(0x1A)时，就认为文件已经结束。相应的，写文件时，会将所有的0x0A换成0x0D0x0A。 上面这一点通俗来说就是 许多MS-DOS编译器都用Ctrl+Z标记文本文件的结尾。以文本模式打开这样的文件时，C能识别作为文件结尾的标记的字符。但是，以二进制模式打开相同的文件时，Ctrl+Z字符被看作是文件中的一个字符，而实际的文件结尾符在该字符的后面，或者文件中可能用空字符填充，使得该文件大小是256的倍数。 MS-DOS用\r\n组合表示文本文件的换行。以文本模式打开相同文件时，C程序把\r\n当作\n。但是，以二进制模式打开该文件时，程序能看见这两个字符。通常，UNIX文本文件既没有Ctrl+Z，也没有\r。 所以，若使用文本方式打开二进制文件时，就很容易出现文件读不完整，或內容不对的错误。即使是用文本方式打开文本文件，也要谨慎使用，比如复制文件，就不应该使用文本方式。 系统差异要特別注意的是，上面这样的说法仅适用于DOS和Windows系统。 在Unix和其他一些系统中，沒有文本方式和二进制方式的区分，使不使用’b’标志都是一样的。这是由于不同操作系统对文本文件换行符的定义，和C语言中换行符的定义有所不同而造成的。 如上文已提到，DOS和Windows系统使用CRLF(0x0D 0x0A)双字节作为文本文件换行符，而Unix文本文件的换行符只有一个字节LF(0x0A)为。在C语言中，也是以LF即&#39;\n&#39;为换行符。 由于DOS/Windows定义的换行符和C语言的不一致，C语言的标准输入输出函数适行读写文本文件时，就适行了CRLF-&gt;LF的转换。而Unix的定义和C语言的是一样的，就不必转换了。 那么，为什么会有定义不一致的情况呢？这纯属历史原因。当初C是在Unix上创造和发展的，对换行的定义自然就一样了。其后C被引入到DOS系统，为了使原有的C程序能不加修改的读写DOS的文本文件，所以就在文件读写上做了修改。随着DOS/Windows逐渐成为主流平台，这个当初为了兼容而做的修改給众多的C语言开发者添了这样一个小小的麻烦。 *转换办法dos2unix/unix2dos一般Linux发行版中都带有这个小工具，只能把DOS转换为UNIX文件，命令如下： # dos2unix dosfile.txt 上面的命令会去掉行尾的^M符号。 vimVim是一个vi的改进版本，可以运行在Windows和Linux平台上，使用方法如下： # vimdosfile.txt DOS转UNIX：:setfileformat=unix UNIX转DOS：:setfileformat=dos :wq 如果你需要把Unix文本文件转换为DOS文本文件，输入:setfileformat=dos，你也可以使用ff来替代fileformat，此时可以输入:set ff=dos。你可以输入:help fileformat来获得跟多的关于选项信息。 注：为了能让vim可以自动识别DOS和UNIX文本文件格式，可以在.vimrc(Linux)或_vimrc（Windows）配置文件中加入如下一行设置： ​ setfileformats=dos,unix ​ 设置完成后，使用vim打开DOS文本文件就不会显示^M字符了。 tr使用tr命令拷贝标准输入到标准输出，替换或者删除掉选择的字符，只能把DOS转换为UNIX文件，命令如下： # tr -d ‘\r’&lt; dosfile.txt &gt; unixfile.txt EmacsEmacs是一个Unix下面的文本编辑工具。它会在底部的状态栏上显示文件的信息。 DOS转UNIX ：M-xset-buffer-file-coding-system Unix UNIX转DOS：M-xset-buffer-file-coding-system dos sed在DOS文件格式中使用CR/LF换行，在Unix下仅使用LF换行，sed替换命令如下： DOS转UNIX：$ sed ‘s/.$//’dosfile.txt &gt; unixfile.txt UNIX转DOS：$ sed ’s/$/\r/’unixfile.txt &gt; dosfile.txt Perl Perl是相当直接，你添加或删除掉文件每行结尾的CR字符。 DOS转UNIX：perl -p -e ‘s/\r$//’&lt; dosfile.txt &gt; unixfile.txt UNIX转DOS：perl -p -e ‘s/$/\r/’&lt; unixfile.txt &gt; dosfile.txt awkDOS转UNIX：awk ‘{sub(“\r$”,“”, $0);print $0}’ dosfile.txt &gt; unixfile.txt UNIX转DOS：awk ‘{sub(“$”,“\r”, $0);print $0}’ dosfile.txt &gt; unixfile.txt Python DOS转UNIX： python -c “importsys; map(sys.stdout.write, (l[:-2] + ‘\n’ for l in sys.stdin.readlines()))”&lt; dosfile.txt &gt; unixfile.txt UNIX转DOS： python -c “importsys; map(sys.stdout.write, (l[:-1] + ‘\r\n’ for l in sys.stdin.readlines()))”&lt; dosfile.txt &gt; unixfile.txt 欢迎补充…]]></content>
      <tags>
        <tag>C Language Homework</tag>
        <tag>C Language standard</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Primary exploration undefined behavior in C/C++]]></title>
    <url>%2F2017%2F12%2FPrimary-exploration-undefined-behavior-in-C%5CC%2B%2B%2F</url>
    <content type="text"><![CDATA[引子：C 语言中int main()和 void main() 有何区别？ 前言 文章基于官方文档汇总而成，引用地址会放在文章末尾，若有修改意见欢迎评论指出～ 渣翻译请见谅，如果翻译有定义性错误，还请评论指出，谢谢 ! 刚开始上课的时候，难免会接触到int main()和void main()，当初我只是初步认识到了void main()是一种 不标准 的写法，但是今天进一步认识到void main()算是一种Undefined behavior(未定义行为)。 main函数原型&amp;&amp;终止行为在C和C++中流传着很多版本的main函数原型，不同的书里也有不同的写法。今天我从几种标准(C89/99/11以及C++98/03/11/14)的角度来寻找一下什么是“标准行为”以及在主函数中return后发生了什么。 比较常见的是下面几种： 12345void main()main()int main()int main(void)int main(int argc,char *argv[]) void main()首先，从标准角度(所有版本)来说，void main()肯定是错的，没有任何标准(C89/99/11以及C++98/03/11/14)中允许过这种写法。 但是我在APUE里看到了一种把主函数写为void main()的原因，不知道是不是有人从这个角度说的然后就以讹传讹了。 The problem is that these compilers don’t know that an exit from main is the same as a return. One way around these warnings, which become annoying after a while, is to use return instead of exit from main. But doing this prevents us from using the UNIX System’s grep utility to locate all calls to exit from a program. Another solution is to declare main as returning void, instead of int, and continue calling exit. This gets rid of the compiler warning but doesn’t look right (especially in a programming text), and can generate other compiler warnings, since the return type of main is supposed to be a signed integer. 还有一种可能是从嵌入式来的，没有操作系统，入口点是硬件实现，返回任何东西都没意义。 main()在K&amp;R C与C89里，函数没有显式声明返回类型，则默认是int: C89对函数定义的语法(Syntax)描述如下(注意declaration-specifiers的opt下标符号)： $${declaration\textrm{-}specifiers{opt}}\hspace{2mm}{declarator\hspace{2mm}declaration\textrm{-}list{opt}}\hspace{2mm}{compound\textrm{-}statement}$$ C89中declaration-specifiers在Syntax上为： storage-class-specifier type-specifier type-qualifier 表明在C89中函数的return type可以省略。 K&amp;R C里的描述如下： Various parts may be absent; a minimal function is 1dummy() &#123;&#125; which does nothing and returns nothing. A do-nothing function like this is sometimes useful as a place holder during program development. If the return type is omitted, int is assumed. 所以说： 123func()&#123;&#125;// 等价于int func()&#123;&#125; 但是这种方式在C99之后就被废除掉了(注意declaration-specifiers没有opt下标了)： declaration-specifiers declarator declaration-list(opt) compound-statement 综上，在C89中，函数的返回类型可以省略，但默认为int，即 主函数声明main()隐式是int main()。 int main()int main()和int main(void)在C语言中是有区别的： 123int main()// 不等价于int main(void) 在C语言中参数列表为空(即不提供参数列表也不为void)，表示不提供参数数量和参数类型信息： 12345678int func()&#123; print("func()\n"); return 0;&#125;int main(void)&#123; func(1,2,3,4);// call func();&#125; The empty list in a function declarator that is not part of a definition of that function specifies that no information about the number or types of theparameters is supplied. C99/11 Standard在C99/11标准中，明确定义了对于标准的main函数的两个原型： The function called at program startup is named main. The implementation declares no prototype for this function. It shall be defined with a return type of int and with no parameters: 程序启动时调用的函数名为main，这种实现声明了这个函数没有原型。 它应该用int的返回类型来定义，并且不带参数： 1int main(void) &#123; /* ... */ &#125; or with two parameters (referred to here as argc and argv, though any names may be used, as they are local to the function in which they are declared): 或者带有两个参数（这里称为argc和argv，尽管使用任何名称，因为它们是本地声明的函数）： 1int main(int argc, char *argv[]) &#123; /* ... */ &#125; or equivalent;or in some other implementation-defined manner.If they are declared, the parameters to the main function shall obey the following constraints: 或者等价;或者以某种其他编译器相关实现的方式。 如果被声明，主函数的参数应该遵守以下约束条件： The value of argc shall be nonnegative. argv[argc] shall be a null pointer. If the value of argc is greater than zero, the array members argv[0] through argv[argc-1] inclusive shall contain pointers to strings, which are given implementation-defined values by the host environment prior to program startup. The intent is to supply to the program information determined prior to program startup from elsewhere in the hosted environment. If the host environment is not capable of supplying strings with letters in both uppercase and lowercase, the implementation shall ensure that the strings are received in lowercase. If the value of argc is greater than zero, the string pointed to by argv[0]represents the program name; argv[0][0] shall be the null character if the program name is not available from the host environment. If the value of argc is greater than one, the strings pointed to by argv[1] through argv[argc-1]represent the program parameters. The parameters argc and argv and the strings pointed to by the argv array shall be modifiable by the program, and retain their last-stored values between program startup and program termination. argc的值应该是非负的。 argv[argc] 应该是一个空指针。 如果argc的值大于零，则argv [0]至argv [argc-1]包含的数组成员应该包含指向字符串的指针，这些字符串在程序启动之前由系统环境给定已被定义的值。 其目的是向程序提供在程序启动之前从托管环境中的其他地方确定的信息。 如果系统环境不能提供大小写字母的字符串，则这类实现应确保字符串以小写形式接收。 如果argc的值大于零，则argv [0]指向的字符串代表程序名称; 如果程序名称在主机环境中不可用，那么argv [0][0]应为空字符。 如果argc的值大于1，argv [1]至argv [argc-1]指向的字符串则代表程序参数。 参数argc和argv以及argv数组所指向的字符串应该可以被程序修改，并在程序启动和程序终止之间保留它们的最后存储的值。 C++ Strandard由于C和C++中对于函数参数列表的规则并不一致(C++中参数列表为空代表不接收任何参数)。所以C++中main的原型和ISO C也并不太一样： a function of () returning int and a function of (int, pointer to pointer to char) returning int main 返回的值main必须要有返回值的原因是：在C和C++中使用return-statement都是将return的值作为参数来调用exit/std::exit来终止程序。 If status is zero or EXIT_SUCCESS, an implementation-defined form of the status successful termination is returned. ISO C99/11:If the return type of the main function is a type compatible with int, a return from the initial call to the main function is equivalent to calling the exit function with the value returned by the main function as its argument;reaching the } that terminates the main function returns a value of 0. If the return type is not compatible with int, the termination status returned to the host environment is unspecified. 如果main函数的返回类型是与int兼容的类型，则从初始调用返回到主函数相当于以main函数返回的值为参数来调用exit函数;到达终止 }主函数返回值 0.如果返回类型与int不兼容，则返回到主机环境的终止状态是未指定的。 Forward references: definition of terms (ISO/IEC 9899:201x 7.1.1), the exit function (ISO/IEC 9899:201x 7.22.4.4). 注意： ISO/IEC 9899:201x -6.9.1 #12 If the } that terminates a function is reached, and the value of the function call is used bythe caller, the behavior is undefined. 如果 }到达终止函数，并且函数调用的值被使用的行为是未定义的。 所以函数结尾不写return是undefined behavior 在Xcode9.0环境下，不写return的函数无法通过编译 ISO C++11/14:A return statement in main has the eﬀect of leaving the main function (destroying any objects with automatic storage duration) and calling std::exit with the return value as the argument. If control reaches the end of main without encountering a return statement, the eﬀect is that of executing main中的return语句具有离开main函数的功能（销毁具有自动存储持续时间的任何对象）并以返回值作为参数调用 std :: exit。 如果控制到达主函数的末尾而没有遇到return语句，那么就是执行： 1return 0; 待补充 exit12#include &lt;stdlib.h&gt;void exit(int status); The exit function causes normal program termination to occur. If more than one call to the exit function is executed by a program, the behavior is undefined. .exit 函数使正常的程序终止执行。如果一个程序执行多个对 exit 函数的调用，其行为将是不确定的。 First, all functions registered by the atexit function are called, in the reverse order of their registration,except that a function is called after any previously registered functions that had already been called at the time it was registered. If, during the call to any such function, a call to the longjmp function is made that would terminate the call to the registered function, the behavior is undefined. Next, all open streams with unwritten buffered data are ﬂushed, all open streams are closed, and all files created by the tmpfile function are removed. Finally, control is returned to the host environment. If the value of status is zero or EXIT_SUCCESS, an implementation-defined form of the status successful termination is returned. If the value of status is EXIT_FAILURE, an implementation-defined form of the status unsuccessful termination is returned. Otherwise the status returned is implementation-defined. 首先，按照相反的顺序调用 atexit 函数所注册的所有函数，除非在注册时调用了之前已经调用的任何已经注册的函数。 如果在调用任何这样的函数期间调用 longjmp 函数来终止对已注册函数的调用，则其行为是不确定的。 接下来，所有开放的未写入的缓冲区数据流被擦除，并关闭所有开放的数据流，并移除由 tmpfile 函数创建的所有文件。 最后，控制权返回到主机环境。 如果状态值为zero或EXIT_SUCCESS，则返回状态 successful termination的自定义形式。 如果状态值为EXIT_FAILURE，则返回状态不成功终止的实现定义形式。 否则，返回的状态是实现其定义的。 The exit function cannot return to its caller. _Exit12#include &lt;stdlib.h&gt;void _Exit(int status); The _Exit function causes normal program termination to occur and control to be returned to the host environment. No functions registered by the atexit function or signal handlers registered by the signal function are called. The status returned to the host environment is determined in the same way as for the exit function (7.20.4.3).Whether open streams with unwritten buffered data are ﬂushed, open streams are closed,or temporary files are removed is implementation-defined.The _Exit function cannot return to its caller. _Exit 函数使正常的程序终止发生，然后控制返回到主机环境。 没有被 atexit 函数注册的函数或者被信号函数注册的信号处理程序将会被调用。 返回到主机环境的状态的确定方式与退出函数（7.20.4.3）的方式相同。无论开放且具有未写入缓冲区的数据流是否被擦除，开放的流是否是关闭的，或者临时文件是否被移除，都是实现其定义的。 _Exit 函数不能返回给它的调用者。 Undefined behavior定义 在计算机程序设计中，未定义行为（英语：undefined behavior）是指行为不可预测的计算机代码。这是一些编程语言的一个特点，最有名的是在C语言中。在这些语言中，为了简化标准，并给予实现一定的灵活性，标准特别地规定某些操作的结果是未定义的，这意味着程序员不能预测会发生什么事。 例如，在C语言中，在任何自动对象被初始化之前，通过非字符类型的左值表达式读取这个变量存储的值会产生未定义行为，除以零或访问数组定义的界限之外的元素（参见缓冲区溢出）也会产生未定义行为。在一般情况下，之后的任何行为是不确定的；甚至只要程序的执行存在未定义行为，在引起未定义行为操作发生之前也可能不要求保证程序的行为可预测（如ISO C++）。特别地，标准从来没有要求编译器判断未定义行为，因此，如果程序调用未定义行为，可能会成功编译，甚至一开始运行时没有错误，只会在另一个系统上，甚至是在另一个日期运行失败。当一个未定义行为的实例发生时，正如语言标准所说，“什么事情都可能发生”，也许什么都没有发生。 和未指定行为(unspecified behavior)不同，未定义行为强调基于不可移植或错误的程序构造，或使用错误的数据。一个符合标准的实现可以在假定未定义行为永远不发生（除了显式使用不严格遵守标准的扩展）的基础上进行优化，可能导致原本存在未定义行为（例如有符号数溢出）的程序经过优化后显示出更加明显的错误（例如死循环）。因此，这种未定义行为一般应被视为bug。 Example in C and C++Attempting to modify a string literal causes undefined behavior 尝试修改字符串字面量会产生未定义行为： 123char * p = "wikipedia";// valid C, ill-formed in C++11, deprecated C++98/C++03 //C++11中错误，C++98/C++03不推荐使用p[0] = 'W'; // undefined behavior 未定义行为 防止这一点的方法之一是将它定义为数组而不是指针： 12char p[] = "wikipedia"; /* 正确 */p[0] = 'W'; Integer division by zero results in undefined behavior 除以零会导致未定义行为。 根据 IEEE 754，float、double和long double类型的值除以零的结果是无穷大或NaN： 1return x/0; // undefined behavior Certain pointer operations may result in undefined behavior: 某些指针操作可能导致未定义行为： 1234int arr[4] = &#123;0, 1, 2, 3&#125;;int *p = arr + 5; // undefined behavior for indexing out of boundsp = 0;int a = *p; // undefined behavior for dereferencing a null pointer In C and C++, the comparison of pointers to objects is only strictly defined if the pointers point to members of the same object, or elements of the same array. Example: 在C和C ++中，如果指针指向相同对象的成员，或者指向同一个数组的元素，那么只能严格定义指向对象的指针。样例： 123456int main(void)&#123; int a = 0; int b = 0; return &amp;a &lt; &amp;b; /* undefined behavior */&#125; Reaching the end of a value-returning function (other than main()) without a return statement results in undefined behavior if the value of the function call is used by the caller: 到达返回数值的函数（除main函数以外）的结尾，而没有一个return语句，会导致未定义行为： 12int f()&#123;&#125; /* undefined behavior if the value of the function call is used*/ Modifying an object between two sequence points more than once produces undefined behavior. It is worth mentioning that there are considerable changes in what causes undefined behavior in relation to sequence points as of C++11. The following example will however cause undefined behavior in both C++ and C. 在两个连续点之间多次修改对象会产生未定义的行为。值得一提的是，与C ++ 11相比，未定义的行为与顺序点的关系有所改变。下面的例子然而会导致C ++和C 中未定义的行为 1i = i++ + 1; // undefined behavior When modifying an object between two sequence points, reading the value of the object for any other purpose than determining the value to be stored is also undefined behavior. 在两个连续点之间修改对象时，除了确定要存储的值之外，读取对象的值也是未定义的行为。 12a[i] = i++; // undefined behaviorprintf("%d %d\n", ++n, power(2, n)); // also undefined behavior BenefitsDocumenting an operation as undefined behavior allows compilers to assume that this operation will never happen in a conforming program. This gives the compiler more information about the code and this information can lead to more optimization opportunities. 将记录为未定义的行为允许编译器假定这个行为永远不会在符合的程序中执行。这给了编译器更多关于代码的信息，这些信息可以有更多机会去优化代码。 C语言的一个例子： An example for the C language: 1234567int foo(unsigned char x)&#123; int value = 2147483600; /* assuming 32 bit int */ value += x; if (value &lt; 2147483600) bar(); return value;&#125; The value of x cannot be negative and, given that signed integer overflow is undefined behavior in C, the compiler can assume that at the line of the if check value &gt;= 2147483600. Thus the if and the call to the function bar can be ignored by the compiler since the if has no side effects and its condition will never be satisfied. The code above is therefore semantically equivalent to: x不能为负值，并且考虑到有符号整数溢出在C中是未定义的行为，编译器可以假设在if检查value &gt;= 2147483600。因此if对函数的调用bar可以被编译器忽略，因为if没有带来任何影响，它的条件永远不会被满足。上面的代码因此在语义上等同于： 12345int foo(unsigned char x)&#123; int value = 2147483600; value += x; return value;&#125; Had the compiler been forced to assume that signed integer overflow has wraparound behavior, then the transformation above would not have been legal. Such optimizations become hard to spot by humans when the code is more complex and other optimizations, like inlining, take place. Another benefit from allowing signed integer overflow to be undefined is that it makes it possible to store and manipulate a variable’s value in a processor register that is larger than the size of the variable in the source code. For example, if the type of a variable as specified in the source code is narrower than the native register width (such as “int on a 64-bit machine, a common scenario), then the compiler can safely use a signed 64-bit integer for the variable in the machine code it produces, without changing the defined behavior of the code. If the behavior of a 32-bit integer under overflow conditions was depended upon by the program, then a compiler would have to insert additional logic when compiling for a 64-bit machine, because the overflow behavior of most machine code instructions depends on the register width. A further important benefit of undefined signed integer overflow is that it enables, though does not require, such erroneous overflows to be detected at compile-time or by static program analysis, or by run-time checks such as the Clang and GCC sanitizers and valgrind; if such overflow was defined with a valid semantics such as wrap-around then compile-time checks would not be possible. 如果编译器被迫假定有符号整数溢出具有环绕行为，那么上面的转换就不合法了。 当代码更复杂时，人们难以发现这样的优化，并作出其他优化，如内联。 允许有符号整数溢出未定义的另一个好处是可以在处理器寄存器中存储和操作变量的值，该寄存器的值大于源代码中变量的大小。例如，如果源代码中指定的变量类型比本地寄存器宽度窄（例如64位机器上的“ int ” ，这是最常见的情况），那么编译器可以安全地使用带符号的 64 位寄存器 机器代码中产生的整数变量，而不会改变代码的定义行为。如果在溢出条件下32位整数的行为被程序所依赖，那么在编译64位机器时，编译器将不得不考虑额外的逻辑，因为大多数机器代码指令的溢出行为取决于寄存器宽度. 未定义的有符号整数溢出的另一个重要好处是，它可以在编译时或通过静态程序分析或通过运行时检查（如Clang和GCC sanitizers和valgrind来检测这种溢出的错误; 如果这样的溢出是用一个有效的语义来定义的，比如环绕行为，那么编译时检查是不可能的。 RisksC and C++ standards have several forms of undefined behavior throughout, which offers increased liberty in compiler implementations and compile-time checks at the expense of undefined run-time behavior if present. In particular, there is an appendix section dedicated to a non-exhaustive listing of common sources of undefined behavior in C. Moreoever, compilers are not required to diagnose code that relies on undefined behavior, due to current static analysis limitations. Hence, it is common for programmers, even experienced ones, to unintentionally rely on undefined behavior either by mistake, or simply because they are not well-versed in the rules of the language that can span over hundreds of pages. This can result in bugs that are exposed when optimizations are enabled on the compiler, or when a compiler of a different vendor or version is used. Testing or fuzzing with dynamic undefined behavior checks enabled, e.g. the Clang sanitizers, can help to catch undefined behavior not diagnosed by the compiler or static analyzers. In scenarios where security is critical, undefined behavior can lead to security vulnerabilities in software. When GCC’s developers changed their compiler in 2008 such that it omitted certain overflow checks that relied on undefined behavior, CERT issued a warning against the newer versions of the compiler. Linux Weekly News pointed out that the same behavior was observed in PathScale C, Microsoft Visual C++ 2005 and several other compilers; the warning was later amended to warn about various compilers. C和C ++标准在整个制定过程中都有几种不确定的行为，如果存在未定义的运行行为，则会增加编译器执行和编译时检查的自由度。特别是有一个附录部分，专门用于列举C中不确定行为的常见来源。不过，由于当前的静态分析限制，编译器不需要诊断依赖于未定义行为的代码。因此，甚至经验丰富的程序员通常会无意中依赖未定义的行为，或者是因为他们不熟悉可能长达数百页的语言规则。这可能会导致在编译器上启用优化时或在使用不同发行商或不同版本的编译器时公开的bug。启用动态未定义行为检查（例如Clang sanitizers）的测试或模糊测试可以帮助捕获未经编译器或静态分析器诊断的未定义行为。 在安全性至关重要的情况下，未定义的行为会导致软件中出现安全漏洞。GCC的开发人员在2008年修改了他们的编译器，忽略了某些依赖于未定义行为的溢出检查时，CERT会对新版本的编译器发出警告。 Linux Weekly News 指出，同样的行为存在于 PathScale C, Microsoft Visual C++ 2005和其他一些编译器; 警告规则在后来已经被修订，用来警告各种编译器. References ISO/IEC (1999). ISO/IEC 9899:1999(E): Programming Languages - C §6.5 Expressions para. 2 ISO/IEC (2003). ISO/IEC 14882:2003(E): Programming Languages - C++ §2.13.4 String literals [lex.string] para. 2 ISO/IEC (2003). ISO/IEC 14882:2003(E): Programming Languages - C++ §5.6 Multiplicative operators [expr.mul] para. 4 ISO/IEC (2007). ISO/IEC 9899:2007(E): Programming Languages - C §6.9 External definitions para. 1 ISO/IEC (2011) .ISO/IEC 9899:201x(E): Programming Languages - C § 5.1.2.2.1Program startup para. 1,2 ANSI X3.159-1989 Programming Language C, footnote 26 https://imzlp.me/posts/15272/ “Vulnerability Note VU#162289 — gcc silently discards some wraparound checks”. Vulnerability Notes Database. CERT. 4 April 2008. Archived from the original on 9 April 2014. “Order of evaluation - cppreference.com”. en.cppreference.com. Retrieved 2016-08-09. https://zh.wikipedia.org/wiki/%E6%9C%AA%E5%AE%9A%E4%B9%89%E8%A1%8C%E4%B8%BA https://en.wikipedia.org/wiki/Undefined_behavior#Examples_in_C_and_C++ Undefined behavior can result in time travel. 27 Jun 2014 [2015-03-09]. Lattner, Chris. What Every C Programmer Should Know About Undefined Behavior. LLVM Project Blog. LLVM.org. May 13, 2011 [May 24, 2011]. The Jargon File on “nasal demons”，未定义行为的一个可能后果。]]></content>
      <tags>
        <tag>Language Standard</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[初探 UIViewController 生命周期]]></title>
    <url>%2F2017%2F12%2F%E5%88%9D%E6%8E%A2UIViewController-%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%2F</url>
    <content type="text"><![CDATA[对象的生命周期一直是开发者所需要关心的，教授 CS193p 的老师 Paul 也详细的讲述了 UIViewController 的生命周期。 环境 日期 Swift Xcode 2017/12/25 4.0 9.2 探究ViewController 的生命周期，其实指的是它控制的视图（View）的生命周期。每当视图的状态发生变化时，视图控制器会自动调用一系列方法来响应变化。 通过这些方法，我们就可以跟踪到视图的整个生命周期。各个方法按执行顺序排列如下： InitializationStoryboard123OUTPUT:init(coder:)awakeFromNib() init(coder:) 当使用 Storyboard 时，控制器的构造器为 init(coder:) 该构造器为必需构造器，如果重写其他构造器，则必须重写该构造器。 该构造器为可失败构造器，即有可能构造失败，返回 nil。 该方法来源自 NSCoding 协议，而 UIViewController 遵从这一协议。 该方法被调用意味着控制器有可能（并非一定）在未来会显示。 在控制器生命周期中，该方法只会被调用一次。 awakeFromNib() 当使用 Storyboard 时，该方法会被调用。 当调用该方法时，将保证所有的 outlet 和 action 连接已经完成。 该方法内部必须调用父类该方法，虽然默认实现为空，但 UIKit 中许多类的该方法为非空。 由于控制器中对象的初始化顺序不能确定，所以构造器中不应该向其他对象发送消息，而应当在 awakeFromNib() 中安全地发送。 通常使用 awakeFromNib() 可以进行在设计时无法完成的必要额外设置。 Code12OUTPUT:init(nibName:bundle:) - NibName: nil, Bundle: nil init(nibName:bundle:) 当使用纯代码创建控制器，控制器的构造器为 init(nibName:bundle:) 虽然使用代码创建时调用了该构造器，但传入的参数均为 nil。 loadView() loadView() 即加载控制器管理的 view（视图初始化） 不应该直接调用该方法，而是由系统自动调用。当 view 被请求却为 nil 时，该方法加载并创建 view。 若控制器有关联的 Nib 文件，该方法会从 Nib 文件中加载 view；如果没有，则创建空白 UIView 对象。 如果使用 Interface Builder 创建 view，则务必不要重写该方法。 可以使用该方法手动创建视图，且需要将根视图分配为 view；重写 loadView 方法不应该再调用父类的该方法。 执行其他初始化操作，建议放在 viewDidLoad() 中。 viewDidLoad() view 被加载到内存后调用 viewDidLoad() 重写该方法需要首先调用父类该方法。 该方法中可以额外初始化控件，例如移除一些视图，添加子控件，添加约束，修改数据等。 该方法被调用意味着控制器有可能（并非一定）在未来会显示。 在控制器生命周期中，该方法只会被调用一次。 viewWillAppear(_:) 该方法在控制器 view 即将添加到视图层次时以及展示 view 时所有动画配置前被调用。 重写该方法需要首先调用父类该方法。 该方法中可以进行操作即将显示的 view，例如改变当前屏幕方向或状态栏的风格。 该方法被调用意味着控制器将一定会显示。 在控制器生命周期中，该方法可能会被多次调用。 注意⚠️： 如果控制器 A 被展示在另一个控制器 B 的 popover 中，那么控制器 B 不会调用该方法，直到控制器 A 清除。 viewWillLayoutSubviews() 该方法在通知控制器将要布局 view 的子控件时调用。 每当视图的 bounds 改变，view 将调整其子控件位置。 该方法可重写以在 view 布局子控件前做出改变。 该方法的默认实现为空。 该方法调用时，AutoLayout 未起作用。 在控制器生命周期中，该方法可能会被多次调用。 viewDidLayoutSubviews() 该方法在通知控制器已经布局 view 的子控件时调用。 该方法可重写以在 view 布局子控件后做出改变。 该方法的默认实现为空。 该方法调用时，AutoLayout 已经完成。 在控制器生命周期中，该方法可能会被多次调用。 viewDidAppear(_:) 该方法在控制器 view 已经添加到视图层次时被调用。 重写该方法需要首先调用父类该方法。 我们可以在这个方法中，对视图做一些关于展示效果方面的修改。 在控制器生命周期中，该方法可能会被多次调用。 viewWillDisappear(_:) 该方法在控制器 view 将要消失、被覆盖或是隐藏时调用。 类似 viewWillAppear(_:) 该方法可重写以提交变更，取消视图第一响应者状态。 viewDidDisappear(_:) 该方法在控制器 view 已经消失、被覆盖或是隐藏时调用。 类似 viewDidAppear(_:) 该方法可重写以清除或隐藏控件。 viewVillUnload&amp;&amp;viewDidUnload 自 iOS6 起，viewWillUnload 和 viewDidUnload 这两个方法被废除了。当系统发出内存警告的时候，会自动把 view 给清除掉，不用我们再特别处理。 同时系统还会调用 didReceiveMemoryWarning 方法通知视图控制器，我们可以在这里面进行一些操作，来释放一些额外的资源。（通常来说不用操作，比较最占资源的 view 已经被系统给清理了。） didReceiveMemoryWarning() 当内存预警时，该方法被调用。 不能直接手动调用该方法。 该方法可重写以释放资源、内存。 deinit 控制器销毁时（离开堆），调用该方法。 视图状态的转换在实际应用中，视图通常不会按照上面列的流程一次执行下来，可能会在可见与不可见的状态间互相转换。比如一开始视图是可见的，接着我们跳转到另一个 ViewController，这时原来视图就变成不可见的。后面我们又跳转回来，那么这个视图就又是可见的。 当视图的可见性发生变化时，视图控制器对应的方法也会随之响应。具体可见下图： Appearing 和 Disappearing 这两个状态是可以互相转化的 测试样例1.ViewController 是首页视图控制器，我们将里面所有的与生命周期有关的函数都打印出来。 2.同时 ViewController 中添加了一个“跳转”按钮，点击后跳转到另一个视图控制器AnotherViewController。3.AnotherViewController 里有个“返回”按钮，点击又会回到前一个页面。 测试代码ViewController.swift 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455import UIKit class ViewController: UIViewController &#123; //视图初始化 override func loadView() &#123; super.loadView() print("loadView") &#125; //视图加载完成 override func viewDidLoad() &#123; super.viewDidLoad() print("viewDidLoad") //创建跳转按钮 let button:UIButton = UIButton(type: .System) button.frame=CGRectMake(10, 50, 100, 30) button.setTitle("跳转", forState: .Normal) button.addTarget(self,action:#selector(jump),forControlEvents:.TouchUpInside) self.view.addSubview(button); &#125; //视图将要出现的时候执行 override func viewWillAppear(animated: Bool) &#123; print("viewWillAppear") &#125; //视图显示完成后执行 override func viewDidAppear(animated: Bool) &#123; print("viewDidAppear") &#125; //视图将要消失的时候执行 override func viewWillDisappear(animated: Bool) &#123; print("viewWillDisappear") &#125; //视图已经消失的时候执行 override func viewDidDisappear(animated: Bool) &#123; print("viewDidDisappear") &#125; //收到内存警告时执行 override func didReceiveMemoryWarning() &#123; super.didReceiveMemoryWarning() &#125; //跳转到另一个视图 func jump()&#123; print("点击按钮，开始跳转！") let anotherVC = AnotherViewController() presentViewController(anotherVC, animated: true, completion: nil) &#125;&#125; AnotherViewController.swift 12345678910111213141516171819202122232425import UIKit class AnotherViewController: UIViewController &#123; override func viewDidLoad() &#123; super.viewDidLoad() //创建返回按钮 let button:UIButton = UIButton(type: .System) button.frame=CGRectMake(10, 150, 100, 30) button.setTitle("返回", forState: .Normal) button.addTarget(self,action:#selector(back),forControlEvents:.TouchUpInside) self.view.addSubview(button); &#125; //返回之前视图 func back()&#123; print("点击按钮，开始返回！") self.dismissViewControllerAnimated(true, completion: nil) &#125; override func didReceiveMemoryWarning() &#123; super.didReceiveMemoryWarning() &#125;&#125; 运行测试从 ViewController 跳到 AnotherViewController，再从 AnotherViewController 跳回 ViewController。整个控制台打印出来的流程如下： 12345678910loadViewviewDidLoadviewWillAppearviewDidAppear点击按钮，开始跳转！viewWillDisappearviewDidDisappear点击按钮，开始返回！viewWillAppearviewDidAppear NoteRotation OUTPUT: willTransition(to:with:) viewWillLayoutSubviews() - Optional((67.5, 269.5, 240.0, 128.0)) viewDidLayoutSubviews() - Optional((213.5, 123.5, 240.0, 128.0)) viewWillLayoutSubviews() - Optional((213.5, 123.5, 240.0, 128.0)) viewDidLayoutSubviews() - Optional((213.5, 123.5, 240.0, 128.0)) viewWillLayoutSubviews() - Optional((213.5, 123.5, 240.0, 128.0)) viewDidLayoutSubviews() - Optional((213.5, 123.5, 240.0, 128.0)) 当 view 转变，会调用 willTransition(to:with:) 方法。 当屏幕旋转，view 的 bounds 改变，其内部的子控件也需要按照约束调整为新的位置，因此也调用了 viewWillLayoutSubviews() 和 viewDidLayoutSubviews() Present &amp; Dismiss OUTPUT: viewWillDisappear viewDidDisappear viewDidDisappear viewWillAppear viewDidAppear 当在一个控制器内 Present 新的控制器，原先的控制器并不会销毁，但会消失，因此调用了 viewWillDisappear 和 viewDidDisappear 方法。 如果新的控制器 Dismiss，即清除自己，原先的控制器会再一次出现，因此调用了其中的 viewWillAppear 和 viewDidAppear 方法。 Endless loop123456789class LoopViewController: UIViewController &#123; override func loadView() &#123; print(#function) &#125; override func viewDidLoad() &#123; print(#function) let _ = view &#125;&#125; OUTPUT: loadView() viewDidLoad() loadView() viewDidLoad() loadView() viewDidLoad() loadView() viewDidLoad() loadView() 若 loadView() 没有加载 view，viewDidLoad() 会一直调用 loadView() 加载 view，因此构成了死循环，程序即卡死。 Reference CS193P_2017 UIViewController 相关生命周期总结 UIViewController生命周期详解]]></content>
      <tags>
        <tag>Swift</tag>
        <tag>UIkit</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[音乐外链播放器推荐]]></title>
    <url>%2F2017%2F12%2F%E4%BC%98%E7%A7%80%E9%9F%B3%E4%B9%90%E5%A4%96%E9%93%BE%E6%92%AD%E6%94%BE%E5%99%A8%E6%8E%A8%E8%8D%90%2F</url>
    <content type="text"><![CDATA[之前寻找音乐外链，最开始选择的是网易云。但是，网易云功能也太少了，实在忍不了。 前言根据互联网定律之一，既然存在比国内优秀的服务，那么应该也被封得差不多了。（逃 正文话不多说，开始了！ 不对，先婊一下网易云的外链。 这个看起来还好，歌单视图看着像是多少年前的东西了，丑的要死。 Spotify 外链获取作为Spotify的老用户，第一个自然是要推荐它的。（五毛一条） 不过由于版权原因，非付费用户只能听30秒就要切换到下一首歌 首先打开网页播放窗口，神清气爽的界面映入我们眼帘： 搜索喜欢的歌，或者专辑，然后：Copy Playlist link 接下来去往开发者中心，粘贴之前复制的播放列表： 去下方自定义样式然后复制下面的iframe标签，放入html5即可，此方法通用，下文不会再涉及。 效果展示 Soundcloud 外链获取 Soundcloud是一家来自德国的音乐服务商，首先去Soundcloud，搜索喜欢的歌或者专辑，然后点击share 选择Embed，自己自定义喜欢的样式，然后复制code。 效果展示 mixcloud 外链获取 这是来自英国的服务商，服务也很不错，不过是用户自己创作的音乐较多。 网址在这里，同样是搜索歌曲，然后选择share，然后选择具体样式 效果展示 soundsgood 外链获取这是我最推荐的一个，不仅可以切换来源，还可以播放视频。如果你可以绕过GFW,你就会发现这是世界上最好的选择 首先还是打开Soundsgood，自己折腾注册和账号绑定。 自己创建歌单，自定义封面，然后点击EMBED获取外链 效果展示 应该有墙 结尾估计要被喜欢网易云音乐的人们萌豚打死了（逃]]></content>
      <tags>
        <tag>Music</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS降级通用教程]]></title>
    <url>%2F2017%2F12%2FiOS%E9%99%8D%E7%BA%A7%E9%80%9A%E7%94%A8%E6%95%99%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[此文只设计如何降级到可联网验证的版本，适合纯小白。想要降级到iOS10，9，8请自行SHSH 前言：此文之说明如何降级何关闭更新提示，越狱后请自行探索(ง๑ •̀_•́)ง 准备工作 一部未越狱iPhone的且系统版本高于iOS11.1.2 一台安装了iTunes且可联网的电脑（最好是你自己的） 一根可连接电脑和iTunes的数据线 一双没有瞎的眼睛 如果没有，还请准备完毕后开始教程(´_ゝ`) 开始降级查询可降级验证版本在查询iOS固件状态后 发现iOS目前可支持验证更新的最低版本是iOS11.0.1，由于每年苹果都会陆续关闭验证通道，所以推荐尽快完成降级。 备份手机资料 安全起见，手机有价，数据无价。我们首先应该进行备份。首先连接手机到电脑，打开iTunes，点击资料库左边的手机样式，在左边设置里面选择摘要—备份，然后点击立即备份到电脑。 这个时候只需等待即可，通常来讲，文件越多，备份所需时间也会越长。具体备份文件地址请访问Apple支持 下载固件 我推荐iOS11.1版本，即将在圣诞节发布的越狱工具首先就是iOS11.1测试成功，为了稳定我推荐iOS11.1版本 首先确认自己的手机版本号，在手机背后下面即可看到产品型号。 一定要确定自己的型号！！ iPhone版本 手机型号&amp;&amp;下载固件 iPhone 8 Plus A1864 iPhone 8 A1863 iPhone 7 Plus A1784， A1661,A1786 iPhone 7 A1778，A1660,A1780 iPhone SE A1723,A1724 iPhone 6s Plus A1699,A1634,A1687 iPhone 6s A1700,A1688,A1633 iPhone 6 Plus A1524,A1522,A1593 iPhone 6 A1586,A1549,A1589 iPhone 5S A1533,A1453， A1518,A1528,A1530,A1457 关闭查找我的设备 前往“设置”&gt;“[您的名字]”&gt;“iCloud”（或“设置”&gt;“iCloud”），然后关闭“查找我的 [iPhone]”。 输入iCloud账号密码，点击关闭 开始刷机降级设备连接iTunes，进入设备详情页面之后查看 如果和我一样是最新版系统，只能通过按住键盘Shift键（Mac电脑按住Control ⌃键）点击【恢复iPhone】，然后选中之前下好的固件（ipsw格式），你的手机将会重置，所以务必前往“设置”&gt;“[您的名字]”&gt;“iCloud”（或“设置”&gt;“iCloud”）查看是否开启了iCloud备份个人数据。 如果你未更新最新版本，检查更新按钮应该是更新，那么按住键盘Shift键（Mac电脑按住Control ⌃键）点击更新将会保留原本的数据，同样选择之前下载的固件进行更新（实际是降级） 静静等待奇迹发生吧，如果失败，你还有备份，还原就好。 关闭手机自动更新降级成功的第一件事就是先关闭手机的系统更新 打开safari，地址栏输入: 1https://oldcat.me/web/NOOTA9.mobileconfig 然后回车按照要求安装此描述文件即可，然后重启，点击检查更新你就会发现目前你的系统是最新版本。]]></content>
      <tags>
        <tag>iOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[I Wish you a Merry Christmas]]></title>
    <url>%2F2017%2F12%2FI-wish-you-a-Merry-Christmas%2F</url>
    <content type="text"><![CDATA[圣诞节快乐米娜桑ε٩(๑&gt; ₃ &lt;)۶з～ 又是一年圣诞季，祝大家都能开开心心的～ 有男女朋友的除外 冬が来る——嬉しくて切ない、永遠の一瞬が 年末总结今年年初过得还不错吧，经历过高考复习的紧张和压抑，枯燥但充实。反省一下高考前还一直通宵打游戏 也感受到了毕业后的放松和对大学的期待。感谢高中三年的同学友谊，无论是17班还是11班，都是我的一份记忆。前者给了我深刻的记忆，后者则给了我永久的回忆。特别感谢你，陪我度过的那些日子，尽管结局不太美好但我希望你在未来会过上你喜欢的生活。 高考成绩不好评判，总之在意料之中吧。进了大学认识了很多小伙伴，也加入了计协这个大家庭，同时也感受到了来自优秀学长们的压力。有压力才有动力，虽然一直在熬夜通宵，学到了很多东西，我也在尽力朝我喜欢的方向发展，但是高数挂了。 一切还算满意，只不过感情很不顺利，希望尽早能找到能一个陪我的人。自己确实感觉到有些孤单 喜欢我的赶紧表白啊，我永远喜欢成熟的小姐姐（发文章的时候记得删掉这一条 希望我在乎的人能开开心心的。我讨厌的人的妈年末买菜必定超级涨价。 圣诞礼物圣诞礼物就是给大家推荐一个网址人工智能图片放大，以后大家碰见喜欢的图，但是又找不到高清图，就可以用这个试试哟～ 然后再送大家几张冬季壁纸（会陆续更新 作品名/Title: ﾒﾘｸﾘ🍥🎀插画作者/Artist: ダンミルC93 🍤3日目東シ71b‏ 原始尺寸/Pic Size: 700 × 904px 放大后尺寸/After Enlarge Size: 8x倍放大 5600 × 7232px 来源链接Illustration ID: 8x倍放大 5600 × 7232 像素高清版（17.3 MB） 下载8x 4x倍放大 2800 × 3616 像素高清版（6 MB） 下载4x 作品名/Title: サンタ榛名描きました插画作者/Artist: 京極燈弥＠金曜東ヤ02ｂ 原始尺寸/Pic Size: 724 × 1023px 放大后尺寸/After Enlarge Size: 2x倍放大 1448 × 2046px 4x放大 2896 × 4092px 2x倍放大 1448 × 2046 像素高清版（0.45 MB） 下载2x 4x倍放大 2896 × 4092 像素高清版（1.2 MB） 下载4x 作品名/Title: 動く、動く插画作者/Artist: ガゥ 🐺2日目H-11a 原始尺寸/Pic Size: 1073×985px 放大后尺寸/After Enlarge Size: 8x倍放大 8584 × 7880px 来源链接/Illustration ID: 描述/Description：少女終末旅行のチト×ユーリ可愛いぃ!! 冬コミ新刊にちょこっと載ります… 8x倍放大 8584 × 7880 像素高清版（3 MB） 下载8x 4x倍放大 4292 × 3940 像素高清版（1.1 MB） 下载4x 作品名/Title: Alter插画作者/Artist: TID原始尺寸/Pic Size: 1000×1520px 放大后尺寸/After Enlarge Size: 4x倍放大 4000 × 6080px 来源链接/Illustration ID: 4x倍放大 4000 × 6080 像素高清版（14.2 MB） 下载4x 2x倍放大 2000 × 3040 像素高清版（4.9 MB） 下载2x 更新结束～算了找不到女朋友就找不到吧]]></content>
      <tags>
        <tag>Daily</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[如何给自有域名添加上https服务]]></title>
    <url>%2F2017%2F12%2F%E5%A6%82%E4%BD%95%E7%BB%99%E8%87%AA%E6%9C%89%E5%9F%9F%E5%90%8D%E6%B7%BB%E5%8A%A0%E4%B8%8Ahttps%E6%9C%8D%E5%8A%A1%2F</url>
    <content type="text"><![CDATA[从Chrome56左右开始，对于没有HTTPS的网站，都不会出现一把小绿锁。反之，有了小绿锁的网站，标志着这个网站是HTTPS安全的。 简介什么是https超文本传输安全协议（英语：Hypertext Transfer Protocol Secure，缩写：HTTPS，常称为HTTP over TLS，HTTP over SSL或HTTP Secure）是一种通过计算机网络进行安全通信的传输协议。HTTPS经由HTTP进行通信，但利用SSL/TLS来加密数据包。HTTPS开发的主要目的，是提供对网站服务器的身份认证，保护交换数据的隐私与完整性。这个协议由网景公司（Netscape）在1994年首次提出，随后扩展到互联网上。 历史上，HTTPS连接经常用于万维网上的交易支付和企业信息系统中敏感信息的传输。在2000年代晚期和2010年代早期，HTTPS开始广泛使用于保护所有类型网站上的网页真实性，保护账户和保持用户通信，身份和网络浏览的私密性。 与HTTP的差异 与HTTP的URL由“http://”起始且默认使用端口80不同，HTTPS的URL由“https://”起始且默认使用端口443。 HTTP是不安全的，且攻击者通过监听和中间人攻击等手段，可以获取网站帐户和敏感信息等。HTTPS被设计为可防止前述攻击，并在正确配置时被认为是安全的。 更多资料 步骤注册Cloudflare Cloudflare是国外非常有名的一家网络服务提供商。它提供的其中一项免费服务就是给我们自有域名加上HTTPS。正好符合我们的需求。 注册成功后添加自己的域名。会有三角形的⚠️标示，这代表Cloudflare没有检测到你域名NS的正确指向，不着急，我们解决。 更改DNS服务器地址 然后需要将我们的域名的DNS服务商的地址改成Cloudflare要求的两个DNS服务器地址。每个人分配的不一样，而且必须用分配的否则会失效。 如果域名提供商那里只有添加解析没有更改DNS服务器的选项。例：8a 清空解析，记住你的域名管理密码，然后去代理注册的域名商更改。例：新网 找到dns服务更改并保存，现在一般都是几分钟就生效了，最长也不过48小时 开启HTTPS 找到Crypto选项，这里我们需要开启Flexible的HTTPS选项。 其实Cloudflare做的事就是，当访问我们的域名的时候，实际上走的是Cloudflare的服务器，这个时候这个阶段的访问是有HTTPS的。然后Cloudflare再去请求我们实际的内容，再将内容返回给用户。这一段是没有HTTPS的。也就是实际上是半HTTPS。不过对于我们静态博客来说，这种半HTTPS实际上已经够我们使用了。 重定向 这个时候我们访问https://xxxxx.xxx自然走的是HTTPS。但是如果有人访问了http://xxxxx.xxx，那要如何跳转到HTTPS的页面呢？CloudFare另一个很棒的功能Page Rules就派上用场了。我们可以指定我们的域名强制使用HTTPS，并且当访问是HTTP的时候重定向到HTTPS。这样就能保证访问我们的页面都是通过HTTPS的了。 加入HSTS的列表我们访问自己的网站是走HTTP-&gt;304重定向-&gt;HTTPS。这个是浏览器跟服务器进行了一次通信之后才发生的跳转。我们也可以通过HSTS的Preload List使其访问的是HTTP，但是浏览器识别之后自动转成HTTPS访问，而不经过重定向那一层操作。 可以参考这篇文章对HSTS进行更深入的了解。简单来说，HSTS能够使我们的网站安全性更上一层楼。 还是CloudFare，自有的HSTS功能，开启之后就能很好的满足我们的需要。还是在Crypto选项下，开启HSTS 检查去HSTS Preload List的网站把我们的域名进行检查并收录（不能是子域名，必须是一级域名），如果没通过会给出修改建议，按照建议修改就行。如果通过了，就会放入审核列表。之后可以时不时回来看看自己的网站被收录了没有。我是等了快一周才被收录。网上的说法普遍是几天内（不过我几分钟就审核过了（逃。所以耐心等待收录。一旦被收录就会应用到主流浏览器上，这样你的网站就是更加安全的网站了。 总结因为是Cloudflare的cdn加速，所以在国外访问速度很快，在国内访问的速度会稍慢一些。 话说国内啥时候能有这样的服务啊，万恶的资本主义]]></content>
      <tags>
        <tag>Domain Name</tag>
        <tag>https</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[利用live 2d给博客添加看版娘]]></title>
    <url>%2F2017%2F12%2F%E5%88%A9%E7%94%A8live-2d%E7%BB%99%E5%8D%9A%E5%AE%A2%E6%B7%BB%E5%8A%A0%E7%9C%8B%E7%89%88%E5%A8%98%2F</url>
    <content type="text"><![CDATA[给你的网站加上女朋友 前言现实生活的你是不是没有女朋友呢？没关系，你可以给你自己网页上弄一个 live2d常常被我们用于做手机的动态壁纸增加萌点！live2dviewerex当然你也可以把她放到你的博客上！这样也很卡哇伊不是吗(/ω＼)live2d目前技术还不是很成熟 但是很适合用来做网站的看板娘 转载自@猫与向日葵和@JiuMeng，本人进行一定整合 获取模型&amp;调整：科普：Live2D是一种应用于电子游戏的绘图渲染技术，技术由日本Cybernoids公司开发。通过一系列的连续图像和人物建模来生成一种类似三维模型的二维图像，对于以动画风格为主的冒险游戏来说非常有用，缺点是Live 2D人物无法大幅度转身，开发商正设法让该技术可显示360度图像。首先既然是做live2d的看板娘怎么能少了最基础的模型呢！这里是本project的大概流程图： Live2d的模型（你喜欢的）[这里包含了声音调用以及其他的0.0]→官方或者修改的SDK（合成）→上传至网站相应目录→在相应位置插入 js css div以及其他附属→调整css→完工了！ 关于模型如何获取这里不详细讲解 以下为获取途径：1.百度贴吧 （live2d吧 live2dviewerex吧 ）这里面有很多模型 自己去看看吧！看看能不能找到你们的老婆2.在游戏里提取（注意版权问题）这些游戏都是由live2d引擎驱动的像在这些游戏里都能提取出模型 置于方法嘛（自己百度吧）说出来我怕菊花被人捅烂《樱花庄的宠物女孩》【2013/02/14】(角川游戏)PSP/PSV《某魔术和科学的群奏活剧》【2013/02/21】(NBGI)PSP《药水制作师》【2015/3/23】(Sinsiroad) 安卓/ios这里有篇讲如何提取《药水制作师》模型的文章：相关链接获取模型的格式 最好是moc的可编辑工程文件 当然lpk也行 但是lpk能不能用就看你的运气了这里讲讲如何打开模型查看模型需要使用LIVE2D官方提供的Live2D Viewer，下载和安装方法请查看 这个网页然后如果你下载（或者提取的）的是编工程文件的live2d的话 （json已经写好的）你可以吧json拖到live2d-viewer里面就可以预览模型了如果是lpk格式的文件的话 这里讲解一种（菊花被人捅烂的方法解lpk） 先下载好lpk然后用zip压缩工具查看打开这个lpk 然后解压里面的文件出来就可以得到moc 那样的模型了如果你下载的lpk是被加密过的那么这个方法就不能使用了（乖乖换老婆或者想其他办法吧） 提取 没有被加密的lpk解压出来是这样的： 红色部分为lpk配置文件这个不影响我们制作模型可以不管它 打开主题部分： 把这个拖进我们的Live2D Viewer你就会看到： 模型成功加载了！ 同样我们可以把别的模型也拖进去拖进live2d-viewer里 就可以预览模型了打开Live2D Viewer，将json或者moc （网页只调用json）拖入主窗口，可以看到模型已经加载成功，若有贴图错位、动作鬼畜等情况则为上一步的json文件配置有误，测试直到找到正确的模型、动作、贴图组合 有些模型是自带动作以及语音的这样可以测试动作： 选择要测试的动作，点击Playback播放动作以测试动作是否正常，勾选Loop可以循环播放模型测试好了之后就进入下一步吧！ 模型大概就到这里了 下面是主体部分： 准备SDK为了效率最大化，不用把有限的时间投入到与bug无限的斗争和踩坑中；为了不重复造轮子；为了爱与和平 就是因为懒，我们不使用官方的SDK，而是用@EYHN大佬封装好的库来加载并显示模型。相比较官方版本而言，仅需一条命令即可进行模型的加载，无疑方便许多。 但对于「药水制作师」这款游戏的模型来说，上面所说的库还需经过一些修改。 修改原因基于commit #fea64e4修改，修改内容：修复移动鼠标会触发点击事件的问题增加鼠标点击事件移除自带的眨眼动作增加久置动作与事件支持增加自定义HIT_AREA的方法由于原项目使用了GPL v2开源协议，修改后的代码已开源至GitHub，若想修改请参考项目hexo-helper-live2d 鉴于该项目仍在活跃开发中，@猫与向日葵修改的版本可能会随时间变化而过时 编译后的版本可以在这里下载： Download Now 以下部分内容为转载内容：提示功能（可选）这部分直接抄自之前的浮动小人，做了部分修改，非必须项，须jQuery支持若不启用此部分内容，下一步应作相应修改此处代码不可直接套用，应根据自身情况进行修改这里是为小人添加消息提示框的 此部分可以不做 当然你喜欢的话我也是不介意的少女盲目分析中 代码脚本将以下内容保存为waifu-tips.js，放至相应目录 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127function render(template, context) &#123; var tokenReg = /(\\)?\&#123;([^\&#123;\&#125;\\]+)(\\)?\&#125;/g; return template.replace(tokenReg, function (word, slash1, token, slash2) &#123; if (slash1 || slash2) &#123; return word.replace('\\', ''); &#125; var variables = token.replace(/\s/g, '').split('.'); var currentObject = context; var i, length, variable; for (i = 0, length = variables.length; i &amp;amp;amp;lt; length; ++i) &#123; variable = variables[i]; currentObject = currentObject[variable]; if (currentObject === undefined || currentObject === null) return ''; &#125; return currentObject; &#125;);&#125;String.prototype.render = function (context) &#123; return render(this, context);&#125;; var re = /x/;console.log(re);re.toString = function() &#123; showMessage('哈哈，你打开了控制台，是想要看看我的秘密吗？', 5000); return '';&#125;; $(document).on('copy', function ()&#123; showMessage('你都复制了些什么呀，转载要记得加上出处哦', 5000);&#125;); $.ajax(&#123; cache: true, url: "path/to/waifu-tips.json", dataType: "json", success: function (result)&#123; $.each(result.mouseover, function (index, tips)&#123; $(tips.selector).mouseover(function ()&#123; var text = tips.text; if(Array.isArray(tips.text)) text = tips.text[Math.floor(Math.random() * tips.text.length + 1)-1]; text = text.render(&#123;text: $(this).text()&#125;); showMessage(text, 3000); &#125;); &#125;); $.each(result.click, function (index, tips)&#123; $(tips.selector).click(function ()&#123; var text = tips.text; if(Array.isArray(tips.text)) text = tips.text[Math.floor(Math.random() * tips.text.length + 1)-1]; text = text.render(&#123;text: $(this).text()&#125;); showMessage(text, 3000); &#125;); &#125;); &#125;&#125;); (function ()&#123; var text; if(document.referrer !== '')&#123; var referrer = document.createElement('a'); referrer.href = document.referrer; text = 'Hello! 来自 &amp;amp;amp;lt;span style="color:#0099cc;"&amp;amp;amp;gt;' + referrer.hostname + '&amp;amp;amp;lt;/span&amp;amp;amp;gt; 的朋友'; var domain = referrer.hostname.split('.')[1]; if (domain == 'baidu') &#123; text = 'Hello! 来自 百度搜索 的朋友你是搜索 &amp;amp;amp;lt;span style="color:#0099cc;"&amp;amp;amp;gt;' + referrer.search.split('&amp;amp;amp;amp;wd=')[1].split('&amp;amp;amp;amp;')[0] + '&amp;amp;amp;lt;/span&amp;amp;amp;gt; 找到的我吗？'; &#125;else if (domain == 'so') &#123; text = 'Hello! 来自 360搜索 的朋友你是搜索 &amp;amp;amp;lt;span style="color:#0099cc;"&amp;amp;amp;gt;' + referrer.search.split('&amp;amp;amp;amp;q=')[1].split('&amp;amp;amp;amp;')[0] + '&amp;amp;amp;lt;/span&amp;amp;amp;gt; 找到的我吗？'; &#125;else if (domain == 'google') &#123; text = 'Hello! 来自 谷歌搜索 的朋友欢迎阅读&amp;amp;amp;lt;span style="color:#0099cc;"&amp;amp;amp;gt;『' + document.title.split(' - ')[0] + '』&amp;amp;amp;lt;/span&amp;amp;amp;gt;'; &#125; &#125;else &#123; if (window.location.href == 'https://imjad.cn/') &#123; //如果是主页 var now = (new Date()).getHours(); if (now &amp;amp;amp;gt; 23 || now &amp;amp;amp;lt;= 5) &#123; text = '你是夜猫子呀？这么晚还不睡觉，明天起的来嘛'; &#125; else if (now &amp;amp;amp;gt; 5 &amp;amp;amp;amp;&amp;amp;amp;amp; now &amp;amp;amp;lt;= 7) &#123; text = '早上好！一日之计在于晨，美好的一天就要开始了'; &#125; else if (now &amp;amp;amp;gt; 7 &amp;amp;amp;amp;&amp;amp;amp;amp; now &amp;amp;amp;lt;= 11) &#123; text = '上午好！工作顺利嘛，不要久坐，多起来走动走动哦！'; &#125; else if (now &amp;amp;amp;gt; 11 &amp;amp;amp;amp;&amp;amp;amp;amp; now &amp;amp;amp;lt;= 14) &#123; text = '中午了，工作了一个上午，现在是午餐时间！'; &#125; else if (now &amp;amp;amp;gt; 14 &amp;amp;amp;amp;&amp;amp;amp;amp; now &amp;amp;amp;lt;= 17) &#123; text = '午后很容易犯困呢，今天的运动目标完成了吗？'; &#125; else if (now &amp;amp;amp;gt; 17 &amp;amp;amp;amp;&amp;amp;amp;amp; now &amp;amp;amp;lt;= 19) &#123; text = '傍晚了！窗外夕阳的景色很美丽呢，最美不过夕阳红~'; &#125; else if (now &amp;amp;amp;gt; 19 &amp;amp;amp;amp;&amp;amp;amp;amp; now &amp;amp;amp;lt;= 21) &#123; text = '晚上好，今天过得怎么样？'; &#125; else if (now &amp;amp;amp;gt; 21 &amp;amp;amp;amp;&amp;amp;amp;amp; now &amp;amp;amp;lt;= 23) &#123; text = '已经这么晚了呀，早点休息吧，晚安~'; &#125; else &#123; text = '嗨~ 快来逗我玩吧！'; &#125; &#125;else &#123; text = '欢迎阅读&amp;amp;amp;lt;span style="color:#0099cc;"&amp;amp;amp;gt;『' + document.title.split(' - ')[0] + '』&amp;amp;amp;lt;/span&amp;amp;amp;gt;'; &#125; &#125; showMessage(text, 6000);&#125;)(); window.setInterval(showHitokoto,30000); function showHitokoto()&#123; $.getJSON('https://api.imjad.cn/hitokoto/?cat=&amp;amp;amp;amp;charset=utf-8&amp;amp;amp;amp;length=28&amp;amp;amp;amp;encode=json',function(result)&#123; showMessage(result.hitokoto, 5000); &#125;);&#125; function showMessage(text, timeout)&#123; if(Array.isArray(text)) text = text[Math.floor(Math.random() * text.length + 1)-1]; console.log(text); $('.waifu-tips').stop(); $('.waifu-tips').html(text).fadeTo(200, 1); if (timeout === null) timeout = 5000; hideMessage(timeout);&#125;function hideMessage(timeout)&#123; $('.waifu-tips').stop().css('opacity',1); if (timeout === null) timeout = 5000; $('.waifu-tips').delay(timeout).fadeTo(200, 0);&#125; 文本将以下内容保存为waifu-tips.json，放至相应目录 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110&#123; "mouseover": [ &#123; "selector": ".container a[href^='http']", "text": ["要看看 &amp;amp;amp;lt;span style=\"color:#0099cc;\"&amp;amp;amp;gt;&#123;text&#125;&amp;amp;amp;lt;/span&amp;amp;amp;gt; 么？"] &#125;, &#123; "selector": ".fui-home", "text": ["点击前往首页，想回到上一页可以使用浏览器的后退功能哦"] &#125;, &#123; "selector": "#tor_show", "text": ["翻页比较麻烦吗，点击可以显示这篇文章的目录呢"] &#125;, &#123; "selector": "#comment_go,.fui-chat", "text": ["想要去评论些什么吗？"] &#125;, &#123; "selector": "#night_mode", "text": ["深夜时要爱护眼睛呀"] &#125;, &#123; "selector": "#qrcode", "text": ["手机扫一下就能继续看，很方便呢"] &#125;, &#123; "selector": ".comment_reply", "text": ["要吐槽些什么呢"] &#125;, &#123; "selector": "#back-to-top", "text": ["回到开始的地方吧"] &#125;, &#123; "selector": "#author", "text": ["该怎么称呼你呢"] &#125;, &#123; "selector": "#mail", "text": ["留下你的邮箱，不然就是无头像人士了"] &#125;, &#123; "selector": "#url", "text": ["你的家在哪里呢，好让我去参观参观"] &#125;, &#123; "selector": "#textarea", "text": ["认真填写哦，垃圾评论是禁止事项"] &#125;, &#123; "selector": ".OwO-logo", "text": ["要插入一个表情吗"] &#125;, &#123; "selector": "#csubmit", "text": ["要提交了吗，首次评论需要审核，请耐心等待~"] &#125;, &#123; "selector": ".ImageBox", "text": ["点击图片可以放大呢"] &#125;, &#123; "selector": "input[name=s]", "text": ["找不到想看的内容？搜索看看吧"] &#125;, &#123; "selector": ".previous", "text": ["去上一页看看吧"] &#125;, &#123; "selector": ".next", "text": ["去下一页看看吧"] &#125;, &#123; "selector": ".dropdown-toggle", "text": ["这里是菜单"] &#125;, &#123; "selector": "c-player a.play-icon", "text": ["想要听点音乐吗"] &#125;, &#123; "selector": "c-player div.time", "text": ["在这里可以调整&amp;amp;amp;lt;span style=\"color:#0099cc;\"&amp;amp;amp;gt;播放进度&amp;amp;amp;lt;/span&amp;amp;amp;gt;呢"] &#125;, &#123; "selector": "c-player div.volume", "text": ["在这里可以调整&amp;amp;amp;lt;span style=\"color:#0099cc;\"&amp;amp;amp;gt;音量&amp;amp;amp;lt;/span&amp;amp;amp;gt;呢"] &#125;, &#123; "selector": "c-player div.list-button", "text": ["&amp;amp;amp;lt;span style=\"color:#0099cc;\"&amp;amp;amp;gt;播放列表&amp;amp;amp;lt;/span&amp;amp;amp;gt;里都有什么呢"] &#125;, &#123; "selector": "c-player div.lyric-button", "text": ["有&amp;amp;amp;lt;span style=\"color:#0099cc;\"&amp;amp;amp;gt;歌词&amp;amp;amp;lt;/span&amp;amp;amp;gt;的话就能跟着一起唱呢"] &#125;, &#123; "selector": ".waifu #live2d", "text": ["干嘛呢你，快把手拿开", "鼠…鼠标放错地方了！"] &#125; ], "click": [ &#123; "selector": ".waifu #live2d", "text": ["是…是不小心碰到了吧", "萝莉控是什么呀", "你看到我的小熊了吗", "再摸的话我可要报警了！⌇●﹏●⌇", "110吗，这里有个变态一直在摸我(ó﹏ò｡)"] &#125; ]&#125; 引入JS修改header.php，加入以下内容以创建画布和提示框： 1234&amp;amp;lt;div class="waifu"&amp;amp;gt;&amp;amp;lt;div class="waifu-tips"&amp;amp;gt;&amp;amp;lt;/div&amp;amp;gt;&amp;amp;lt;canvas id="live2d" width="280" height="250" class="live2d"&amp;amp;gt;&amp;amp;lt;/canvas&amp;amp;gt;&amp;amp;lt;/div&amp;amp;gt; 在footer.php中加入以下内容： 123&amp;amp;lt;img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-wp-preserve="%3Cscript%20async%20src%3D%22path%2Fto%2Fwaifu-tips.js%22%3E%3C%2Fscript%3E" data-mce-resize="false" data-mce-placeholder="1" class="mce-object" width="20" height="20" alt="&amp;amp;amp;lt;script&amp;amp;amp;gt;" title="&amp;amp;amp;lt;script&amp;amp;amp;gt;" /&amp;amp;gt;&amp;amp;lt;img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-wp-preserve="%3Cscript%20src%3D%22path%2Fto%2Flive2d.js%22%3E%3C%2Fscript%3E" data-mce-resize="false" data-mce-placeholder="1" class="mce-object" width="20" height="20" alt="&amp;amp;amp;lt;script&amp;amp;amp;gt;" title="&amp;amp;amp;lt;script&amp;amp;amp;gt;" /&amp;amp;gt;&amp;amp;lt;img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-wp-preserve="%3Cscript%20type%3D%22text%2Fjavascript%22%3E%0A%20loadlive2d(%22live2d%22%2C%20%22path%2Fto%2Fmodel.json%22)%3B%0A%3C%2Fscript%3E" data-mce-resize="false" data-mce-placeholder="1" class="mce-object" width="20" height="20" alt="&amp;amp;amp;lt;script&amp;amp;amp;gt;" title="&amp;amp;amp;lt;script&amp;amp;amp;gt;" /&amp;amp;gt; model.json修改为以下内容其中hit_areas_custom字段的head_x和body_x定义了头部和身体的HIT_AREA的左上角的坐标，head_y和body_y定义了右下角的坐标 坐标可通过启用DEBUG_MOUSE_LOG获取 源码+声音 已下是可选择内容 修改你的人物.json 这里给的只是某个贴图的格式: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899&#123; "version":"1.0.0", "model":"model.moc", "textures":[ "textures/default-costume.png" ], "layout":&#123; "center_x":0.0, "center_y":-0.05, "width":2.0 &#125;, "hit_areas_custom":&#123; "head_x":[-0.35, 0.6], "head_y":[0.19, -0.2], "body_x":[-0.3, -0.25], "body_y":[0.3, -0.9] &#125;, "motions":&#123; "idle":[ &#123;"file":"motions/WakeUp.mtn"&#125;, &#123;"file":"motions/Breath1.mtn"&#125;, &#123;"file":"motions/Breath2.mtn"&#125;, &#123;"file":"motions/Breath3.mtn"&#125;, &#123;"file":"motions/Breath5.mtn"&#125;, &#123;"file":"motions/Breath7.mtn"&#125;, &#123;"file":"motions/Breath8.mtn"&#125; ], "sleepy":[ &#123;"file":"motions/Sleeping.mtn"&#125; ], "flick_head":[ &#123;"file":"motions/Touch Dere1.mtn"&#125;, &#123;"file":"motions/Touch Dere2.mtn"&#125;, &#123;"file":"motions/Touch Dere3.mtn"&#125;, &#123;"file":"motions/Touch Dere4.mtn"&#125;, &#123;"file":"motions/Touch Dere5.mtn"&#125;, &#123;"file":"motions/Touch Dere6.mtn"&#125; ], "tap_body":[ &#123;"file":"motions/Touch1.mtn"&#125;, &#123;"file":"motions/Touch2.mtn"&#125;, &#123;"file":"motions/Touch3.mtn"&#125;, &#123;"file":"motions/Touch4.mtn"&#125;, &#123;"file":"motions/Touch5.mtn"&#125;, &#123;"file":"motions/Touch6.mtn"&#125; ], "":[ &#123;"file":"motions/Breath1.mtn"&#125;, &#123;"file":"motions/Breath2.mtn"&#125;, &#123;"file":"motions/Breath3.mtn"&#125;, &#123;"file":"motions/Breath4.mtn"&#125;, &#123;"file":"motions/Breath5.mtn"&#125;, &#123;"file":"motions/Breath6.mtn"&#125;, &#123;"file":"motions/Breath7.mtn"&#125;, &#123;"file":"motions/Breath8.mtn"&#125;, &#123;"file":"motions/Fail.mtn"&#125;, &#123;"file":"motions/Sleeping.mtn"&#125;, &#123;"file":"motions/Success.mtn"&#125;, &#123;"file":"motions/Sukebei1.mtn"&#125;, &#123;"file":"motions/Sukebei2.mtn"&#125;, &#123;"file":"motions/Sukebei3.mtn"&#125;, &#123;"file":"motions/Touch Dere1.mtn"&#125;, &#123;"file":"motions/Touch Dere2.mtn"&#125;, &#123;"file":"motions/Touch Dere3.mtn"&#125;, &#123;"file":"motions/Touch Dere4.mtn"&#125;, &#123;"file":"motions/Touch Dere5.mtn"&#125;, &#123;"file":"motions/Touch Dere6.mtn"&#125;, &#123;"file":"motions/Touch1.mtn"&#125;, &#123;"file":"motions/Touch2.mtn"&#125;, &#123;"file":"motions/Touch3.mtn"&#125;, &#123;"file":"motions/Touch4.mtn"&#125;, &#123;"file":"motions/Touch5.mtn"&#125;, &#123;"file":"motions/Touch6.mtn"&#125;, &#123;"file":"motions/WakeUp.mtn"&#125; ], "tap_body": [ &#123; "file":"motions/Touch Dere3.mtn" , "sound":"sounds/1.mp3"&#125;, &#123; "file":"motions/Touch1.mtn" , "sound":"sounds/3.mp3"&#125;, &#123; "file":"motions/Touch2.mtn" , "sound":"sounds/4.mp3"&#125; ], "pinch_in": [ &#123; "file":"motions/Breath3.mtn", "sound":"sounds/9.mp3" &#125; ], "pinch_out": [ &#123; "file":"motions/Breath5.mtn", "sound":"sounds/8.mp3" &#125; ], "shake": [ &#123; "file":"motions/Breath7.mtn", "sound":"sounds/6.mp3","fade_in":500 &#125; ], "flick_head": [ &#123; "file":"motions/Breath8.mtn", "sound":"sounds/3.mp3" &#125; ] &#125;&#125; 上面的mtn动作以及sounds可以选择添加 这样可以在人物里面添加动作同步声音 增加看板娘萌度！ 其中motions的idle组是放置时的动作，按照次序依次显示，可以在这里添加更多的动作 layout的center_x字段和center_y字段用于偏移显示模型，日后若有显示错位可以修改此处的值 增加样式:把如下源码写成css再调用或者直接插入style.css里再调用都可以 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244.waifu &#123; position: fixed; bottom: 0; left: 0; z-index: 1; font-size: 0; transition: all .3s ease-in-out; -webkit-transform: translateY(3px); transform: translateY(3px);&#125;.waifu:hover &#123; -webkit-transform: translateY(0); transform: translateY(0);&#125;@media (max-width: 768px) &#123; .waifu &#123; display: none; &#125;&#125;.waifu-tips &#123; opacity: 0; width: 200px; height: 60px; margin: -20px 20px; padding: 4px 6px; border: 1px solid rgba(224, 186, 140, 0.62); border-radius: 12px; background-color: rgba(236, 217, 188, 0.5); box-shadow: 0 3px 15px 2px rgba(191, 158, 118, 0.2); font-size: 12px; text-overflow: ellipsis; overflow: hidden; position: absolute; animation-delay: 5s; animation-duration: 50s; animation-iteration-count: infinite; animation-name: shake; animation-timing-function: ease-in-out;&#125;.waifu #live2d&#123; position: relative;&#125; @keyframes shake &#123; 2% &#123; transform: translate(0.5px, -1.5px) rotate(-0.5deg); &#125; 4% &#123; transform: translate(0.5px, 1.5px) rotate(1.5deg); &#125; 6% &#123; transform: translate(1.5px, 1.5px) rotate(1.5deg); &#125; 8% &#123; transform: translate(2.5px, 1.5px) rotate(0.5deg); &#125; 10% &#123; transform: translate(0.5px, 2.5px) rotate(0.5deg); &#125; 12% &#123; transform: translate(1.5px, 1.5px) rotate(0.5deg); &#125; 14% &#123; transform: translate(0.5px, 0.5px) rotate(0.5deg); &#125; 16% &#123; transform: translate(-1.5px, -0.5px) rotate(1.5deg); &#125; 18% &#123; transform: translate(0.5px, 0.5px) rotate(1.5deg); &#125; 20% &#123; transform: translate(2.5px, 2.5px) rotate(1.5deg); &#125; 22% &#123; transform: translate(0.5px, -1.5px) rotate(1.5deg); &#125; 24% &#123; transform: translate(-1.5px, 1.5px) rotate(-0.5deg); &#125; 26% &#123; transform: translate(1.5px, 0.5px) rotate(1.5deg); &#125; 28% &#123; transform: translate(-0.5px, -0.5px) rotate(-0.5deg); &#125; 30% &#123; transform: translate(1.5px, -0.5px) rotate(-0.5deg); &#125; 32% &#123; transform: translate(2.5px, -1.5px) rotate(1.5deg); &#125; 34% &#123; transform: translate(2.5px, 2.5px) rotate(-0.5deg); &#125; 36% &#123; transform: translate(0.5px, -1.5px) rotate(0.5deg); &#125; 38% &#123; transform: translate(2.5px, -0.5px) rotate(-0.5deg); &#125; 40% &#123; transform: translate(-0.5px, 2.5px) rotate(0.5deg); &#125; 42% &#123; transform: translate(-1.5px, 2.5px) rotate(0.5deg); &#125; 44% &#123; transform: translate(-1.5px, 1.5px) rotate(0.5deg); &#125; 46% &#123; transform: translate(1.5px, -0.5px) rotate(-0.5deg); &#125; 48% &#123; transform: translate(2.5px, -0.5px) rotate(0.5deg); &#125; 50% &#123; transform: translate(-1.5px, 1.5px) rotate(0.5deg); &#125; 52% &#123; transform: translate(-0.5px, 1.5px) rotate(0.5deg); &#125; 54% &#123; transform: translate(-1.5px, 1.5px) rotate(0.5deg); &#125; 56% &#123; transform: translate(0.5px, 2.5px) rotate(1.5deg); &#125; 58% &#123; transform: translate(2.5px, 2.5px) rotate(0.5deg); &#125; 60% &#123; transform: translate(2.5px, -1.5px) rotate(1.5deg); &#125; 62% &#123; transform: translate(-1.5px, 0.5px) rotate(1.5deg); &#125; 64% &#123; transform: translate(-1.5px, 1.5px) rotate(1.5deg); &#125; 66% &#123; transform: translate(0.5px, 2.5px) rotate(1.5deg); &#125; 68% &#123; transform: translate(2.5px, -1.5px) rotate(1.5deg); &#125; 70% &#123; transform: translate(2.5px, 2.5px) rotate(0.5deg); &#125; 72% &#123; transform: translate(-0.5px, -1.5px) rotate(1.5deg); &#125; 74% &#123; transform: translate(-1.5px, 2.5px) rotate(1.5deg); &#125; 76% &#123; transform: translate(-1.5px, 2.5px) rotate(1.5deg); &#125; 78% &#123; transform: translate(-1.5px, 2.5px) rotate(0.5deg); &#125; 80% &#123; transform: translate(-1.5px, 0.5px) rotate(-0.5deg); &#125; 82% &#123; transform: translate(-1.5px, 0.5px) rotate(-0.5deg); &#125; 84% &#123; transform: translate(-0.5px, 0.5px) rotate(1.5deg); &#125; 86% &#123; transform: translate(2.5px, 1.5px) rotate(0.5deg); &#125; 88% &#123; transform: translate(-1.5px, 0.5px) rotate(1.5deg); &#125; 90% &#123; transform: translate(-1.5px, -0.5px) rotate(-0.5deg); &#125; 92% &#123; transform: translate(-1.5px, -1.5px) rotate(1.5deg); &#125; 94% &#123; transform: translate(0.5px, 0.5px) rotate(-0.5deg); &#125; 96% &#123; transform: translate(2.5px, -0.5px) rotate(-0.5deg); &#125; 98% &#123; transform: translate(-1.5px, -1.5px) rotate(-0.5deg); &#125; 0%, 100% &#123; transform: translate(0, 0) rotate(0); &#125;&#125; 如果单独写成css的 你就在header.php里面加上 1&amp;amp;lt;link rel="stylesheet" href="https://www.ohyhello.com/live2d/live2d.css" type="text/css"/&amp;amp;gt; 调用你自己的css 如一切正常，刷新网页后，可爱的Pio就会出现在页面左下角，点击会播放不同的动作并有相应提示文字 结语：按照以上步骤的话你的博客大概已经出现了卡哇伊的看板娘了注意检查细节特别是waifu-tips.js里面有调用一个json注意别写错路径了 参考&amp;相关连接hexo-helper-live2dlive2d_src 修改模型@猫与向日葵 部分内容转载@猫与向日葵 部分内容转载@JiuMeng live2d 什么是live2d Live2D Viewer – Live2D Cubism 2 中文說明書 药水制作师Unity StudioUABE]]></content>
      <tags>
        <tag>JavaScript</tag>
        <tag>HTML</tag>
        <tag>Wesite</tag>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[给网页添加鼠标点击特效]]></title>
    <url>%2F2017%2F12%2F%E7%BB%99%E7%BD%91%E9%A1%B5%E6%B7%BB%E5%8A%A0%E9%BC%A0%E6%A0%87%E7%82%B9%E5%87%BB%E7%89%B9%E6%95%88%2F</url>
    <content type="text"><![CDATA[最近折腾网页，会陆续分享一些东西给大家 前言偶尔看见别人网页鼠标点击会有特殊效果，一般都是基于js/css实现的，这篇文章会介绍anime.js和如何添加鼠标点击效果 Anime.js 简介Github项目 anime.js是一款功能强大的Javascript动画库插件。anime.js可以和CSS3属性，SVG，DOM元素和JS对象一起工作，制作出各种高性能，平滑过渡的动画效果。 浏览器支持 Chrome Safari IE / Edge Firefox Opera 24+ 6+ 10+ 32+ 15+ 使用123$ npm install animejs# OR$ bower install animejs 1import anime from 'animejs' 或者手动 下载 然后在你的网页上链接 anime.min.js ： 1&lt;script src="anime.min.js"&gt;&lt;/script&gt; 自定义anime.js功能极其强大，具体参数设置详见官方文档，点我了解代码详情 有兴趣可以移步。 你也可以找到喜欢的样式时看看源代码，如果包含了anime.min.js/anime.js你就需要找到另外一个自定义的js文件然后保存到网站目录 添加在&lt;/body&gt;前添加 12345&lt;script type="text/javascript" src="你的文件目录/anime.js"&gt;&lt;/script&gt;&lt;script type="text/javascript" src="你的文件目录/xxxx.js"&gt;&lt;/script&gt;或者&lt;script type="text/javascript" src="你的文件目录/anime.min.js"&gt;&lt;/script&gt;&lt;script type="text/javascript" src="你的文件目录/xxxx.js"&gt;&lt;/script&gt; Download anime.js Now Download anime.min.js Now Codefireworks.js123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124function updateCoords(e) &#123; pointerX = (e.clientX || e.touches[0].clientX) - canvasEl.getBoundingClientRect().left, pointerY = e.clientY || e.touches[0].clientY - canvasEl.getBoundingClientRect().top&#125;function setParticuleDirection(e) &#123; var t = anime.random(0, 360) * Math.PI / 180 , a = anime.random(50, 180) , n = [-1, 1][anime.random(0, 1)] * a; return &#123; x: e.x + n * Math.cos(t), y: e.y + n * Math.sin(t) &#125;&#125;function createParticule(e, t) &#123; var a = &#123;&#125;; return a.x = e, a.y = t, a.color = colors[anime.random(0, colors.length - 1)], a.radius = anime.random(16, 32), a.endPos = setParticuleDirection(a), a.draw = function() &#123; ctx.beginPath(), ctx.arc(a.x, a.y, a.radius, 0, 2 * Math.PI, !0), ctx.fillStyle = a.color, ctx.fill() &#125; , a&#125;function createCircle(e, t) &#123; var a = &#123;&#125;; return a.x = e, a.y = t, a.color = "#F00", a.radius = .1, a.alpha = .5, a.lineWidth = 6, a.draw = function() &#123; ctx.globalAlpha = a.alpha, ctx.beginPath(), ctx.arc(a.x, a.y, a.radius, 0, 2 * Math.PI, !0), ctx.lineWidth = a.lineWidth, ctx.strokeStyle = a.color, ctx.stroke(), ctx.globalAlpha = 1 &#125; , a&#125;function renderParticule(e) &#123; for (var t = 0; t &lt; e.animatables.length; t++) e.animatables[t].target.draw()&#125;function animateParticules(e, t) &#123; for (var a = createCircle(e, t), n = [], i = 0; i &lt; numberOfParticules; i++) n.push(createParticule(e, t)); anime.timeline().add(&#123; targets: n, x: function(e) &#123; return e.endPos.x &#125;, y: function(e) &#123; return e.endPos.y &#125;, radius: .1, duration: anime.random(1200, 1800), easing: "easeOutExpo", update: renderParticule &#125;).add(&#123; targets: a, radius: anime.random(80, 160), lineWidth: 0, alpha: &#123; value: 0, easing: "linear", duration: anime.random(600, 800) &#125;, duration: anime.random(1200, 1800), easing: "easeOutExpo", update: renderParticule, offset: 0 &#125;)&#125;function debounce(fn, delay) &#123; var timer return function () &#123; var context = this var args = arguments clearTimeout(timer) timer = setTimeout(function () &#123; fn.apply(context, args) &#125;, delay) &#125;&#125;var canvasEl = document.querySelector(".fireworks");if (canvasEl) &#123; var ctx = canvasEl.getContext("2d") , numberOfParticules = 30 , pointerX = 0 , pointerY = 0 , tap = "mousedown" , colors = ["#FF1461", "#18FF92", "#5A87FF", "#FBF38C"] , setCanvasSize = debounce(function() &#123; canvasEl.width = 2 * window.innerWidth, canvasEl.height = 2 * window.innerHeight, canvasEl.style.width = window.innerWidth + "px", canvasEl.style.height = window.innerHeight + "px", canvasEl.getContext("2d").scale(2, 2) &#125;,500) , render = anime(&#123; duration: 1 / 0, update: function() &#123; ctx.clearRect(0, 0, canvasEl.width, canvasEl.height) &#125; &#125;); document.addEventListener(tap, function(e) &#123; "sidebar" !== e.target.id &amp;&amp; "toggle-sidebar" !== e.target.id &amp;&amp; "A" !== e.target.nodeName &amp;&amp; "IMG" !== e.target.nodeName &amp;&amp; (render.play(), updateCoords(e), animateParticules(pointerX, pointerY)) &#125;, !1), setCanvasSize(), window.addEventListener("resize", setCanvasSize, !1)&#125;]]></content>
      <tags>
        <tag>Website</tag>
        <tag>JavaScript</tag>
        <tag>HTML</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[利用Node.js解决Win-VS编译的文件到Xcode出现乱码的问题]]></title>
    <url>%2F2017%2F12%2F%E8%A7%A3%E5%86%B3WinVS%E7%BC%96%E8%AF%91%E7%9A%84%E6%96%87%E4%BB%B6%E5%88%B0Xcode%E5%87%BA%E7%8E%B0%E4%B9%B1%E7%A0%81%E7%9A%84%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[在iOS混编的时候，经常会共用跨平台文件，导入到Xcode中，有的格式就可能会识别不了，就会变成乱码，比如说GBK，GB2312（理论上有的文件xcode是可以识别的）。为了可以统一转化这些文件的编码，可以使用Node.js来完成这项工作。 今天心情相当复杂 一.Node.js简介Node.js 不是一种独立的语言,Node.js 也不是一个 JavaScript 框架。Node.js 是一个让 JavaScript 运行在服务端的开发平台。他跳过了http服务器，速度更快，性能更高！ 学习网站：点我跳转 V8引擎本身就是用于Chrome浏览器的JS解释部分，但是Ryan Dahl把V8搬到了服务器上，用于做服务器的软件。 Node.js是一个让JavaScript运行在服务器端的开发平台，它让JavaScript的触角伸到了服务器端，可以与PHP、JSP、Pythod、Ruby平起平坐。 但Node有点不同： Node.js不是一种独立的语言，与php、ASP.Net、JSP、Pythod、Perl、Ruby的既是语言，也是平台不同，Node.js的使用JavaScript进行编程，运行在chrome V8引擎上。 与php、JSP等相比（php、asp.Net、JSP、.net都需要运行在服务器上），Node.js跳过了Apache、Nginx、IIS等HTTP服务器，它自己不用建设在任何服务器软件上，Node.js的许多设计理念与经典架构（LAMP）有着很大的不同，可以提供强大的伸缩能力。 Node.js 与 JavaScript JavaScript 是由 ECMAScript、文档对象模型（DOM）和浏览器对象模型（BOM）组成的，而 Mozilla 则指出 JavaScript 由Core JavaScript 和 Client JavaScript 组成。我们可以认为，Node.js 中所谓的 JavaScript 只是 Core JavaScript，或者说是 ECMAScript 的一个实现，不包含 DOM、BOM 或者 Client JavaScript。这是因为 Node.js 不运行在浏览器中，所以不需要使用浏览器中的许多特性。 Node.js 是一个让 JavaScript 运行在浏览器之外的平台。它实现了诸如文件系统、模块、包、操作系统 API、网络通信等 Core JavaScript 没有或者不完善的功能。历史上将 JavaScript移植到浏览器外的计划不止一个，但Node.js 是最出色的一个。 Node.js 的 JavaScript 引擎是 V8，来自 Google Chrome 项目。V8 号称是目前世界上最快的 JavaScript 引擎，经历了数次引擎革命，它的 JIT（Just-in-time Compilation，即时编译）执行速度已经快到了接近本地代码的执行速度。Node.js 不运行在浏览器中，所以也就不存在 JavaScript 的浏览器兼容性问题，你可以放心地使用 JavaScript 语言的所有特性 二.Node.js配置1.安装1.NodeJS提供了一些安装程序，都可以在nodejs.org这里下载并安装。 2.通过brew安装（brew 又叫Homebrew，是Mac OSX上的软件包管理工具，能在Mac中方便的安装软件或者卸载软件， 只需要一个命令） i&gt;.首先安装brew 12&gt; /usr/bin/ruby -e "$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)"&gt; 将以上命令粘贴至终端。 脚本会在执行前暂停，并说明将它将做什么。高级安装选项在 这里。 ii&gt;.通过brew安装node brew install node Homebrew 会将软件包安装到独立目录，并将其文件软链接至 /usr/local 2.更新node.js 一行命令 版本升级 npm install -g n # 显示错误 所以用 sudo npm install -g n 来代替 如果提示错误，在打开bash的时候使用 sudo -s 回车输入密码即可。 三.iconv-lite配置输入npm install iconv-lite就可以安装了 四.完整代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950// 文件名 index.jsconst fs = require('fs'); const path = require('path'); const iconv = require('iconv-lite');console.log('爬虫程序开始运行...')var root = path.join(__dirname) readDir(path.join(root)) console.log('爬虫程序结束运行...')function readDir(subPath)&#123; fs.readdir(subPath,function(err,menu)&#123; if(!menu) return; menu.forEach(function(ele)&#123; fs.stat(subPath+"/"+ele,function(err,info)&#123; if(info.isDirectory())&#123; readDir(subPath+"/"+ele); &#125;else&#123; // 先判断后缀名 if (isContains(ele, '.h') || isContains(ele, '.hpp') || isContains(ele, '.cpp') || isContains(ele, '.c') || isContains(ele, '.m') || isContains(ele, '.mm')) &#123; transStr(subPath, ele) &#125; &#125; &#125;) &#125;) &#125;) &#125; // 判断是是否包含字符串function isContains(str, substr) &#123; return str.indexOf(substr) &gt;= 0;&#125;// 转化文件中的编码方式function transStr(fontPath, subPath) &#123; var filePath = path.resolve(fontPath, subPath); console.log("file: " + filePath) var data = fs.readFileSync(filePath); var change_data = iconv.decode(data,'gbk'); var aie = iconv.encode(change_data,'utf8'); fs.writeFileSync(filePath, aie);&#125; 有哪个文件夹中的文件需要转化，那就把这个文件（index.js命名可以随便）放在哪个文件夹或者是上一层，只要在终端中，跳转到当前的目录下，然后执行node index.js就可以了。 现在我们简单的分析一下代码的流程 1. 导入模块123const fs = require('fs'); const path = require('path'); const iconv = require('iconv-lite'); 导入需要用到的三个node的模块，fs是处理文件流的，path是处理路径的，iconv-lite是进行编码转化的。 2. 获取路径12var root = path.join(__dirname) readDir(path.join(root)) __dirname 获得当前文件所在目录的完整目录名 3. 遍历所有文件夹中的文件1234567891011121314151617181920212223function readDir(subPath)&#123; fs.readdir(subPath,function(err,menu)&#123; if(!menu) return; menu.forEach(function(ele)&#123; fs.stat(subPath+"/"+ele,function(err,info)&#123; if(info.isDirectory())&#123; readDir(subPath+"/"+ele); &#125;else&#123; // 先判断后缀名 if (isContains(ele, '.h') || isContains(ele, '.hpp') || isContains(ele, '.cpp') || isContains(ele, '.c') || isContains(ele, '.m') || isContains(ele, '.mm')) &#123; transStr(subPath, ele) &#125; &#125; &#125;) &#125;) &#125;) &#125; 这里是利用递归的方式来获取文件夹的所有目录的。 fs.readdir(path, [callback(err,files)]) 以异步的方式读取文件目录。 fs.stat(path, [callback(err, stats)]) 获取文件信息 在这里加了一个判断，如果文件的后缀名是.h .hpp .c .cpp .m .mm的的时候，才会进行编码的转化。 4. 转化文件中的编码方式12345678910function transStr(fontPath, subPath) &#123; var filePath = path.resolve(fontPath, subPath); console.log("file: " + filePath) var data = fs.readFileSync(filePath); var change_data = iconv.decode(data,'gbk'); var aie = iconv.encode(change_data,'utf8'); fs.writeFileSync(filePath, aie);&#125; 最后一部分，才是本文的重点 path.resolve([from ...], to) 将参数 to 位置的字符解析到一个绝对路径里，这里解析出文件的绝对路径。 fs.readFileSync(filename, [encoding]) 异步获取文件中的数据。 fs.writeFileSync(filename, data, [options]) 异步将数据写入到文件。 iconv.decode() iconv.encode() 解码和编码数据的格式，这里的gbk utf8只是一个例子，还可以替换成其他的格式(比如gbk ISO-8859)，这个就需要尝试精神，因为有的时候我们也不知道他到底是什么编码。记得备份，不要和我一样转过去转过来都不能还原了。。。。]]></content>
      <tags>
        <tag>Xcode</tag>
        <tag>Node.js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CocoaPods安装和使用教程]]></title>
    <url>%2F2017%2F11%2FCocoaPods%E5%AE%89%E8%A3%85%E5%92%8C%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[CocoaPods安装和使用教程CocoaPods是什么？当你开发iOS应用时，会经常使用到很多第三方开源类库，比如JSONKit，AFNetWorking等等。可能某个类库又用到其他类库，所以要使用它，必须得另外下载其他类库，而其他类库又用到其他类库，“子子孙孙无穷尽也”，这也许是比较特殊的情况。总之我的意思就是，手动一个个去下载所需类库十分麻烦。另外一种常见情况是，你项目中用到的类库有更新，你必须得重新下载新版本，重新加入到项目中，十分麻烦。如果能有什么工具能解决这些恼人的问题，那将“善莫大焉”。所以，你需要 CocoaPods。 CocoaPods应该是iOS最常用最有名的类库管理工具了，上述两个烦人的问题，通过cocoaPods，只需要一行命令就可以完全解决，当然前提是你必须正确设置它。重要的是，绝大部分有名的开源类库，都支持CocoaPods。所以，作为iOS程序员的我们，掌握CocoaPods的使用是必不可少的基本技能了。 如何下载和安装CocoaPods？在安装CocoaPods之前，首先要在本地安装好Ruby环境。至于如何在Mac中安装好Ruby环境，请google一下，本文不再涉及。 假如你在本地已经安装好Ruby环境，那么下载和安装CocoaPods将十分简单，只需要一行命令。在Terminator（也就是终端）中输入以下命令（注意，本文所有命令都是在终端中输入并运行的。什么，你不知道什么是终端？请你点击左上角谢谢。） 1sudo gem install cocoapods 但是，且慢。如果你在天朝，在终端中敲入这个命令之后，有可能会发现半天没有任何反应。原因无他，因为那堵墙阻挡了cocoapods.org。我们可以用淘宝的Ruby镜像来访问cocoapods。按照下面的顺序在终端中敲入依次敲入命令： 123$ gem sources --remove https://rubygems.org/ //等有反应之后再敲入以下命令 $ gem sources -a http://ruby.taobao.org/ 为了验证你的Ruby镜像是并且仅是taobao，可以用以下命令查看： 1$ gem sources -l 只有在终端中出现下面文字才表明你上面的命令是成功的： 123*** CURRENT SOURCES *** http://ruby.taobao.org/ 上面所有的命令完成之时,你再次在终端中运行： 1$ sudo gem install cocoapods 等上十几秒钟，CocoaPods就可以在你本地下载并且安装好了，不再需要其他设置。 ##如何使用CocoaPods？ 好了，安装好CocoPods之后，接下来就是使用它。所幸，使用CocoPods和安装它一样简单，也是通过一两行命令就可以搞定。 小编在这里用两种使用场景来具体说明如何使用CocoaPods。 场景1：利用CocoaPods，在项目中导入AFNetworking类库AFNetworking类库在GitHub地址是：https://github.com/AFNetworking/AFNetworking 为了确定AFNetworking是否支持CocoaPods，可以用CocoaPods的搜索功能验证一下。在终端中输入： 1$ pod search AFNetworking 过几秒钟之后，你会在终端中看到关于AFNetworking类库的一些信息。这说明，AFNetworking是支持CocoaPods，所以我们可以利用CocoaPods将AFNetworking导入你的项目中。 首先，我们需要在我们的项目中加入CocoaPods的支持。你看到这里也许会问，CocoaPods为什么能下载AFNetworking呢，而不是下载其他类库呢？这个问题的答案是，有个文件来控制CocoaPods该下载什么。这个文件就叫做“Podfile”（注意，一定得是这个文件名，而且没有后缀）。你创建一个Podfile文件，然后在里面添加你需要下载的类库，也就是告诉CocoaPods，“某某和某某和某某某，快到碗里来！”。每个项目只需要一个Podfile文件。 好吧，废话少说，我们先创建这个神奇的PodFile。在终端中进入（cd命令）你项目所在目录，然后在当前目录下，利用vim创建Podfile，运行： 1$ vim Podfile 然后在Podfile文件中输入以下文字： 12platform :ios, &apos;7.0&apos; pod &quot;AFNetworking&quot;, &quot;~&gt; 2.0&quot; 注意，这段文字不是凭空生成的，可以在AFNetworking的github页面找到。这两句文字的意思是，当前AFNetworking支持的iOS最高版本是iOS 7.0, 要下载的AFNetworking版本是2.0。 然后保存退出。vim环境下，保存退出命令是： 1:wq 这时候，你会发现你的项目目录中，出现一个名字为Podfile的文件，而且文件内容就是你刚刚输入的内容。注意，Podfile文件应该和你的工程文件.xcodeproj在同一个目录下。 这时候，你就可以利用CocoPods下载AFNetworking类库了。还是在终端中的当前项目目录下，运行以下命令： 1$ pod install 因为是在你的项目中导入AFNetworking，这就是为什么这个命令需要你进入你的项目所在目录中运行。 运行上述命令之后，终端出现以下信息： 12345678EricmatoMacBook-Pro:CocoaPodsDemo ericwang$ pod install Analyzing dependencies Downloading dependencies Installing AFNetworking (2.0.2) Generating Pods project Integrating client project [!] From now on use `CocoaPodsDemo.xcworkspace`. 注意最后一句话，意思是：以后打开项目就用 CocoaPodsDemo.xcworkspace 打开，而不是之前的.xcodeproj文件。 你也许会郁闷，为什么会出现.xcodeproj文件呢。这正是你刚刚运行$ pod install命令产生的新文件。除了这个文件，你会发现还多了另外一个文件“Podfile.lock”和一个文件夹“Pods”。 点击 CocoaPodsDemo.xcworkspace 打开之后工程之后你会惊喜地发现，AFNetwoking已经成功导入项目了！ 现在，你就可以开始使用AFNetworking.h啦。可以稍微测试一下，在你的项目任意代码文件中输入： 天、123#import &lt;AFNetworking.h&gt; 或者 #import "AFNetworking.h" 然后编译，看看是否出错。 至此，CocoPods的第一个应用场景讲述完毕。其实过程是十分简单的。总结一下就是： 先在项目中创建Podfile，Podfile的内容是你想导入的类库。一般类库的原作者会告诉你导入该类库应该如何写Podfile； 运行命令：`$ pod install. 下面，继续讲述第二种使用场景。 场景2：如何正确编译运行一个包含CocoPods类库的项目你也许曾经遇到过（特别是新手iOS开发者）这种情况，好不容易在GitHub上找到一份代码符合自己想需求，兴冲冲下载下来，一编译，傻眼了，发现有各种各样错误。一看，原来是缺失了各种其他第三方类库。这时候莫慌，你再仔细一看，会发现你下载的代码包含了Podfile。没错，这意味着你可以用CocoaPods很方便下载所需要的类库。 下面，以代码 UAAppReviewManager 为例来说明如何正确编译运行一个包含CocoPods类库的项目。 UAAppReviewManager是一个能够让你方便地将提醒用户评分的功能加入你的应用中。当你去UAAppReviewManager的GitHub地址下载这份代码之后，打开Example工程（UAAppReviewManagerExample），编译，你会发现Xcode报告一大堆错误，基本都是说你编译的这份代码找不到某某头文件，这就意味着你要成功编译UAAppReviewManager的Example代码，必须先导入一些第三方类库。同时你会发现在UAAppReviewManagerExample文件夹下面有三个跟CocosPods相关的文件（文件夹）：Podfile，Podfile.lock和Pods 这时候，打开终端，进入UAAppReviewManagerExample所在的目录，也就是和Podfile在同一目录下，和场景1一样，输入以下命令（由于已经有Podfile，所以不需要再创建Podfile）： 1$ pod update 过几秒（也许需要十几秒，取决于你的网络状况）之后，终端出现： 12345678Analyzing dependencies Fetching podspec for `UAAppReviewManager` from `../` Downloading dependencies Installing UAAppReviewManager (0.1.6) Generating Pods project Integrating client project [!] From now on use `UAAppReviewManagerExample.xcworkspace`. 这时候，再回到UAAppReviewManagerExample文件夹看一看，会看到多了一个文件UAAppReviewManagerExample.xcworkspace： 根据终端的信息提示，你以后就需用新产生的UAAppReviewManagerExample.xcworkspace来运行这个Example代码了。 打开UAAppReviewManagerExample.xcworkspace，编译运行，成功！ 注意，这里有个小问题，如果刚刚你不是输入$ pod update，而是输入$ pod install，会发现类库导入不成功，并且终端出现下面提示： 12[!] Required version (UAAppReviewManager (from `../`)) not found for `UAAppReviewManager`. Available versions: 0.1.6 这里的意思大概是Podfile文件过期，类库有升级，但是Podfile没有更改。$ pod install只会按照Podfile的要求来请求类库，如果类库版本号有变化，那么将获取失败。但是 $ pod update会更新所有的类库，获取最新版本的类库。而且你会发现，如果用了 $ pod update，再用 $ pod install 就成功了。 那你也许会问，什么时候用 $ pod install，什么时候用 $ pod update 呢，不知道类库有没有新版本。那你每次直接用 $ pod update 或者先用 $ pod install，如果不行，再用 $ pod update。 上述都只是CocoaPods的最基本用法。要继续研究CocoaPods其他高级用法，请点击这里CocoaPods Wiki。]]></content>
      <tags>
        <tag>Swift</tag>
        <tag>iOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Swift-自动布局SnapKit]]></title>
    <url>%2F2017%2F11%2FSwift-%E8%87%AA%E5%8A%A8%E5%B8%83%E5%B1%80SnapKit%2F</url>
    <content type="text"><![CDATA[Swift自动布局SnapKit的详细使用介绍简介SnapKit，一个经典的Swift版的第三方库，专门用于项目的自动布局，目前在github上的stars就高达11346颗星，这是一个不小的数字，亦足以证明它存在的非凡意义和作用。作者认为，在iOS开发（swift）中，它是用于项目最优秀的自动布局的必选库之一。它的作者仍然是写Objective-C的第三方库Masonry的大牛 - Robert Payne，开门见山，本文将详细介绍介绍SnapKit的详细使用和安装，相信对于初入门该库的开发者或许会有一定的帮助，当然，鉴于作者能力有限，如有不足之处，欢迎指点和批评。 Snapkit的安装环境配置要求： iOS 8.0 / Mac OS X 10.11+ Xcode 8.0+ Swift 3.0+ 安装在已经安装CocoaPods的前提下， 即可以进行下列步骤。 在你的项目工程里的Podfile文件里面添加 123456789source &apos;https://github.com/CocoaPods/Specs.git&apos;platform :ios, &apos;10.0&apos;use_frameworks!target &apos;这里是你的工程名称&apos; do pod &apos;SnapKit&apos;, &apos;~&gt; 3.0&apos;end 老生常谈，运行CocoaPods的如下命令 1pod install 到此，不出意外的话，你已经将SnapKit集成到你的项目中了。然后，就开始讲怎么使用它了。 Snapkit的布局使用1、 实现一个宽高为100，居于当前视图的中心的视图布局，示例代码如下 123456789101112131415161718import UIKitimport SnapKitclass ViewController: UIViewController &#123; override func viewDidLoad() &#123; super.viewDidLoad() let testView = UIView() testView.backgroundColor = UIColor.cyan view.addSubview(testView) testView.snp.makeConstraints &#123; (make) in make.width.equalTo(100) // 宽为100 make.height.equalTo(100) // 高为100 make.center.equalTo(view) // 位于当前视图的中心 &#125; &#125;&#125; 更简洁的写法可以 1234567891011121314151617import UIKitimport SnapKitclass ViewController: UIViewController &#123; override func viewDidLoad() &#123; super.viewDidLoad() let testView = UIView() testView.backgroundColor = UIColor.cyan view.addSubview(testView) testView.snp.makeConstraints &#123; (make) in make.width.height.equalTo(100) // 链式语法直接定义宽高 make.center.equalToSuperview() // 直接在父视图居中 &#125; &#125;&#125; 效果图 2、View2位于View1内， view2位于View1的中心， 并且距离View的边距的距离都为20 123456789101112131415161718192021222324252627import UIKitimport SnapKitclass ViewController: UIViewController &#123; override func viewDidLoad() &#123; super.viewDidLoad() // 黑色视图作为父视图 let view1 = UIView() view1.frame = CGRect(x: 0, y: 0, width: 300, height: 300) view1.center = view.center view1.backgroundColor = UIColor.black view.addSubview(view1) // 测试视图 let view2 = UIView() view2.backgroundColor = UIColor.magenta view1.addSubview(view2) view2.snp.makeConstraints &#123; (make) in make.top.equalToSuperview().offset(20) // 当前视图的顶部距离父视图的顶部：20（父视图顶部+20） make.left.equalToSuperview().offset(20) // 当前视图的左边距离父视图的左边：20（父视图左边+20） make.bottom.equalToSuperview().offset(-20) // 当前视图的底部距离父视图的底部：-20（父视图底部-20） make.right.equalToSuperview().offset(-20) // 当前视图的右边距离父视图的右边：-20（父视图右边-20） &#125; &#125;&#125; 更简洁的写法 123456789101112131415161718192021222324import UIKitimport SnapKitclass ViewController: UIViewController &#123; override func viewDidLoad() &#123; super.viewDidLoad() // 黑色视图作为父视图 let view1 = UIView() view1.frame = CGRect(x: 0, y: 0, width: 300, height: 300) view1.center = view.center view1.backgroundColor = UIColor.black view.addSubview(view1) // 测试视图 let view2 = UIView() view2.backgroundColor = UIColor.magenta view1.addSubview(view2) view2.snp.makeConstraints &#123; (make) in make.edges.equalToSuperview().inset(UIEdgeInsets(top: 20, left: 20, bottom: 20, right: 20)) &#125; &#125;&#125; 效果图 3、布局一个视图view2， 让它的水平中心线小于等于另一个视图view2的左边，可以这样布局 1234567891011121314151617181920212223242526272829import UIKitimport SnapKitclass ViewController: UIViewController &#123; override func viewDidLoad() &#123; super.viewDidLoad() // 黑色视图作为父视图 let view1 = UIView() view1.frame = CGRect(x: 0, y: 0, width: 300, height: 300) view1.center = view.center view1.backgroundColor = UIColor.black view.addSubview(view1) // 测试视图 let view2 = UIView() view2.backgroundColor = UIColor.magenta view1.addSubview(view2) view2.snp.makeConstraints &#123; (make) in // 让顶部距离view1的底部为10的距离 make.top.equalTo(view1.snp.bottom).offset(10) // 设置宽、高 make.width.height.equalTo(100) // 水平中心线&lt;=view1的左边 make.centerX.lessThanOrEqualTo(view1.snp.leading) &#125; &#125;&#125; 效果图 视图的属性说明通过上面的大致简单布局我们对SnapKit有了一个基本的了解，那么， 它的布局属性是怎么来的呢？和原生的布局类有什么关联？ 下面看一个SnapKit的布局属性表 从表中，我们知道，Snapkit的布局属性都是源自于系统的NSLayoutAttribute，那么，NSLayoutAttribute是个什么呢？其实，它在swift中是一个枚举，内部列举了很多布局属性诸如top、left、leading、centerX等，Snapkit的布局属性与它们都存在一一的对应关系。 Snapkit 的 greaterThanOrEqualTo 属性如果想让视图View2的左边&gt;=父视图View1的左边， 这时我们就可以用到greaterThanOrEqualTo 12345678910111213141516171819202122232425262728293031import UIKitimport SnapKitclass ViewController: UIViewController &#123; override func viewDidLoad() &#123; super.viewDidLoad() // 黑色视图作为父视图 let view1 = UIView() view1.frame = CGRect(x: 0, y: 0, width: 300, height: 300) view1.center = view.center view1.backgroundColor = UIColor.black view.addSubview(view1) // 测试视图 let view2 = UIView() view2.backgroundColor = UIColor.magenta view1.addSubview(view2) view2.snp.makeConstraints &#123; (make) in // 让顶部距离view1的底部为10的距离 make.top.equalTo(view1.snp.bottom).offset(10) // 设置宽、高 make.width.height.equalTo(100) // 水平中心线&lt;=view1的左边 make.left.greaterThanOrEqualTo(view1) // 或者, 和上面一行代码一样的效果// make.left.greaterThanOrEqualTo(view1.snp.left) &#125; &#125;&#125; 效果图 其实，greaterThanOrEqualTo这个属性有点多余，比如上面这行代码 make.left.greaterThanOrEqualTo(view1) ， 我们可以换成 make.left.equalToSuperview()或make.left.equalTo(view1.snp.left)， 效果是一样的，也就是说，一般情况下 &gt;= 或 &lt;= 我们都可以直接用equalTo来代替！ SnapKit的greaterThanOrEqualTo和lessThanOrEqualTo联合使用当我们想要让某个视图的width或height大于等于某个特定的值，小于等于某个特定的值的时候，一般而言，Snapkit会以greaterThanOrEqualTo为准，这里举一个width的例子，为了方便，这里指贴出了viewDidLoad中的代码（其他没必要） 1234567891011121314151617// 黑色视图作为父视图let view1 = UIView()view1.frame = CGRect(x: 0, y: 0, width: 300, height: 300)view1.center = view.centerview1.backgroundColor = UIColor.blackview.addSubview(view1)// 测试视图let view2 = UIView()view2.backgroundColor = UIColor.magentaview1.addSubview(view2)view2.snp.makeConstraints &#123; (make) in make.width.lessThanOrEqualTo(300) make.width.greaterThanOrEqualTo(200) make.height.equalTo(100) make.center.equalToSuperview()&#125; 接着，我们来看一下效果图 很明显，最后的宽度是以make.width.greaterThanOrEqualTo(200)为标准的，也可以这样的，在同时使用两者的情况下，greaterThanOrEqualTo的优先级略比lessThanOrEqualTo的优先级高。值得一提的是， 在上面的例子中，如果我们只设置make.width.lessThanOrEqualTo(300)，那么view2是不会显示出来的，因为view2不知道你要表达的是要显示多少，小于等于300，到底是100还是200呢？(这里指针对width和height）所以它不能确定这个约束的值，但是，如果我们单独设置make.width.greaterThanOrEqualTo(200)，那么就和上面的效果一样，因为它会以200为标准布局约束！ lessThanOrEqualTo的用于上、下、左、右如果我们想要视图view2的左边 &lt;= view1.left + 10, 那么就可以直接用到lessThanOrEqualTo布局了，看下面这个例子 1234567891011121314151617// 黑色视图作为父视图let view1 = UIView()view1.frame = CGRect(x: 0, y: 0, width: 300, height: 300)view1.center = view.centerview1.backgroundColor = UIColor.blackview.addSubview(view1)// 测试视图let view2 = UIView()view2.backgroundColor = UIColor.magentaview1.addSubview(view2)view2.snp.makeConstraints &#123; (make) in make.left.lessThanOrEqualTo(20) // &lt;= 父视图的左边+20 make.right.equalTo(-40) // = 父视图的右边-40 make.height.equalTo(100) make.center.equalToSuperview()&#125; 效果图 Snapkit布局的灵活性 Snapkit布局灵活性很强， 我们看下面的例子, 他们的效果是一样的 123make.left.equalToSuperview().offset(10)make.left.equalTo(10)make.left.equalTo(view1.snp.left).offset(10) 设置视图的大小（width，height）,他们效果是一样的 123456make.width.height.equalTo(100)或make.width.equalTo(100)make.height.equalTo(100)或make.size.equalTo(CGSize(width: 100, height: 100)) 优先级(priority) 我们来看一下Snapkit的优先级设置， 优先级都是附加在约束链的末尾处，看下面的使用方法 1234567891011121314151617// 黑色视图作为父视图let view1 = UIView()view1.frame = CGRect(x: 0, y: 0, width: 300, height: 300)view1.center = view.centerview1.backgroundColor = UIColor.blackview.addSubview(view1)// 测试视图let view2 = UIView()view2.backgroundColor = UIColor.magentaview1.addSubview(view2)view2.snp.makeConstraints &#123; (make) in make.width.equalTo(100).priority(666) make.width.equalTo(250).priority(999) make.height.equalTo(111) make.center.equalToSuperview()&#125; 效果图 从上面我们可以知道, 我们设置了两个优先级：make.width.equalTo(100).priority(666) 和 make.width.equalTo(250).priority(999)， 那运行结果是一个哪个为准呢？显然是以优先级为 999的为准，因为 priority(999)&gt;priotity(666)， 所以在使用Snapkit的过程中，有时我们可以使用优先级priority来设置我们的约束， 另外，值得一提的是，SnapKit的优先级最大值只能是 1000， 如果优先级的数值超过1000，则运行时就会Crash！这里要尤其注意。 更新约束（引用约束） 我们可以通过保存某一个约束布局来更新相应的约束，或者保存一组约束布局到一个数组中更新约束， 具体看下面代码 12345678910111213141516171819202122232425262728293031323334// 保存约束（引用约束）var updateConstraint: Constraint?override func viewDidLoad() &#123; super.viewDidLoad() // 黑色视图作为父视图 let view1 = UIView() view1.frame = CGRect(x: 0, y: 0, width: 300, height: 300) view1.center = view.center view1.backgroundColor = UIColor.black view.addSubview(view1) // 测试视图 let view2 = UIView() view2.backgroundColor = UIColor.magenta view1.addSubview(view2) view2.snp.makeConstraints &#123; (make) in make.width.height.equalTo(100) // 宽高为100 self.updateConstraint = make.top.left.equalTo(10).constraint // 距离父视图上、左为10 &#125; let updateButton = UIButton(type: .custom) updateButton.backgroundColor = UIColor.brown updateButton.frame = CGRect(x: 100, y: 80, width: 50, height: 30) updateButton.setTitle("更新", for: .normal) updateButton.addTarget(self, action: #selector(updateConstraintMethod), for: .touchUpInside) view.addSubview(updateButton)&#125;// 更新约束func updateConstraintMethod() &#123; self.updateConstraint?.update(offset: 50) // 更新距离父视图上、左为50&#125; 更新约束(snp.updateConstraints) 说起这个updateConstraints, 我也懵逼过，那么它到底有何作用呢？又怎么用呢？它和一开始就使用的makeConstraints又有什么明确的区别呢？请继续往下看 说明1：如果你这是更新某个约束或某几个约束的常量值，你就可以使用updateConstraints而不是makeConstraints。 说明2：这个也是苹果推荐用来添加或更新约束的方式 说明3：这个方法可以调用多次，会相应setNeedsUpdateConstraints, 在控制器中，可以写在override func updateViewConstraints()方法里面（当然也可以写在你想要什么时候更新的点击事件里面） 12345678910111213141516171819202122232425262728293031323334import UIKitimport SnapKitclass ViewController: UIViewController &#123; lazy var blackView = UIView() override func viewDidLoad() &#123; super.viewDidLoad() blackView.backgroundColor = UIColor.black view.addSubview(blackView) blackView.snp.makeConstraints &#123; (make) in // 四个约束确定位置和大小 make.width.equalTo(100) make.height.equalTo(150) make.top.equalTo(10) make.centerX.equalToSuperview() &#125; &#125; override func updateViewConstraints() &#123; blackView.snp.updateConstraints &#123; (make) in // 更新距离父视图顶部的约束（从 10 ---&gt; 300 ） make.top.equalTo(300) &#125; // 根据苹果，调用父类应该放在末尾 super.updateViewConstraints() &#125;&#125; 注意: 从上面的代码中我们很明确地知道， blackView通过width、height、top、centerX确定了它本身的大小和位置， 但是， 在 run 出来之后，它的top改变了距离， 从 10 变成了 300，其他三个约束保持不变， 见下图效果： 显而易见， 除了top约束， 其他都没有改变！ 也就是说，约束被更新（相当于系统升级一样，是一个道理） 现在，我们通过UIButton的点击事件来证明一下制作约束makeConstraints和updateConstraints具体的区别在哪里？ 1234567891011121314151617181920212223242526272829303132lazy var blackView = UIView()override func viewDidLoad() &#123; super.viewDidLoad() blackView.backgroundColor = UIColor.black view.addSubview(blackView) blackView.snp.makeConstraints &#123; (make) in make.width.equalTo(100) make.height.equalTo(150) make.top.equalTo(50) make.centerX.equalToSuperview() &#125; let btn = UIButton(type: .custom) btn.backgroundColor = UIColor.brown btn.frame = CGRect(x: 100, y: 200, width: 60, height: 30) btn.addTarget(self, action: #selector(buttonAction), for: .touchUpInside) view.addSubview(btn)&#125;// 点击更新/制作约束func buttonAction() &#123; blackView.snp.makeConstraints &#123; (make) in make.width.height.equalTo(20) make.top.equalTo(300) &#125;&#125; 先看效果图 点击事件发生前(图1）： 点击事件发生后（图2） 图3 图4 上面，我们知道，视图 blackView一开始是由四个约束确定位置和大小，在点击事情响应后，我们又给 blackView 制作（记住，是制作，而不是重做，两者有明确的区别）了3个约束，分别是 width、height、top, 那么这样做问题出现在哪里呢？ 第一， 点击事情发生前（图1）， 在点击事件发生后（见图2）， 我们发现，blackView的width、height约束改变了，但是 top却没有改变，还是原来的距离父视图顶部 50 的距离， 原因在于，我们在原来的约束基础上又添加了多余的约束， 也就是说，约束从4个变成了7个（见图3左边constraints）， 这样就产生了约束不明确，进而导致snapkit的警告（见图4）， 这样布局显然是不可取的，在项目中这样做极其危险，甚至可能会导致异常奔溃！！！！ 现在， 我们该将点击事件中的约束布局从makeConstraints改变成updateConstraints来试试两者有什么区别(下面只添加了点击事件的代码，其他事重复的就不多此一举了） 12345678func buttonAction() &#123; // 注意这里是updateConstraints， 而不是makeConstraints blackView.snp.updateConstraints &#123; (make) in make.width.height.equalTo(20) make.top.equalTo(300) &#125; print(&quot;这里试试snapkit有没有报警告&quot;)&#125; 接着看点击事件后的效果图 图5 图6 图7 发现没有，在将makeConstraints改变成updateConstraints之后，约束还是4个，snapkit没有报警告，点击事件中的width、height、top全部起了作用，而这就是两者的本质区别：makeConstraints是制作约束，在原来的基础上再添加另外的约束，也就是画蛇添足，约束增加，视图布局就有不确定性，从而有些约束起作用，有些不起作用（如上面的top），snapkit报警告！！！而updateConstraints是更新约束，改变原有约束，约束不会增加，没经过updateConstraints处理的保持原有约束，经过处理就更新约束，约束不会减少，snapkit不会产生警告，这是正常标准的更新约束的正确方式！！！ 重做约束（remakeConstraints） 重做约束的本质就是：去掉已有的所有约束， 重新做约束，记住，是做约束， 也就是说， 使用了remakeConstraints后，重做的约束必须要能确定相应视图的大小和位置, 之前makeConstraints的约束已经不会存在了，完全销毁！！！ 1234567891011// 点击更新/制作约束func buttonAction() &#123; // 注意这里是 remakeConstraints blackView.snp.remakeConstraints &#123; (make) in make.width.height.equalTo(20) make.top.equalTo(300) &#125; print("这里试试snapkit有没有报警告")&#125; 效果图 图（1） 图（2） 图（3） 我们看到， blackView重做了约束， 之前的约束不起任何作用，由于它在重做约束后只有 3 个约束分别是 width、height、top, 但是这里有一个问题，就是这 3 个约束只能确定大小，无法确定视图的位置， 所以在水平方向上或者左右缺少一个布局条件， 故 blackView整体视图的x紧靠左边（默认）！ 另外我们发现， 在图（3）中，右上角出现了一个感叹号“！”, 那是因为告诉你缺少了一个约束条件：x-xcode-debug-views://7f81fcbc7900: runtime: Layout Issues: Horizontal position is ambiguous for UIView. 小结通过以上学习，我们或深或浅地学习了布局三方库SnapKit的使用， 我相信，只要将上述布局会使用，并且懂得布局的原则和道理，基本上就可以“高枕无忧”了，至于涉及动态布局、动画布局等知识，后续有时间会更新文档。]]></content>
      <tags>
        <tag>Swift library</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[为什么 Kotlin 比你们用的那些垃圾语言都好]]></title>
    <url>%2F2017%2F11%2F%E4%B8%BA%E4%BB%80%E4%B9%88Kotlin-%E6%AF%94%E4%BD%A0%E4%BB%AC%E7%94%A8%E7%9A%84%E9%82%A3%E4%BA%9B%E5%9E%83%E5%9C%BE%E8%AF%AD%E8%A8%80%E9%83%BD%E5%A5%BD%2F</url>
    <content type="text"><![CDATA[5月18日，安卓团队在谷歌 I/O 2017 大会上宣布 Kotlin 成为官方头等支持语言。这条爆炸性资讯在当天就是 Hacker News 首页热门讨论，与此同时，谷歌技术大牛 Steve Yegge 也写了一篇关于 Kotlin 的使用体会总结文章，同样也在首页热门，并引发大量讨论（点击进入原文） ​ （Steve Yegge ） 为什么说 Kotlin 比你们用的那些垃圾语言都好哈，这个标题党的题目让你点进来看了吧。不要奇怪，现在标题党在网上很普遍的。而且这篇文章给出的回答，肯定能震撼到你。 说真的，其实我不想去攻击你们的语言信仰……至少不会“大大地”想。毕竟你喜欢的语言大放异彩的时期，可能要追溯到冰川时代了，对不？如果你喜欢的语言到今天还没有死，那只能说明这门语言在逐渐地改进和更新，保持与时俱进。 但改进的速度呢？好吧……假设你现在用的语言碰巧是 Java，并且你也沉溺于 Java 曾经是一门非常优秀的语言的想法，那么你就完蛋了。而且是早就完蛋了。尽管人类都不太喜欢思考终极命运问题，但是相比于在 20 多年前刚刚问世，Java 8 仅仅是做了部分语言特性的替换，对此你禁不住要想：“我真的要和这种语言来共度过的余生么？还是说 Java 也就只能这样了？” 因为终于要开始做 Android 开发了，我把各种老旧的语言问题又过了一遍。我写过一个老游戏 Wyvern，这个游戏已经有一个 iOS 版本了，最近我决定再搞一个 Android 版本。我从来没料到计算机语言会折腾到让我“思考人生”（例如“我这是他娘的在浪费生命么？”）如果你写过 Android 程序的话，你就知道在 Android 领域，语言的问题是会让你相当难熬的。 我第一次尝试写 Android 程序是在去年夏天，我的个老天爷，那感觉简直糟透了。其实是有人警告过我的。他们都说：“那些 API 可是很难搞啊。”而我却不听劝。一意孤行。 我想：这些玩意儿能糟糕到哪儿去呢？反正不就是 Java 么？ 历史代码的灾难真是很不走运——因为很复杂的历史原因，并且也没人在意——造成 Android 的核心 API 实在是糟糕透顶。我是说：真的很糟，真的很糟，真的很糟。你只能关掉参考书，深呼吸，然后出去猛喝咖啡来压压惊。人们之前给我的告诫看来是完全正确的。 Android API 库就是一个百宝箱。很多 API 真的是非常好用。我可以说，很多在 iOS 开发里非常难搞的事情在 Android 里面却很容易。Product flavors、Downloads 服务、findViewById() 方法、Preferences activity 等等，这些都是很好的例子。有太多 Android 里面有的东西在 iOS 里面是诶有的，所以在 iOS 里面你总能看到：开发者自己实现的恶心的和优雅的应用库并存。 但是！注意左边是一个大写加粗的但是！在写 Android 程序的时候，人们只关注那些不好的 API，就像你开车时候只会数路上遇到了几个红灯一样，绿灯的数量是没人关心的。因为人们只会通过红灯的数量来评价路途是否通顺。 Android 确实有几个很糟糕的“红灯”API。例如 Fragments，这就是在 Andoird “红灯” API 中的招牌 API。这个 API 的整个生命周期的糟糕程度达到了令人发指的地步，好吧其实 Activities 和 Fragments 都是如此。说句不中听的，iOS 反而却没有这么糟糕的API。去年夏天我试了试这些API，它们是如此之糟糕以至于我当时就放弃了。我算是彻底服了。去它的，我还是以后找个人来帮我写这些程序吧。 接下来的一年半，我就没再碰过 Android 编程。 来自俄罗斯的救星我一直听说，有一种新语言叫做 Kotlin，可以用来写基于 JVM 或者 Android 程序。发明这种语言的不是别国，正是战斗的民族俄罗斯。更具体一点儿，它是由 JetBrains 开发。JetBrains 可是世界知名的 IDE 开发商，代表作是 Intellij IDEA，还有他们那可爱而且大名鼎鼎的橘色，绿色，紫色和黑色混合的暗色“Darcula”主题。 图：一个千年老妖按捺不住对 Java 8 的兴奋 那么为什么要给这种语言起名叫 Kotlin 呢？好吧，有一种说法是因为 Java 的第一个字母是“J”，而 Kotlin 则用了Java 的下一个字母“K”作为开头。除此之外，有人还猜想（这种猜想可能来自加州大学伯克利分校），“Kotlin”这个名字的灵感还来源于“克里姆林宫”，“赫鲁晓夫”以及“克格勃”。这些都是前苏联的骄傲，所以他们就用了一个前苏联军事基地的名字“Kotlin”来命名这种语言。总之这个名字不错，而且你会习惯它的。 伯乐在线补充：Steve Yegge 在前文关于 Kotlin 的名字来源，应该错了。在他自己原文评论中，也有网友指出了。 正确的应该是：① JetBrains 是一家注册地在捷克布拉格的公司，在全球共有 6 个办公点：布拉格、圣彼得堡、莫斯科、波士顿、慕尼黑和新西伯利亚。但主要管理层和开发者是在圣彼得堡。② 芬兰湾中有个岛就是「Kotlin/科特林」，在圣彼得堡以西 32 公里。 我发现去年业界关于 Kotlin 只是有不少“嘀咕（buzz）”。注意，只是“嘀咕”，不是天花乱坠地吹牛宣传。人们只是低调地“嘀咕”着。好吧，总之，我当时看了一下，然后就觉得这个语言和我过去 15 年看过的 50 ~ 100 种计算机语言一样，这也是一门可以替代 Java 的语言，当然，我认为任何理性的语言都能替代 Java。 对 Kotlin 的第一印象我第一次看到 Kotlin 的时候，真心觉得这种语言不可能在现实生活中用到，真的是一点可能性都没有。其实我也就是走马观花。我的第一印象？这个语言也没什么大问题。它很简洁，也具有先进的特性。如果说它时髦也行，因为它几乎囊括了计算机语言设计上的所有最新潮流。不过这也没什么大不了，因为很多语言也都满足这一点。比如，Rust。Rust 也是一门健壮的，名字起得很好的，但是没什么人用的语言。 Kotlin 给我的一种奇怪的感觉是“似曾相识”，后来我才反应过来，原来这是因为它和 Swift 很像。我之所以没有马上反应过来，是因为我的 iOS 程序因为历史代码的原因不得不用 Objective-C 而不是 Swift 来写。当然现在我也弄明白了：其实 Kotlin 的历史比 Swift 要悠久几年，所以正确的说法应该是：Swift 和 Kotlin 很像。 不过即便如此我当时也没准备用这种语言干活。Kotlin 对我来说确实是一种语法优雅的语言，但是我觉得我对这门语言还没有掌握到足够的程度，以至于让我可以用它来应付残酷的现实工作。 从 Java 叛逃到 Kotlin我不太记得我是具体怎么爱上 Kotlin 的了。但是我敢肯定的是这绝对不是有意为之。 我努力回忆了一下，事情是这样的，我做的那个游戏的玩家跟我说了好久，让我开发一个 Android 版本。这个游戏是 12 月份在 Apple Store 上架的，然后几周之内，大量粉丝就跟我说，他们是 Andorid 用户，所以没法玩到这个游戏。所以，尽管我已经“发誓”再也不碰Android 编程了，但是用户就是上帝，所以我又开始尝试了。不过这一次要换个玩儿法——不能再把胃口坏在 Android 的 Java 语言上了。我需要有个现成的框架，或者什么类似的东西，来让工作变得简单一点儿。 在 1 月中旬，我做了一个粗略评估，然后就决定用 Kotlin 来开发了，Kotlin 当时可同时支持 Dalvik 和 Art 两种 Android 虚拟机。我觉得我的评估是基于以下几个原因： \1. Kotlin 已经小有名气； \2. 当时我写 iOS 版的时候就想用 Swift（但是没用成）； \3. Kotlin有一种挺不错的 Android DSL 叫做 Anko，这勾起了我的兴趣，虽然最后我并没有真的用到它。 所以我就用 Kotlin 开始做了。在接下来的 4-5 周内，我用 Kotlin 重写了游戏的服务平台。要知道这个平台之前已经有 20 多年历史了。用了一个月的 Kotlin，我就被完全征服了。我不是要说 Scala 或者其他语言的坏话，但是对我这种普通码农来说，Koltin 是完美的。我的要求不高，给口饭吃就行，知道不？Scala 固然很好，但是它好得过头了，就像牛蛙\牛脑\松露蜗牛这些高档菜那么好。要知道我就是个蓝领，Clojure、Scala 这类的语言对我来说太高大上了。 我大约花了 3 天时间来学习 Kotlin 的各种语法，然后就开始正式编程了，虽然我还是很不熟练，但是我知道这种语言和 IDE 工具足以让我解决各种麻烦。 当我对这种语言稍微熟悉了一些以后，我就知道，我应该不会再去爱上另外一种语言了，因为 Kotlin 实在是太迷人了。你在代码写出来的东西让你觉得很酷。当然我以前用其他的语言编程的时候也体验过类似的感觉，但是那些语言的学习曲线一般都非常陡峭。Kotlin呢，它就是大救星：当 Java 程序员为了 Java 8 弄出来的一大堆新概念挠头的时候，Kotlin 出现了。Kotlin 能实现 Java 8 的各种新特性，并且通过对 coroutines 的支持，其实能实现更强大的功能，而且语法表现力更简洁。Java 8 确实也能表达很有意思的逻辑，但是很繁琐，感觉就像让你说话之前要先给你嘴里塞沙子。 我想 Kotlin 上手很容易的原因太显而易见了，要归功于它的 IDE 支持。现在几乎所有的 JVM 语言或者 Android 语言的 IDE 支持都是由社区的几个志愿者在维护（当然 Java 除外）。而 Kotlin 则是来自世界级的 IDE 厂商（Jetbrains），所以 Kotlin 打一开始就是自带 IDE 支持的。有多少语言能做到从发明伊始就能有 IDE 支持呢？编程语言的进化历程一般做不到这一点。况且有的编程语言从一开始就是要避开 IDE 这个因素的（Hi！Rob）另外一个能一开始就做到 IDE 支持的语言就是 C#，当然 C# 毫无疑问是全世界最好的编程语言之一。 伯乐在线译注：上面这段中的 Rob，应该是指 Go 语言的发明者 Rob Pike，作者在这里也许是暗讽 Go 语言从发明到现在都没有一个靠谱的 IDE 支持吧。 作为一个自带 IDE 支持的语言，你在 Kotlin buffer 敲代码的时候，打字基本对就可以了。IDE 会帮你补全你没写完的部分。你知道吗，你甚至可以把Java代码复制到IDE里面，然后 IDE 会帮你自动转换成Kotlin代码。如果你觉得 Java 的 IDE 都还不错，那么我可以很荣幸地告诉你，Kotlin IDE 会把这种“不错”推进到前所未有的地步。甚至有一个前微软工程师跟我说：“我本以为微软的 Visual Studio 是 IDE 界的标杆，是不可超越的。但是我觉得 IntelliJ IDEA 的确要更好。”在我看来，因为我对 Visual Studio 不熟悉，所以我在这里只是引用他说的话。不过我认为 IntelliJ IDEA 至少和 VS 是同等水平。 诚然，在现实工作中我还是要经常切换到 Emacs 的。IntelliJ 在你打字很快的时候还是有点儿反应不过来。如果你打字总是只打一半儿的话，那么自动补全动能的运行压力还是很大。况且对纯文本的处理也很糟糕，这是所有 IDE 的通病。所以 IDE 和 Emacs 你都是需要用到的。不幸的是，目前 Emcacs 对 Kotlin 的支持现在也就那么回事儿，不过相信以后会越来越好。我现在反正就是在 Emacs 和 IntelliJ 之间来回切换。目前还算是 OK。 就是这样了。我曾经花了大约 10 年的时间，来找一种语言来取代 Java。我真的找得很努力很辛苦。讽刺的是，在我放弃了以后，这种东西居然出来了。去看看吧。Kudos 对 JetBrains 来说，是一个惊艳的成就。 Android：Kotlin 的杀手锏这年头新生编程语言几乎很难产生什么巨大影响力。不是说现在没有新语言产生了，相反是每年都有质量不错的新语言产生，但是然并卵，没人用！要给“不可能”划定界限很难。但是计算机语言的市场已经非常饱和了。如果要让一个新的语言能够大火（而且这个规律在过去 10 到 20 年都成立），那么这个语言就必须有一个“杀手级”的应用。这门语言需要绑定一个平台，让大家都非常迫切地区使用这个平台，这才能促进大家学习这门语言以便在这个平台上编程。 就目前看来，我们上面所说的杀手级应用——也就是我们上面扯了这么多的东西——却是 Android 恶心的 API。每当你顺着 Android 路线往下走，一遇到 API 就会卡壳，这只会让你去诅咒 Android 这个平台。Android 不论有多少优秀的 API 都不管用，重要的是，Android 糟糕的 API 太多了，所以你不得不停下来去找”现成”的办法（solution）。 不过兄弟，Android 里面解决问题的“现成办法”可是不少。对于新手来说，有一大堆 Java annotation processors可用，这就为语言的问题埋下伏笔。更不要提一堆迷你的框架（比如 Lyft 的 Scoop）。还有那些和 Android（Java）完全独立的框架：React Native、Cordova、Xamarin、Flutter等等。 如果以上说的技术你都不喜欢，那么你还可以从语言的角度来解决问题。当然，那些完全独立的框架是基于特定语言的，而并不是Java。 Kotlin 的竞争优势在于它并不是完全隔离于 Java 语言。它基本上是 100% 可与 Java 相互翻译转换的。这很像C++ 与 C 的关系一样（但它们做不到 100% ）。Kotlin 也是在不断进化的。所以你可以直接把你写的 Kotlin 代码扔到 Android 工程中，连目录都不用改，然后程序就能正常运行了，方便得眼睛都不用眨一下。 其他种类的 Android 平台都倾向于迫使你去学习一种全新的语言以及对应的平台，其编程范式，理念和特性都各不相同。Kotlin 则是让你直接写出 Android 可运行的类，就跟其他 Android 程序员用 Java 写出来的一样。其实其底层的 API 都是一样的，但是 Kotlin 组织得要好很多。 还记得我去年夏天把 Android 编程书扔了然后再也不打算看了么。现在 Kotlin 则让我感觉：Android 编程是快乐的？我甚至觉得可能 Android 那些糟糕的 API 很可能并不是那么糟，只是 Java 把它搞得太恶心了而已。 Kotlin 致力于让大家绕过 Android API 那些恶心的东西，并且能让你充分发挥你的经验，这一点甚至比 iOS 做得还要好。好吧，至少来说比 Objective-C 做得好，因为我觉得 Swift 肯定也不会差。知道为什么吗？因为 Swift 和 Kotlin 很像啊。 我特别喜欢 Kotlin 的地方有哪些？嗯，这个话题其实要细说就很大了，我觉得我最好再开一篇文章来写这个。这里我就提一下那些高级（high-level）且共性的点。 Kotlin 很像 Java。它长得不像 Clojure 或者 Scala 那么奇怪（承认现实把，这两种语言就是挺奇怪的）。所以你学 Kotlin 应该很快。这门语言显然就是写给 Java 开发者来用的。 它比 Java 更安全。Java 很多需要 annotation processors 来做的事情在 Kotlin 里则是内置的，例如 overriding，nullability等等。而且 Kotlin 对数值转换的规则也更安全，虽然我不太喜欢 Kotlin 的处理方式，但是我还是很感谢这门语言强制我去思考我的数值表现形式。 Kotlin 和 Java 是可以互译的。真的是指无缝互译。我见过很多 JVM 语言最后挂掉，就是因为其不支持子类继承机制。我不知道什么时候就会用到静态内部类，非静态内部类，或者什么破玩意儿类。Kotlin 在设计时就把和Java互译的属性放在第一位，也就是说，把 Java 翻译到 Kotlin 可以逐渐进行，一次可以直接转换一个文件。 Kotlin 很简洁。你要知道我也算是个高尔夫球手，所以我实话实说。如果在一切都相同的情况下，我更喜欢短的程序，只要它写的逻辑清楚。Kotlin 对我来说就像是打了一轮好局。平均下来我发现 Kotlin 的代码长度比相同逻辑的 Jython 代码短了 5%-10%（这可是我用某种“黄金标准”测出来的），而且还能保证程序的可读性和类型安全。 Kotlin 更贴近实际。Kotlin 支持在一个文件里定义多个类，支持一等方法，操作符重载，扩展方法，类型别名，字符串模板，还有一堆看上去没什么新意的语言特性它都支持。而我就是不明白为什么 Java 什么都不支持，连人们需要的语言特性它都不做。 Kotlin 进化很快。例如刚刚宣布启动的对 coroutine 的支持，将会成为提供 asyn/await， geneator 以及所有其他无锁并发特性的基础设施。 Kotlin 很擅长“拿来主义”。Kotlin 经常从其他的计算机语言设计中抄点子，并且也毫不避讳。他们说：“我们很喜欢 C# 的处理方式，所以我们就自己照着撸了一个。” Kotlin 支持 DSL。DSL 不到深思熟虑万不得已的话千万不要引入，但是不得不承认 DSL 威力巨大。例如你看 Gradle 的 DSL 和 Maven 比，在典型的 Maven 项目里，配置代码肯定要超过上千行。所以 Kotlin 是来给你降工作压力的。 Kotlin 的 IDE 是在是太棒了。刚才不久我才在 Emacs 里写程序文件，结果 Emacs 报了一对错。而我把同样的代码拷贝到 IntelliJ 里面，然后按 Alt-Enter 逐一自动修复了 50 多条，然后所有的错误就都搞定了。这真是帮了大忙啊。 ​ Kotlin 很有趣。我跟你们说，Kotlin 就是有趣。也许这是我发自潜意识地在做广告。Kolint 的关键字和方法名都很有意思。Kotlin 把我从一个只会死编程的码农转变为了一个计算机语言的爱好者。 总之，你就这么想：我收拾东西搬家，然后碰到了邻居 Kotlin。我之前也算见过的一堆计算机语言，但是只有 Kotlin，能够让我在那么短的时间内重写我的游戏服务器代码。而我现在则是在用 Kotlin 重写我之前写过的一切。 我也知道还有好多其他的程序员也对 Kotlin 感觉非常好，打算成为 Kotlin 程序员。其中大部分的人应该在 1-2 年之内水平就能超过我了。我们私下里谈论过，互相都说“Kotlin 让编程感觉美好的感觉又回来了。”还不错，再我们尚未对编程全部失去兴趣之前，Kotlin 来了。就仿佛你只要把语言的语法学会了。这回把你带回到那种第一次学编程的感觉，无论写什么都觉得自己很牛逼。 再一次，向 JetBrains 致敬。他们对计算机语言做出了巨大的贡献！我脱帽致敬。 那么 Kotlin 比你用的任何其他编程语言都好吗？我想对我来说是的。因为，如果你碰巧是在用 Java 的话。如果你一整天就是泡在椅子面前写 Java，那么你会发现 Kotlin 简直就是一股清流。所以也让我知道你们是怎么想的吧。 免责声明：本文只是阐述Steve Yegge对 Android 开发的观点，并不代表Google或者 JetBrains 的观点。]]></content>
      <tags>
        <tag>Kotlin</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C89标准和C99标准C11标准的区别（简单总结版&&较为完整版）]]></title>
    <url>%2F2017%2F11%2FC89%E6%A0%87%E5%87%86%E5%92%8CC99%E6%A0%87%E5%87%86C11%E6%A0%87%E5%87%86%E7%9A%84%E5%8C%BA%E5%88%AB%2F</url>
    <content type="text"><![CDATA[较详细的阐述了c89/c99/c11的一些变化 ###较简单的总结 （1）对数组的增强 ​ 可变长数组 C99中,程序员声明数组时,数组的维数可以由任一有效的整型表达式确定,包括只在运行时才能确定其值的表达式,这类数组就叫做可变长数组,但是只有局部数组才可以是变长的.可变长数组的维数在数组生存期内是不变的,也就是说,可变长数组不是动态的.可以变化的只是数组的大小.可以使用*来定义不确定长的可变长数组。 ​ 数组声明中的类型修饰符 在C99中，如果需要使用数组作为函数变元，可以在数组声明的方括号内使用static关键字，这相当于告诉编译程序，变元所指向的数组将至少包含指定的元素个数。也可以在数组声明的方括号内使用restrict,volatile,const关键字，但只用于函数变元。如果使用restrict，指针是初始访问该对象的惟一途径。如果使用const，指针始终指向同一个数组。使用volatile没有任何意义。 （2）单行注释 引入了单行注释标记 “//“ , 可以象C++一样使用这种注释了。 （3）分散代码与声明 预处理程序的修改 （4）for语句内的变量声明 C99中，程序员可以在for语句的初始化部分定义一个或多个变量，这些变量的作用域仅于本for语句所控制的循环体内。比如：代码:for(int i=0; i&lt;10; i++){ // do someting …} （5）复合赋值 C99中，复合赋值中，可以指定对象类型的数组、结构或联合表达式。当使用复合赋值时，应在括弧内指定类型，后跟由花括号围起来的初始化列表；若类型为数组，则不能指定数组的大小。建成的对象是未命名的。 例： double *fp = (double[]) {1.1, 2.2, 3.3}; 该语句用于建立一个指向double的指针fp，且该指针指向这个3元素数组的第一个元素。 在文件域内建立的复合赋值只在程序的整个生存期内有效。在模块内建立的复合赋值是局部对象，在退出模块后不再存在。 (6)指定的初始化符 C99中，该特性对经常使用稀疏数组的程序员十分有用。指定的初始化符通常有两种用法：用于数组，以及用于结构和联合。用于数组的格式：[index] = vol; 其中，index表示数组的下标，vol表示本数组元素的初始化值。 例如： int x[10] = {[0] = 10, [5] = 30}; 其中只有x[0]和x[5]得到了初始化．用于结构或联合的格式如下： member-name(成员名称) 对结构进行指定的初始化时，允许采用简单的方法对结构中的指定成员进行初始化。 例如： struct example{ int k, m, n; } object = {m = 10,n = 200}; 其中，没有初始化k。对结构成员进行初始化的顺序没有限制 (7)printf()和scanf()函数系列的增强 C99中printf()和scanf()函数系列引进了处理long long int和unsigned long long int数据类型的特性。long long int 类型的格式修饰符是ll。在printf()和scanf()函数中，ll适用于d, i, o, u 和x格式说明符。另外，C99还引进了hh修饰符。当使用d, i, o, u和x格式说明符时，hh用于指定char型变元。ll和hh修饰符均可以用于n说明符。 格式修饰符a和A用在printf()函数中时，结果将会输出十六进制的浮点数。 格式如下：[-]0xh, hhhhp + d 使用A格式修饰符时，x和p必须是大写。A和a格式修饰符也可以用在scanf()函数中，用于读取浮点数。调用printf()函数时，允许在%f说明符前加上l修饰符，即%lf，但不起作用。 (8)C99新增的库 C89中标准的头文件 定义宏assert() 字符处理 错误报告 定义与实现相关的浮点值勤 定义与实现相关的各种极限值 支持函数setlocale() 数学函数库使用的各种定义 支持非局部跳转 定义信号值 支持可变长度的变元列表 定义常用常数 支持文件输入和输出 其他各种声明 支持串函数 支持系统时间函数 C99新增的头文件和库 支持复数算法 给出对浮点状态标记和浮点环境的其他方面的访问 定义标准的、可移植的整型类型集合。也支持处理最大宽度整数的函数 首先在此1995年第一次修订时引进，用于定义对应各种运算符的宏 支持布尔数据类型类型。定义宏bool，以便兼容于C++ 定义标准的、可移植的整型类型集合。该文件包含在中 定义一般类型的浮点宏 首先在1995年第一次修订时引进，用于支持多字节和宽字节函数 首先在1995年第一次修订时引进，用于支持多字节和宽字节分类函数** (10)func预定义标识符 用于指出func所存放的函数名，类似于字符串赋值。** (11) 其它特性的改动 放宽的转换限制 限制 C89标准 C99标准 数据块的嵌套层数 15 127 条件语句的嵌套层数 8 63 内部标识符中的有效字符个数 31 63 外部标识符中的有效字符个数 6 31 结构或联合中的成员个数 127 1023 函数调用中的参数个数 31 127 不再支持隐含式的int规则 删除了隐含式函数声明 对返回值的约束 C99中,非空类型函数必须使用带返回值的return语句. 扩展的整数类型 扩展类型 含义 int16_t 整数长度为精确16位 int_least16_t 整数长度为至少16位 int_fast32_t 最稳固的整数类型,其长度为至少32位 intmax_t 最大整数类型 uintmax_t 最大无符号整数类型 对整数类型提升规则的改进 C89中,表达式中类型为char,short int或int的值可以提升为int或unsigned int类型. C99中,每种整数类型都有一个级别.例如:long long int 的级别高于int, int的级别高于char等.在表达式中,其级别低于int或unsigned int的任何整数类型均可被替换成int或unsigned int类型. (12)新增数据类型 _Bool 值是0或1。C99中增加了用来定义bool、true以及false宏的头文件夹，以便程序员能够编写同时兼容于C与C++的应用程序。在编写新的应用程序时，应该使用头文件中的bool宏。 _Complex and _Imaginary C99标准中定义的复数类型如下：float_Complex; float_Imaginary; double_Complex; double_Imaginary; long double_Complex; long double_Imaginary.头文件中定义了complex和imaginary宏,并将它们扩展为_Complex和_Imaginary,因此在编写新的应用程序时,应该使用头文件中的complex和imaginary宏。 long long int C99标准中引进了long long int（-(2e63 - 1)至2e63 - 1）和unsigned long long int（0 - 2e64 - 1）。long long int能够支持的整数长度为64位。 较完整的阐述C99对C89的改变 1、增加restrict指针 C99中增加了公适用于指针的restrict类型修饰符，它是初始访问指针所指对象的惟一途径，因此只有借助restrict指针表达式才能访问对象。restrict指针指针主要用做函数变元，或者指向由malloc()函数所分配的内存变量。restrict数据类型不改变程序的语义。 如果某个函数定义了两个restrict指针变元，编译程序就假定它们指向两个不同的对象，memcpy()函数就是restrict指针的一个典型应用示例。C89中memcpy()函数原型如下： 代码: void memcpy (void s1, const void *s2, size_t size); 如果s1和s2所指向的对象重叠，其操作就是未定义的。memcpy()函数只能用于不重叠的对象。C99中memcpy()函数原型如下： 代码: void memcpy(void restrict s1, const void *restrict s2,size_t size); 通过使用restrict修饰s1和s2 变元，可确保它们在该原型中指向不同的对象。 2、inline（内联）关键字 内联函数除了保持结构化和函数式的定义方式外,还能使程序员写出高效率的代码.函数的每次调用与返回都会消耗相当大的系统资源,尤其是当函数调用发生在重复次数很多的循环语句中时.一般情况下,当发生一次函数调用时,变元需要进栈,各种寄存器内存需要保存.当函数返回时,寄存器的内容需要恢复。如果该函数在代码内进行联机扩展，当代码执行时，这些保存和恢复操作旅游活动会再发生，而且函数调用的执行速度也会大大加快。函数的联机扩展会产生较长的代码，所以只应该内联对应用程序性能有显著影响的函数以及长度较短的函数。 3、新增数据类型 _Bool 值是0或1。C99中增加了用来定义bool、true以及false宏的头文件夹，以便程序员能够编写同时兼容于C与C++的应用程序。在编写新的应用程序时，应该使用 头文件中的bool宏。 _Complex and _Imaginary C99标准中定义的复数类型如下：float_Complex; float_Imaginary; double_Complex;double_Imaginary; long double_Complex; long double_Imaginary. 头文件中定义了complex和imaginary宏,并将它们扩展为_Complex和_Imaginary,因此在编写新的应用程序时,应该使用头文件中的complex和imaginary宏。 long long int C99标准中引进了long long int（-(2e63 - 1)至2e63 - 1）和unsigned long long int（0 - 2e64- 1）。long long int能够支持的整数长度为64位。 4、对数组的增强 可变长数组 C99中,程序员声明数组时,数组的维数可以由任一有效的整型表达式确定,包括只在运行时才能确定其值的表达式,这类数组就叫做可变长数组,但是只有局部数组才可以是变长的.可变长数组的维数在数组生存期内是不变的,也就是说,可变长数组不是动态的.可以变化的只是数组的大小.可以使用*来定义不确定长的可变长数组。 数组声明中的类型修饰符 在C99中，如果需要使用数组作为函数变元，可以在数组声明的方括号内使用static关键字，这相当于告诉编译程序，变元所指向的数组将至少包含指定的元素个数。也可以在数组声明的方括号内使用restrict,volatile,const关键字，但只用于函数变元。如果使用restrict，指针是初始访问该对象的惟一途径。如果使用const，指针始终指向同一个数组。使用volatile没有任何意义。 5、单行注释 引入了单行注释标记 “//“ , 可以象C++一样使用这种注释了。 6、分散代码与声明 7、预处理程序的修改 ａ、变元列表 宏可以带变元，在宏定义中用省略号（…）表示。内部预处理标识符VA_ARGS决定变元将在何处得到替换。例：#define MySum(…) sum(VA_ARGS) 语句MySum(k,m,n);将被转换成：sum(k, m, n); 变元还可以包含变元。例： #define compare(compf, …)compf(VA_ARGS) 其中的compare(strcmp,”small”, “large”); 将替换成：strcmp(“small”,”large”); ｂ、_Pragma运算符 C99引入了在程序中定义编译指令的另外一种方法：_Pragma运算符。格式如下： _Pragma(“directive”) 其中directive是要满打满算的编译指令。_Pragma运算符允许编译指令参与宏替换。 ｃ、内部编译指令 STDCFP_CONTRACT ON/OFF/DEFAULT 若为ON，浮点表达式被当做基于硬件方式处理的独立单元。默认值是定义的工具。 STDCFEVN_ACCESS ON/OFF/DEFAULT 告诉编译程序可以访问浮点环境。默认值是定义的工具。 STDC CX_LIMITED_RANGE ON/OFF/DEFAULT 若值为ON，相当于告诉编译程序某程序某些含有复数的公式是可靠的。默认是OFF。 ｄ、新增的内部宏 STDC_HOSTED 若操作系统存在，则为1 STDC_VERSION 199991L或更高。代表C的版本 STDC_IEC_599 若支持IEC 60559浮点运算，则为1 STDC_IEC_599_COMPLEX 若支持IEC 60599复数运算，则为1 STDC_ISO_10646 由编译程序支持，用于说明ISO/IEC 10646标准的年和月格式：yyymmmL 8、for语句内的变量声明 C99中，程序员可以在for语句的初始化部分定义一个或多个变量，这些变量的作用域仅于本for语句所控制的循环体内。比如： 代码:for(int i=0; i&lt;10; i++){​ // do someting …} 9、复合赋值 C99中，复合赋值中，可以指定对象类型的数组、结构或联合表达式。当使用复合赋值时，应在括弧内指定类型，后跟由花括号围起来的初始化列表；若类型为数组，则不能指定数组的大小。建成的对象是未命名的。 例： double *fp = (double[]) {1.1, 2.2, 3.3}; 该语句用于建立一个指向double的指针fp，且该指针指向这个3元素数组的第一个元素。 在文件域内建立的复合赋值只在程序的整个生存期内有效。在模块内建立的复合赋值是局部对象，在退出模块后不再存在。 10、柔性数组结构成员 C99中，结构中的最后一个元素允许是未知大小的数组，这就叫做柔性数组成员，但结构中的柔性数组成员前面必须至少一个其他成员。柔性数组成员允许结构中包含一个大小可变的数组。sizeof返回的这种结构大小不包括柔性数组的内存。包含柔性数组成员的结构用malloc()函数进行内存的动态分配，并且分配的内存应该大于结构的大小，以适应柔性数组的预期大小。 11、指定的初始化符 C99中，该特性对经常使用稀疏数组的程序员十分有用。指定的初始化符通常有两种用法：用于数组，以及用于结构和联合。用于数组的格式：[index] = vol; 其中，index表示数组的下标，vol表示本数组元素的初始化值。 例如： int x[10] = {[0] = 10, [5] = 30}; 其中只有x[0]和x[5]得到了初始化．用于结构或联合的格式如下： member-name(成员名称) 对结构进行指定的初始化时，允许采用简单的方法对结构中的指定成员进行初始化。 例如： struct example{ int k, m, n; } object = {m = 10,n = 200}; 其中，没有初始化k。对结构成员进行初始化的顺序没有限制。 12、printf()和scanf()函数系列的增强 C99中printf()和scanf()函数系列引进了处理long long int和unsigned long long int数据类型的特性。long long int 类型的格式修饰符是ll。在printf()和scanf()函数中，ll适用于d, i, o, u 和x格式说明符。另外，C99还引进了hh修饰符。当使用d, i, o, u和x格式说明符时，hh用于指定char型变元。ll和hh修饰符均可以用于n说明符。 格式修饰符a和A用在printf()函数中时，结果将会输出十六进制的浮点数。格式如下：[-]0xh, hhhhp+ d 使用A格式修饰符时，x和p必须是大写。A和a格式修饰符也可以用在scanf()函数中，用于读取浮点数。调用printf()函数时，允许在%f说明符前加上l修饰符，即%lf，但不起作用。 13、C99新增的库 C89中标准的头文件 定义宏assert() 字符处理 错误报告 定义与实现相关的浮点值勤 定义与实现相关的各种极限值 支持函数setlocale() 数学函数库使用的各种定义 支持非局部跳转 定义信号值 支持可变长度的变元列表 定义常用常数 支持文件输入和输出 其他各种声明 支持串函数 支持系统时间函数 C99新增的头文件和库 支持复数算法 给出对浮点状态标记和浮点环境的其他方面的访问 定义标准的、可移植的整型类型集合。也支持处理最大宽度整数的函数（常见） 首先在此1995年第一次修订时引进，用于定义对应各种运算符的宏 支持布尔数据类型类型。定义宏bool，以便兼容于C++ 定义标准的、可移植的整型类型集合。该文件包含在中（常见） 定义一般类型的浮点宏 首先在1995年第一次修订时引进，用于支持多字节和宽字节函数 首先在1995年第一次修订时引进，用于支持多字节和宽字节分类函数 14、func预定义标识符 用于指出func所存放的函数名，类似于字符串赋值。 15、其它特性的改动 放宽的转换限制 限制 C89标准 C99标准 数据块的嵌套层数 15 127 条件语句的嵌套层数 8 63 内部标识符中的有效字符个数 31 63 外部标识符中的有效字符个数 6 31 结构或联合中的成员个数 127 1023 函数调用中的参数个数 31 127 不再支持隐含式的int规则 删除了隐含式函数声明 对返回值的约束 C99中,非空类型函数必须使用带返回值的return语句. 扩展的整数类型 扩展类型 含义 int16_t 整数长度为精确16位 int_least16_t 整数长度为至少16位 int_fast32_t 最稳固的整数类型,其长度为至少32位 intmax_t 最大整数类型 uintmax_t 最大无符号整数类型 对整数类型提升规则的改进 C89中,表达式中类型为char,short int或int的值可以提升为int或unsigned int类型. C99中,每种整数类型都有一个级别.例如:long long int 的级别高于int, int的级别高于char等.在表达式中,其级别低于int或unsigned int的任何整数类型均可被替换成int或unsigned int类型. C11相比C99的变化编辑 对齐处理操作符 alignof，函数 aligned_alloc()，以及 头文件 。见 7.15 节。 _Noreturn 函数标记，类似于 gcc 的 attribute((noreturn))。例子： _Noreturn void thrd_exit(int res); _Generic 关键词，有点儿类似于 gcc 的 typeof。示例代码： 123456789101112131415#include&lt;stdio.h&gt;#defineGENERAL_ABS(x)_Generic((x),int:abs,float:fabsf,double:fabs)(x)int main(void)&#123;printf("intabs:%d\n",GENERAL_ABS(-12));printf("floatabs:%f\n",GENERAL_ABS(-12.04f));printf("doubleabs:%f\n",GENERAL_ABS(-13.09876));inta=10;intb=0,c=0;_Generic(a+0.1f,int:b,float:c,default:b)++;printf("b=%d,c=%d\n",b,c);_Generic(a+=1.1f,int:b,float:c,default:b)++;printf("a=%d,b=%d,c=%d\n",a,b,c);&#125; 静态断言（ static assertions），_Static_assert()，在解释 #if 和 #error 之后被处理。例子： _Static_assert(FOO &gt; 0, “FOO has a wrong value”); 删除了 gets() 函数，C99中已经将此函数被标记为过时，推荐新的替代函数 gets_s()。 新的 fopen() 模式，(“…x”)。类似 POSIX 中的 O_CREAT|O_EXCL，在文件锁中比较常用。 匿名结构体/联合体，这个早已经在 gcc 中了，我们并不陌生，定义在 6.7.2.1 p13。 多线程支持，包括：_Thread_local，头文件 ，里面包含线程的创建和管理函数（比如 thrd_create()，thrd_exit()），mutex （比如 mtx_lock()，mtx_unlock()）等等，更多内容清参考 7.26 节。 _Atomic类型修饰符和 头文件 ，见 7.17 节。 带边界检查（Bounds-checking）的函数接口，定义了新的安全的函数，例如 fopen_s()，strcat_s() 等等。更多参考 Annex K。 改进的 Unicode 支持，新的头文件 等。实例代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include&lt;stdio.h&gt;#include&lt;uchar.h&gt;size_tUTF16StrLen(constchar16_t*utf16String)&#123;if(utf16String==NULL)return0;size_tindex;for(index=0;utf16String[index]!=u'\0';index++);returnindex;&#125; size_tUTF16ToUTF8(char*mbBuffer,constchar16_t*utf16String)&#123;if(mbBuffer==NULL||utf16String==NULL)return0;mbstate_tstate=&#123;&#125;;size_tmbIndex=0;for(intutf16Index=0;utf16String[utf16Index]!=u'\0';utf16Index++)&#123;constsize_tlength=c16rtomb(&amp;mbBuffer[mbIndex],utf16String[utf16Index],&amp;state);mbIndex+=length;&#125;mbBuffer[mbIndex]='\0';returnmbIndex;&#125;intmain(intargc,char*argv[])&#123;char16_tch=u'好'; charchBuffer[64]; mbstate_tstate=&#123;&#125;; size_tlength=c16rtomb(chBuffer,ch,&amp;state); chBuffer[length]='\0'; printf("TheUTF-8characterlengthis:%zu,andthecharacteris:%s\n",length,chBuffer); constchar*utf8Str=u8"你好，世界。"; printf("TheUTF-8stringis:%s\n",utf8Str); constchar16_t*utf16Str=u"你好，世界。"; printf("Theutf16stringlengthis:%zu\n",UTF16StrLen(utf16Str)); length=UTF16ToUTF8(chBuffer,utf16Str); printf("TheUTF-8stringlengthis:%zu,andthecontentis:%s\n",length,chBuffer); printf("IftheconvertedUTF-8stringisequaltotheoriginalone?%s\n",strcmp(chBuffer,utf8Str)==0?"YES":"NO");&#125; 新增 quick_exit() 函数，作为第三种终止程序的方式，当 exit() 失败时可以做最少的清理工作（deinitializition），具体见 7.22.4.7。 创建复数的宏， CMPLX()，见 7.3.9.3。 更多浮点数处理的宏 （More macros for querying the characteristics of floating point types, concerning subnormal floating point numbers and the number of decimal digits the type is able to store）。 struct timespec 成为 time.h 的一部分，以及宏 TIME_UTC，函数 timespec_get()。]]></content>
      <tags>
        <tag>C Language Homework</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Swift iOS 菜单和圆形布局库 FanMenu]]></title>
    <url>%2F2017%2F11%2FSwift-iOS-%E8%8F%9C%E5%8D%95%E5%92%8C%E5%9C%86%E5%BD%A2%E5%B8%83%E5%B1%80%E5%BA%93-FanMenu%2F</url>
    <content type="text"><![CDATA[FanMenu 是一个菜单和 圆形布局类库，基于 Macaw，用Swift编写。介绍在我上一篇文章中有讲。 用法** 在您的故事板或程序中创建UIView。 将FanMenu设置为UIView类 设置按钮 12345fanMenu.button = FanMenuButton(id: "main",image: "plus",color: Color(val: 0x7C93FE)) 4. 设置菜单项 12345678910111213fanMenu.items = [FanMenuButton(id: "exchange_id",image: "exchange",color: Color(val: 0x9F85FF)), ...FanMenuButton(id: "visa_id",image: "visa",color: Color(val: 0xF55B58))] 5. 添加事件处理程序 123456789//call before animationfanMenu.onItemDidClick = &#123; button inprint("ItemDidClick: \(button.id)")&#125;// call after animationfanMenu.onItemWillClick = &#123; button inprint("ItemWillClick: \(button.id)")&#125;]]></content>
      <tags>
        <tag>Swift library</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Swift 强大且易用的矢量图形库 Macaw]]></title>
    <url>%2F2017%2F11%2FSwift-%E5%BC%BA%E5%A4%A7%E4%B8%94%E6%98%93%E7%94%A8%E7%9A%84%E7%9F%A2%E9%87%8F%E5%9B%BE%E5%BD%A2%E5%BA%93-Macaw%2F</url>
    <content type="text"><![CDATA[此文介绍了Macaw这一强大的矢量图形库……. Macaw是一个功能强大、易于使用的矢量图形库，支持 SVG图片， 用Swift编写。动机现代设计包含大量的插图和复杂的动画。 移动开发人员必须花费大量时间将设计转换为本机视图，这些视图可以针对不同的屏幕进行调整。 使用Macaw，您可以将开发时间缩短到最低限度，并描绘高级场景元素中的所有图形。 甚至可以使用Macaw中的事件和动画支持从设计工具中渲染SVG图形。示例Activity Monitor应用程序显示步数，跑步级别和每日摘要。 动画菜单 你喜欢化学吗？这个iPad应用程序显示了Macaw的全部功能：仿射变换，用户事件，动画和各种效果。 [点击查看更多示例] [开源代码主页]]]></content>
      <tags>
        <tag>Swift Library</tag>
      </tags>
  </entry>
</search>
