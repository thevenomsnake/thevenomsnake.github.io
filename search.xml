<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[c语言课后实验作业11]]></title>
    <url>%2F2018%2F01%2Fc%E8%AF%AD%E8%A8%80%E8%AF%BE%E5%90%8E%E5%AE%9E%E9%AA%8C%E4%BD%9C%E4%B8%9A11%2F</url>
    <content type="text"><![CDATA[文件总是问题最多的是不是觉得每次都要手动排序很麻烦？qsort()函数可以帮你解决这个问题～ qsort()标准库函数的使用qsort函数包含在&lt;stdlib.h&gt;中 qsort函数声明如下： void qsort(void * base,size_t nmemb,size_t size ,int(*compar)(const void *,const void *)); 参数说明： base,要排序的数组 nmemb,数组中元素的数目 size,每个数组元素占用的内存空间，可使用sizeof函数获得 compar,指向函数的指针也即函数指针。这个函数用来比较两个数组元素，第一个参数大于，等于，小于第二个参数时，分别显示正值，零，负值。 下面看几个例子： 123456789101112131415161718192021222324252627282930313233343536#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;math.h&gt;#include &lt;string.h&gt;int main(void)&#123; int i; int a[10]=&#123;0,1,2,3,4,5,6,7,8,9&#125;; char b[10]=&#123;'a','b','c','d','e','f','g','h','i','j'&#125;; double c[10]=&#123;0.1,0.2,0.9,0.5,0.3,0.6,0.7,0.8,1.1,1.2&#125;; int cmp1(const void * a,const void * b)&#123; return (*(int*)a-*(int*)b);//a&gt;b 返回正值 &#125; int cmp2(const void * a,const void *b)&#123; return(*(char*)a-*(char*)b); &#125; int cmp3(const void * a,const void * b)&#123; if(fabs(*(double*)a-*(double *)b)&lt;1*exp(-20)) return 0; else return(((*(double*)a-*(double*)b)&gt;0)?1:-1); &#125; qsort(a,10,sizeof(int),&amp;cmp1);//对于函数指针（指向函数的指针），直接传入函数名和函数名进行&amp; //运算都是可以的，因为在调用函数时也是取的函数的地址 qsort(b,10,sizeof(char),cmp2); qsort(c,10,sizeof(double),cmp3); for(i=0;i&lt;10;i++) printf("%d ",a[i]); for(i=0;i&lt;10;i++) printf("%c ",b[i]); for(i=0;i&lt;10;i++) printf("%lf ",c[i]); return 0;&#125; 基础练习2.312345678910111213141516171819202122232425262728#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;int main(void)&#123; FILE *fp; char str[100]; int i = 0; if ((fp = fopen("test.dat", "wb")) == NULL) &#123; printf("Can not open the file\n"); return 1; &#125; printf("Input a string:\n"); gets(str); while (str[i] != '!') &#123; if (str[i] &gt;= 'a' &amp;&amp; str[i] &lt;= 'z') &#123; str[i] = str[i]-32; &#125; fputc(str[i], fp); i++; &#125; fclose(fp); fp = fopen("test.dat", "rb"); fgets(str, (int)(strlen(str)+1), fp); printf("%s\n",str); fclose(fp); return 0;&#125; 2.5使用qsort（）函数1234567891011121314151617181920212223242526272829#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;time.h&gt;int cmp1(const void * a,const void * b);int main(void)&#123; FILE *fp=fopen("rand.txt","w"); /*要写入的文件*/ FILE *fp2=NULL ; int i; int a[10000]; srand((unsigned int)time(NULL)); /*不可放在循环内，否则每次得到相同的“随机数”*/ for (i = 0; i&lt;10000; i++) &#123; a[i]=rand(); fprintf(fp,"%d ",a[i]); &#125; fclose(fp); qsort(a, 10000, sizeof(int), &amp;cmp1);/*排序函数，调用qsort()标准库函数进行排序*/ fp2=fopen("sort_rand.txt","w"); /*排序之后要写入的文件*/ for (i = 0; i&lt;10000; i++) &#123; fprintf(fp,"%d ",a[i]); &#125; fclose(fp2); return 0;&#125;int cmp1(const void * a,const void * b) &#123; return (*(int*)a-*(int*)b);//a&gt;b 返回正值&#125; 进阶练习3.61234567891011121314151617181920212223242526272829303132#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;struct information &#123; char a[15]; char b[10]; int c; double d; char e[10];&#125;;int main(void) &#123; struct information inf[5]; int i; FILE *fp; for (i = 0; i &lt; 5; i++) &#123; scanf("%s%s%d%lf%s", inf[5].a, inf[5].b, &amp;inf[5].c, &amp;inf[5].d, inf[5].e); &#125; fp = fopen("emloy.txt", "wb"); for (i = 0; i &lt; 5; i++) &#123; fwrite(&amp;inf[i], sizeof(struct information), 1, fp); &#125; fclose(fp); fp = fopen("emloy.txt", "rb"); for (i = 0; i &lt; 5; i++) &#123; fread(&amp;inf[i], sizeof(struct information), 1, fp); printf("%s\t%s\t%d\t%.2lf\t%s\n",inf[5].a,inf[5].b,inf[5].c,inf[5].d,inf[5].e); &#125; fclose(fp); return 0;&#125; 3.71234567891011121314151617181920212223242526#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;int main(void) &#123; FILE *fp; char ch1,ch2; fp = fopen("test", "r"); if (fp == NULL) &#123; printf("open file failed !\n"); return 1; &#125; ch1 = ch2 = 49; //ascii码 while (ch1 != EOF) &#123; if (ch1 == '\n')&#123; ch2++; putchar(ch1); putchar(ch2); ch1 = fgetc(fp); &#125; else &#123; putchar(ch1); ch1 = fgetc(fp); &#125; &#125; putchar('\n'); return 0;&#125; 3.91234567891011121314151617181920212223242526272829303132333435#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;int main(void) &#123; int a[18] = &#123;5,96,87,78,93,21,4,92,82,85,87,6,72,69,85,75,81,73&#125;; FILE *fp; int i,avg = 0,j,temp; fp = fopen("dat", "wb"); fwrite(a, sizeof(a), 1, fp); fclose(fp); fp = fopen("dat", "rb"); fread(&amp;j, sizeof(int), 1, fp); for (i = 0; i &lt; j; i++) &#123; fread(&amp;temp, sizeof(int), 1, fp); avg += temp; &#125; printf("%d\n",avg/j); fread(&amp;j, sizeof(int), 1, fp); avg = 0; for (i = 0; i &lt; j; i++) &#123; fread(&amp;temp, sizeof(int), 1, fp); avg += temp; &#125; printf("%d\n",avg/j); avg = 0; fread(&amp;j, sizeof(int), 1, fp); for (i = 0; i &lt; j; i++) &#123; fread(&amp;temp, sizeof(int), 1, fp); avg += temp; &#125; printf("%d\n",avg/j); fclose(fp); return 0;&#125; 3.10123456789101112131415#include &lt;stdio.h&gt;int main(void)&#123; char a; FILE *fp; if((fp=fopen("text.txt","r"))==NULL)&#123; printf("open failed"); return 1; &#125; while((a=fgetc(fp))!=EOF)&#123; printf("%c",a); fseek(fp,1,1);//偏移一位 &#125; fclose(fp); return 0;&#125; 3.131234567891011121314151617181920212223242526272829303132#include &lt;stdio.h&gt;int main(void)&#123; float sum; int i,j; FILE *fp; float a; if((fp=fopen("grades.bin","wb"))==NULL)&#123; printf("open failed"); return 1; &#125; for(i=0;i&lt;5;i++)&#123; for(j=0;j&lt;4;j++)&#123; scanf("%f",&amp;a); fwrite(&amp;a,sizeof(float),1,fp); &#125; &#125; fclose(fp); if((fp=fopen("grades.bin","rb"))==NULL)&#123; printf("¥Úø™ ß∞‹"); return 2; &#125; for(i=0;i&lt;5;i++)&#123; sum=0; for(j=0;j&lt;4;j++)&#123; fread(&amp;a,sizeof(float),1,fp); sum+=a; &#125; printf("%.2f\t",sum/4); &#125; fclose(fp); return 0;&#125; 怎样提高效率才是我们最应该想的事情，不要舍本逐末]]></content>
      <tags>
        <tag>c语言</tag>
        <tag>c语言作业</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[c语言课后实验作业10]]></title>
    <url>%2F2018%2F01%2Fc%E8%AF%AD%E8%A8%80%E8%AF%BE%E5%90%8E%E5%AE%9E%E9%AA%8C%E4%BD%9C%E4%B8%9A10%2F</url>
    <content type="text"><![CDATA[这可能是最近最简单的作业如对结构体抱有疑问，请看往期介绍（逃 随便挑几个溜了 基础练习 基础练习1 12345678910111213141516171819#include &lt;stdio.h&gt;struct people&#123; char name[10]; int age; int money;&#125;;int main(void)&#123; int i; struct people per[3]=&#123; &#123;"李明",25,2500&#125;, &#123;"王利",22,2300&#125;, &#123;"赵勇",30,3000&#125; &#125;; printf("姓名 年龄 月薪\n"); for(i=0;i&lt;3;i++)&#123; printf(" %s %d %d\n",per[i].name,per[i].age,per[i].money); &#125; return 0;&#125; 基础练习4 123456789101112#include &lt;stdio.h&gt;typedef struct tada&#123; int year; int month; int day;&#125;;int main(void)&#123; struct tada a; printf("输入年、月、日："); scanf("%d%d%d",&amp;a.year,&amp;a.month,&amp;a.day); printf(" %d年 %d月 %d日\n",a.year,a.month,a.day);&#125; 进阶练习 进阶练习1 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758#include &lt;stdio.h&gt;struct studentInformationOne&#123; char studentID[11]; int credit; int score; float average;&#125;;struct studentInformationTwo&#123; char name[10]; char data[15]; int credit; int score; float average;&#125;;struct list&#123; char name[10]; char address[100];&#125;;struct stock&#123; char name[10]; int value; char data[15];&#125;;struct inventory&#123; char number[10]; char name[10]; int itemIn; int theID;&#125;;int main()&#123; struct studentInformationOne a; struct studentInformationTwo b; struct list c; struct stock d; struct inventory e; printf("输入学生学号、完成的学分、累积成绩分数、平均值组。"); scanf("%s%d%d%f",a.studentID,&amp;a.credit,&amp;a.score,&amp;a.average); printf("输入学生姓名、出生日期、完成的学分数、累积成绩分数、平均值。"); scanf("%s%s%d%d%f",b.name,b.data,&amp;b.credit,&amp;b.score,&amp;b.average); printf("输入人名、地址。"); scanf("%s%s",c.name,c.address); printf("输入股票名称、股票价格、购买日期"); scanf("%s%d%s",d.name,&amp;d.value,d.data); printf("输入零件号码、零件名称、库存量、记录员编号"); scanf("%s%s%d%d",e.number,e.name,&amp;e.itemIn,&amp;e.theID); printf("学生学号%s 完成的学分%d 累积成绩分数%d 平均值组%f。\n",a.studentID,a.credit,a.score,a.average); printf("学生姓名%s 出生日期%s 完成的学分数%d 累积成绩分数%d 平均值%f.\n",b.name,b.data,b.credit,b.score,b.average); printf("人名%s 地址%s。\n",c.name,c.address); printf("输入股票名称%s 股票价格%d 购买日期%s.\n",d.name,d.value,d.data); printf("输入零件号码%s 零件名称%s 库存量%d 记录员编号%d.\n",e.number,e.name,e.itemIn,e.theID); return 0;&#125; 进阶练习2 1234567891011121314151617#include &lt;stdio.h&gt;struct data&#123; int house; int fen;&#125;;int main(void)&#123; struct data a; scanf("%d %d",&amp;a.house,&amp;a.fen); if(a.fen==59)&#123; if(a.house==12)&#123; printf("1 00"); &#125; else &#123; printf("%d 00",a.house+1); &#125; &#125; else printf("%d %d",a.house,a.fen+1);&#125; 进阶练习10 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110#include &lt;stdio.h&gt;struct Data&#123; int year; int month; int day;&#125;;typedef struct Data DATA;DATA larger(DATA d1,DATA d2);int days(DATA data);int main(void)&#123; DATA m; DATA data1,data2; scanf("%d%d%d",&amp;data1.year,&amp;data1.month,&amp;data1.day); scanf("%d%d%d",&amp;data2.year,&amp;data2.month,&amp;data2.day); m=larger(data1,data2); printf("%d %d %d \n",m.year,m.month,m.day);&#125;DATA larger(DATA d1,DATA d2)&#123; if(days(d1)-days(d2)&gt;0) return d1; else return d2;&#125;int days(DATA data)&#123; int m; if(data.year%4==0)&#123; m=(data.year-1900)/4*1461; switch (data.month)&#123; case 1: m+=0; break; case 2: m+=31; break; case 3: m+=60; break; case 4: m+=91; break; case 5: m+=121; break; case 6: m+=152; break; case 7: m+=182; break; case 8: m+=213; break; case 9: m+=244; break; case 10: m+=274; break; case 11: m+=305; break; default : m+=335; &#125; return (m+data.day); &#125; else&#123; m=(data.year-1900)/4*1461+(data.year-1900)%4*365; switch (data.month)&#123; case 1: m+=0; break; case 2: m+=31; break; case 3: m+=61; break; case 4: m+=92; break; case 5: m+=122; break; case 6: m+=153; break; case 7: m+=183; break; case 8: m+=214; break; case 9: m+=245; break; case 10: m+=275; break; case 11: m+=306; break; default : m+=336; &#125; return (m+data.day); &#125;&#125;]]></content>
      <tags>
        <tag>c语言</tag>
        <tag>c语言作业</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[认识文本文件与二进制文件]]></title>
    <url>%2F2017%2F12%2F%E8%AE%A4%E8%AF%86%E6%96%87%E6%9C%AC%E6%96%87%E4%BB%B6%E4%B8%8E%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%96%87%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[C Primer Plus第六版 417页有这样一段话：“像Unix和Linux这样只有一种文件类型的系统，带b字母的模式和不带b字母的模式相同” 不讨论最底层，因为我太菜 发现问题总所周知，fopen()的函数原型是：FILE *fopen(const char filename, const char mode) 关于char *mode在 C primer Plus(第六版) 这本书对做出了介绍 模式字符串 含义 “r” （read）以只读模式打开文件 “w” （write）以写模式打开文件，把现有的文件长度截成0，如果文件不存在，则创建对应的一个新文件 “a” （append）以写模式打开文件，在现有文件末尾添加内容，如果文件不存在，则创建对应的一个新文件 “r+” 以更新模式打开文件（即可以读写文件） “w+” 以更新模式打开文件（即读和写），如果文件存在，则将其长度截成0；如果文件不存在，则创建一个新文件 “a+” 以更新模式打开文件（即读和写），在现有文件末尾添加内容，如果文件不存在，则创建一个新文件；可以读整个文件，但是只能从末尾添加内容 “rb”、”wb”、”ab”、”rb+”、”r+b”、 “wb+”、”w+b”、”ab+”、”a+b” 与上一个模式类似，但是是以二进制模式而不是文本模式打开文件 “wx”、”wbx”、”w+x”、”wb+x”或”w+bx” （c11）类似非x模式，但是如果文件已存在或以独占模式打开文件，则打开文件失败 但下方有一段话： “像Unix和Linux这样只有一种文件类型的系统，带b字母的模式和不带b字母的模式相同” 那么，译者的意思是，Windows不只有一种文件类型的系统，而Linux只有一种？那是什么差异导致的呢？ 探索上机首先自然是在不同环境下测试啦 测试代码123456789#include &lt;stdio.h&gt;int main(void)&#123; FILE *fp = NULL; fp = fopen("test.txt", "wb+");//使用二进制格式保存 fprintf(fp, "This is testing for fprintf...\n"); fputs("This is testing for fputs...\n", fp); fclose(fp); return 0;&#125; 测试环境windows 10 -1709 -VC6++ 可以发现文本模式并不能正确识别 Kail Linux -2017.3-GCC 7.2 Linux可以识别 macOS -High Sierra-Xcode 9.3 macOS上也可以识别 实践证明fopen()函数在Linux和UNIX下的确不需要带“b”的模式 疑问一顿Google猛如虎，结果下来啥没有。任何系统本质都是二进制文件，那书上这句话究竟想表达什么呢？或者说为什么Linux不需要带“b”字母的模式呢？ 总结比较广义上的二进制文件包括文本文件，这里讨论的是狭义上的二进制文件与文本文件的比较： 能存储的数据类型不同文本文件只能存储char型字符变量。二进制文件可以存储char/int/short/long/float/……各种变量值。 每条数据的长度文本文件每条数据通常是固定长度的。以ASCII为例，每条数据(每个字符)都是1个字节。二进制文件每条数据不固定。如short占两个字节，int占四个字节，float占8个字节…… 读取的软件不同文本文件编辑器就可以读写。比如记事本、NotePad++、Vim等。二进制文件需要特别的解码器。比如bmp文件需要图像查看器，rmvb需要播放器 文件读写过程明白二者的区别，也需要知道文件的读写过程。 以读文件为例，实际上是磁盘 》》 文件缓冲区》》应用程序内存空间 这两个转化过程。我们说“文本文件和二进制文件没有区别”，实际上针对的是第一个过程；既然没有区别，那么打开方式不同，为何显示内容就不同呢？这个区别实际上是第二个过程造成的。 文件实际上包括两部分，控制信息和内容信息。纯文本文件仅仅是没有控制格式信息罢了；实际上也是一种特殊的二进制文件。所以，我们很难区分二者的不同，因为他们的概念上不是完全互斥的。 在Windows和DOS系统中，狭义的文本文件是指扩展名为txt的文件。实际上，那些没有规定格式的，由可理解的的ASCII以及其他编码文字组成的文件都是文本文件，如C源程序文件，HTML超文本，XML。除此之外的其他文件都是二进制文件，如Word文件DOCX，图象格式文件JPG。 但是，所谓使用fopen标志打开文本文件与二进制文件的说法并不准确。正确的说法应该是: 以文本方式和二进制方式打开文件。因为我们用两种方式都可以打开任意的文件。 即使这样，为什么还要区分两种方式呢? 操作差异这是因为这两种方式在读写文件时的操作是不一样的。 二进制方式很简单，读文件时，会原封不动的读出文件的全部內容，写的時候，也是把內存缓冲区的內容原封不动的写到文件中。 而文本方式就不一样了，在读文件时，会将换行符号CRLF(0x0D 0x0A)全部转换成单个的0x0A，并且当遇到结束符CTRLZ(0x1A)时，就认为文件已经结束。相应的，写文件时，会将所有的0x0A换成0x0D0x0A。 上面这一点通俗来说就是 许多MS-DOS编译器都用Ctrl+Z标记文本文件的结尾。以文本模式打开这样的文件时，C能识别作为文件结尾的标记的字符。但是，以二进制模式打开相同的文件时，Ctrl+Z字符被看作是文件中的一个字符，而实际的文件结尾符在该字符的后面，或者文件中可能用空字符填充，使得该文件大小是256的倍数。 MS-DOS用\r\n组合表示文本文件的换行。以文本模式打开相同文件时，C程序把\r\n当作\n。但是，以二进制模式打开该文件时，程序能看见这两个字符。通常，UNIX文本文件既没有Ctrl+Z，也没有\r。 所以，若使用文本方式打开二进制文件时，就很容易出现文件读不完整，或內容不对的错误。即使是用文本方式打开文本文件，也要谨慎使用，比如复制文件，就不应该使用文本方式。 系统差异要特別注意的是，上面这样的说法仅适用于DOS和Windows系统。 在Unix和其他一些系统中，沒有文本方式和二进制方式的区分，使不使用’b’标志都是一样的。这是由于不同操作系统对文本文件换行符的定义，和C语言中换行符的定义有所不同而造成的。 如上文已提到，DOS和Windows系统使用CRLF(0x0D 0x0A)双字节作为文本文件换行符，而Unix文本文件的换行符只有一个字节LF(0x0A)为。在C语言中，也是以LF即&#39;\n&#39;为换行符。 由于DOS/Windows定义的换行符和C语言的不一致，C语言的标准输入输出函数适行读写文本文件时，就适行了CRLF-&gt;LF的转换。而Unix的定义和C语言的是一样的，就不必转换了。 那么，为什么会有定义不一致的情况呢？这纯属历史原因。当初C是在Unix上创造和发展的，对换行的定义自然就一样了。其后C被引入到DOS系统，为了使原有的C程序能不加修改的读写DOS的文本文件，所以就在文件读写上做了修改。随着DOS/Windows逐渐成为主流平台，这个当初为了兼容而做的修改給众多的C语言开发者添了这样一个小小的麻烦。 *转换办法dos2unix/unix2dos一般Linux发行版中都带有这个小工具，只能把DOS转换为UNIX文件，命令如下： # dos2unix dosfile.txt 上面的命令会去掉行尾的^M符号。 vimVim是一个vi的改进版本，可以运行在Windows和Linux平台上，使用方法如下： # vimdosfile.txt DOS转UNIX：:setfileformat=unix UNIX转DOS：:setfileformat=dos :wq 如果你需要把Unix文本文件转换为DOS文本文件，输入:setfileformat=dos，你也可以使用ff来替代fileformat，此时可以输入:set ff=dos。你可以输入:help fileformat来获得跟多的关于选项信息。 注：为了能让vim可以自动识别DOS和UNIX文本文件格式，可以在.vimrc(Linux)或_vimrc（Windows）配置文件中加入如下一行设置： ​ setfileformats=dos,unix ​ 设置完成后，使用vim打开DOS文本文件就不会显示^M字符了。 tr使用tr命令拷贝标准输入到标准输出，替换或者删除掉选择的字符，只能把DOS转换为UNIX文件，命令如下： # tr -d ‘\r’&lt; dosfile.txt &gt; unixfile.txt EmacsEmacs是一个Unix下面的文本编辑工具。它会在底部的状态栏上显示文件的信息。 DOS转UNIX ：M-xset-buffer-file-coding-system Unix UNIX转DOS：M-xset-buffer-file-coding-system dos sed在DOS文件格式中使用CR/LF换行，在Unix下仅使用LF换行，sed替换命令如下： DOS转UNIX：$ sed ‘s/.$//’dosfile.txt &gt; unixfile.txt UNIX转DOS：$ sed ’s/$/\r/’unixfile.txt &gt; dosfile.txt Perl Perl是相当直接，你添加或删除掉文件每行结尾的CR字符。 DOS转UNIX：perl -p -e ‘s/\r$//’&lt; dosfile.txt &gt; unixfile.txt UNIX转DOS：perl -p -e ‘s/$/\r/’&lt; unixfile.txt &gt; dosfile.txt awkDOS转UNIX：awk ‘{sub(“\r$”,“”, $0);print $0}’ dosfile.txt &gt; unixfile.txt UNIX转DOS：awk ‘{sub(“$”,“\r”, $0);print $0}’ dosfile.txt &gt; unixfile.txt Python DOS转UNIX： python -c “importsys; map(sys.stdout.write, (l[:-2] + ‘\n’ for l in sys.stdin.readlines()))”&lt; dosfile.txt &gt; unixfile.txt UNIX转DOS： python -c “importsys; map(sys.stdout.write, (l[:-1] + ‘\r\n’ for l in sys.stdin.readlines()))”&lt; dosfile.txt &gt; unixfile.txt 欢迎补充…]]></content>
      <tags>
        <tag>c语言</tag>
        <tag>c语言语法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[初探C/C++标准&&未定义行为]]></title>
    <url>%2F2017%2F12%2F%E5%88%9D%E6%8E%A2%E6%9C%AA%E5%AE%9A%E4%B9%89%E8%A1%8C%E4%B8%BA%2F</url>
    <content type="text"><![CDATA[引子：C 语言中int main()和 void main() 有何区别？ 前言 文章基于官方文档汇总而成，引用地址会放在文章末尾，若有修改意见欢迎评论指出～ 刚开始上课的时候，难免会接触到int main()和void main()，当初我只是初步认识到了void main()是一种 不标准 的写法，但是今天进一步认识到void main()算是一种Undefined behavior(未定义行为)。 main函数原型&amp;&amp;终止行为在C和C++中流传着很多版本的main函数原型，不同的书里也有不同的写法。今天我从几种标准(C89/99/11以及C++98/03/11/14)的角度来寻找一下什么是“标准行为”以及在主函数中return后发生了什么。 比较常见的是下面几种： 12345void main()main()int main()int main(void)int main(int argc,char *argv[]) void main()首先，从标准角度(所有版本)来说，void main()肯定是错的，没有任何标准(C89/99/11以及C++98/03/11/14)中允许过这种写法。 但是我在APUE里看到了一种把主函数写为void main()的原因，不知道是不是有人从这个角度说的然后就以讹传讹了。 The problem is that these compilers don’t know that an exit from main is the same as a return. One way around these warnings, which become annoying after a while, is to use return instead of exit from main. But doing this prevents us from using the UNIX System’s grep utility to locate all calls to exit from a program. Another solution is to declare main as returning void, instead of int, and continue calling exit. This gets rid of the compiler warning but doesn’t look right (especially in a programming text), and can generate other compiler warnings, since the return type of main is supposed to be a signed integer. 还有一种可能是从嵌入式来的，没有操作系统，入口点是硬件实现，返回任何东西都没意义。 main()在K&amp;R C与C89里，函数没有显式声明返回类型，则默认是int: C89对函数定义的语法(Syntax)描述如下(注意declaration-specifiers的opt下标符号)： $${declaration\textrm{-}specifiers{opt}}\hspace{2mm}{declarator\hspace{2mm}declaration\textrm{-}list{opt}}\hspace{2mm}{compound\textrm{-}statement}$$ C89中declaration-specifiers在Syntax上为： storage-class-specifier type-specifier type-qualifier 表明在C89中函数的return type可以省略。 K&amp;R C里的描述如下： Various parts may be absent; a minimal function is 1dummy() &#123;&#125; which does nothing and returns nothing. A do-nothing function like this is sometimes useful as a place holder during program development. If the return type is omitted, int is assumed. 所以说： 123func()&#123;&#125;// 等价于int func()&#123;&#125; 但是这种方式在C99之后就被废除掉了(注意declaration-specifiers没有opt下标了)： declaration-specifiers declarator declaration-list(opt) compound-statement 综上，在C89中，函数的返回类型可以省略，但默认为int，即 主函数声明main()隐式是int main()。 int main()int main()和int main(void)在C语言中是有区别的： 123int main()// 不等价于int main(void) 在C语言中参数列表为空(即不提供参数列表也不为void)，表示不提供参数数量和参数类型信息： 12345678int func()&#123; print("func()\n"); return 0;&#125;int main(void)&#123; func(1,2,3,4);// call func();&#125; The empty list in a function declarator that is not part of a definition of that function specifies that no information about the number or types of theparameters is supplied. C99/11 Standard在C99/11标准中，明确定义了对于标准的main函数的两个原型： 摘自ISO/IEC 9899:201x 中5.1.2.2.1在线查阅&amp;&amp;下载 The function called at program startup is named main. The implementation declares no prototype for this function. It shall be defined with a return type of int and with no parameters: 1int main(void) &#123; /* ... */ &#125; or with two parameters (referred to here as argc and argv, though any names may be used, as they are local to the function in which they are declared): 1int main(int argc, char *argv[]) &#123; /* ... */ &#125; or equivalent;or in some other implementation-defined manner.If they are declared, the parameters to the main function shall obey the following constraints: The value of argc shall be nonnegative. argv[argc] shall be a null pointer. If the value of argc is greater than zero, the array members argv[0] through argv[argc-1] inclusive shall contain pointers to strings, which are given implementation-defined values by the host environment prior to program startup. The intent is to supply to the program information determined prior to program startup from elsewhere in the hosted environment. If the host environment is not capable of supplying strings with letters in both uppercase and lowercase, the implementation shall ensure that the strings are received in lowercase. If the value of argc is greater than zero, the string pointed to by argv[0]represents the program name; argv[0][0] shall be the null character if the program name is not available from the host environment. If the value of argc is greater than one, the strings pointed to by argv[1] through argv[argc-1]represent the program parameters. The parameters argc and argv and the strings pointed to by the argv array shall be modifiable by the program, and retain their last-stored values between program startup and program termination. C++ Strandard由于C和C++中对于函数参数列表的规则并不一致(C++中参数列表为空代表不接收任何参数)。所以C++中main的原型和ISO C也并不太一样： a function of () returning int and a function of (int, pointer to pointer to char) returning int main 返回的值main必须要有返回值的原因是：在C和C++中使用return-statement都是将return的值作为参数来调用exit/std::exit来终止程序。 If status is zero or EXIT_SUCCESS, an implementation-defined form of the status successful termination is returned. ISO C99/11:If the return type of the main function is a type compatible with int, a return from the initial call to the main function is equivalent to calling the exit function with the value returned by the main function as its argument;reaching the } that terminates the main function returns a value of 0. If the return type is not compatible with int, the termination status returned to the host environment is unspecified. Forward references: definition of terms (ISO/IEC 9899:201x 7.1.1), the exit function (ISO/IEC 9899:201x 7.22.4.4). 注意： ISO/IEC 9899:201x -6.9.1 #12 If the } that terminates a function is reached, and the value of the function call is used bythe caller, the behavior is undefined. 所以函数结尾不写return是undefined behavior 在Xcode9.0环境下，不写return的函数无法通过编译 但是： ISO/IEC 9899:201x 5.1.2.2.3 Program termination 1 If the return type of the main function is a type compatible with int, a return from theinitial call to the main function is equivalent to calling the exit function with the valuereturned by the main function as its argument;(11) reaching the } that terminates themain function returns a value of 0. If the return type is not compatible with int, thetermination status returned to the host environment is unspecified.Forward references: definition of terms (7.1.1), the exit function (7.22.4.4) main函数是一个特例，可以不用return ISO C++11/14:A return statement in main has the eﬀect of leaving the main function (destroying any objects with automatic storage duration) and calling std::exit with the return value as the argument. If control reaches the end of main without encountering a return statement, the eﬀect is that of executing 1return 0; 待补充 exit12#include &lt;stdlib.h&gt;void exit(int status); The exit function causes normal program termination to occur. If more than one call to the exit function is executed by a program, the behavior is undefined. First, all functions registered by the atexit function are called, in the reverse order of their registration,except that a function is called after any previously registered functions that had already been called at the time it was registered. If, during the call to any such function, a call to the longjmp function is made that would terminate the call to the registered function, the behavior is undefined. Next, all open streams with unwritten buffered data are ﬂushed, all open streams are closed, and all files created by the tmpfile function are removed. Finally, control is returned to the host environment. If the value of status is zero or EXIT_SUCCESS, an implementation-defined form of the status successful termination is returned. If the value of status is EXIT_FAILURE, an implementation-defined form of the status unsuccessful termination is returned. Otherwise the status returned is implementation-defined. The exit function cannot return to its caller. _Exit12#include &lt;stdlib.h&gt;void _Exit(int status); The _Exit function causes normal program termination to occur and control to be returned to the host environment. No functions registered by the atexit function or signal handlers registered by the signal function are called. The status returned to the host environment is determined in the same way as for the exit function (7.20.4.3).Whether open streams with unwritten buffered data are ﬂushed, open streams are closed,or temporary files are removed is implementation-defined.The _Exit function cannot return to its caller. Undefined behavior渣翻译请见谅，如果翻译有定义性错误，还请评论指出，谢谢 ! 原文链接 定义 在计算机程序设计中，未定义行为（英语：undefined behavior）是指行为不可预测的计算机代码。这是一些编程语言的一个特点，最有名的是在C语言中。在这些语言中，为了简化标准，并给予实现一定的灵活性，标准特别地规定某些操作的结果是未定义的，这意味着程序员不能预测会发生什么事。 例如，在C语言中，在任何自动对象被初始化之前，通过非字符类型的左值表达式读取这个变量存储的值会产生未定义行为，除以零或访问数组定义的界限之外的元素（参见缓冲区溢出）也会产生未定义行为。在一般情况下，之后的任何行为是不确定的；甚至只要程序的执行存在未定义行为，在引起未定义行为操作发生之前也可能不要求保证程序的行为可预测（如ISO C++）。特别地，标准从来没有要求编译器判断未定义行为，因此，如果程序调用未定义行为，可能会成功编译，甚至一开始运行时没有错误，只会在另一个系统上，甚至是在另一个日期运行失败。当一个未定义行为的实例发生时，正如语言标准所说，“什么事情都可能发生”，也许什么都没有发生。 和未指定行为(unspecified behavior)不同，未定义行为强调基于不可移植或错误的程序构造，或使用错误的数据。一个符合标准的实现可以在假定未定义行为永远不发生（除了显式使用不严格遵守标准的扩展）的基础上进行优化，可能导致原本存在未定义行为（例如有符号数溢出）的程序经过优化后显示出更加明显的错误（例如死循环）。因此，这种未定义行为一般应被视为bug。 Example in C and C++Attempting to modify a string literal causes undefined behavior 尝试修改字符串字面量会产生未定义行为： 123char * p = "wikipedia";// valid C, ill-formed in C++11, deprecated C++98/C++03 //C++11中错误，C++98/C++03不推荐使用p[0] = 'W'; // undefined behavior 未定义行为 防止这一点的方法之一是将它定义为数组而不是指针： 12char p[] = "wikipedia"; /* 正确 */p[0] = 'W'; Integer division by zero results in undefined behavior 除以零会导致未定义行为。 根据 IEEE 754，float、double和long double类型的值除以零的结果是无穷大或NaN： 1return x/0; // undefined behavior Certain pointer operations may result in undefined behavior: 某些指针操作可能导致未定义行为： 1234int arr[4] = &#123;0, 1, 2, 3&#125;;int *p = arr + 5; // undefined behavior for indexing out of boundsp = 0;int a = *p; // undefined behavior for dereferencing a null pointer In C and C++, the comparison of pointers to objects is only strictly defined if the pointers point to members of the same object, or elements of the same array. Example: 在C和C ++中，如果指针指向相同对象的成员，或者指向同一个数组的元素，那么只能严格定义指向对象的指针。样例： 123456int main(void)&#123; int a = 0; int b = 0; return &amp;a &lt; &amp;b; /* undefined behavior */&#125; Reaching the end of a value-returning function (other than main()) without a return statement results in undefined behavior if the value of the function call is used by the caller: 到达返回数值的函数（除main函数以外）的结尾，而没有一个return语句，会导致未定义行为： 12int f()&#123;&#125; /* undefined behavior if the value of the function call is used*/ Modifying an object between two sequence points more than once produces undefined behavior. It is worth mentioning that there are considerable changes in what causes undefined behavior in relation to sequence points as of C++11. The following example will however cause undefined behavior in both C++ and C. 在两个连续点之间多次修改对象会产生未定义的行为。值得一提的是，与C ++ 11相比，未定义的行为与顺序点的关系有所改变。下面的例子然而会导致C ++和C 中未定义的行为 1i = i++ + 1; // undefined behavior When modifying an object between two sequence points, reading the value of the object for any other purpose than determining the value to be stored is also undefined behavior. 在两个连续点之间修改对象时，除了确定要存储的值之外，读取对象的值也是未定义的行为。 12a[i] = i++; // undefined behaviorprintf("%d %d\n", ++n, power(2, n)); // also undefined behavior BenefitsDocumenting an operation as undefined behavior allows compilers to assume that this operation will never happen in a conforming program. This gives the compiler more information about the code and this information can lead to more optimization opportunities. 将记录为未定义的行为允许编译器假定这个行为永远不会在符合的程序中执行。这给了编译器更多关于代码的信息，这些信息可以有更多机会去优化代码。 C语言的一个例子： An example for the C language: 1234567int foo(unsigned char x)&#123; int value = 2147483600; /* assuming 32 bit int */ value += x; if (value &lt; 2147483600) bar(); return value;&#125; The value of x cannot be negative and, given that signed integer overflow is undefined behavior in C, the compiler can assume that at the line of the if check value &gt;= 2147483600. Thus the if and the call to the function bar can be ignored by the compiler since the if has no side effects and its condition will never be satisfied. The code above is therefore semantically equivalent to: x不能为负值，并且考虑到有符号整数溢出在C中是未定义的行为，编译器可以假设在if检查value &gt;= 2147483600。因此if对函数的调用bar可以被编译器忽略，因为if没有带来任何影响，它的条件永远不会被满足。上面的代码因此在语义上等同于： 12345int foo(unsigned char x)&#123; int value = 2147483600; value += x; return value;&#125; Had the compiler been forced to assume that signed integer overflow has wraparound behavior, then the transformation above would not have been legal. Such optimizations become hard to spot by humans when the code is more complex and other optimizations, like inlining, take place. Another benefit from allowing signed integer overflow to be undefined is that it makes it possible to store and manipulate a variable’s value in a processor register that is larger than the size of the variable in the source code. For example, if the type of a variable as specified in the source code is narrower than the native register width (such as “int on a 64-bit machine, a common scenario), then the compiler can safely use a signed 64-bit integer for the variable in the machine code it produces, without changing the defined behavior of the code. If the behavior of a 32-bit integer under overflow conditions was depended upon by the program, then a compiler would have to insert additional logic when compiling for a 64-bit machine, because the overflow behavior of most machine code instructions depends on the register width. A further important benefit of undefined signed integer overflow is that it enables, though does not require, such erroneous overflows to be detected at compile-time or by static program analysis, or by run-time checks such as the Clang and GCC sanitizers and valgrind; if such overflow was defined with a valid semantics such as wrap-around then compile-time checks would not be possible. 如果编译器被迫假定有符号整数溢出具有环绕行为，那么上面的转换就不合法了。 当代码更复杂时，人们难以发现这样的优化，并作出其他优化，如内联。 允许有符号整数溢出未定义的另一个好处是可以在处理器寄存器中存储和操作变量的值，该寄存器的值大于源代码中变量的大小。例如，如果源代码中指定的变量类型比本地寄存器宽度窄（例如64位机器上的“ int ” ，这是最常见的情况），那么编译器可以安全地使用带符号的 64 位寄存器 机器代码中产生的整数变量，而不会改变代码的定义行为。如果在溢出条件下32位整数的行为被程序所依赖，那么在编译64位机器时，编译器将不得不考虑额外的逻辑，因为大多数机器代码指令的溢出行为取决于寄存器宽度. 未定义的有符号整数溢出的另一个重要好处是，它可以在编译时或通过静态程序分析或通过运行时检查（如Clang和GCC sanitizers和valgrind来检测这种溢出的错误; 如果这样的溢出是用一个有效的语义来定义的，比如环绕行为，那么编译时检查是不可能的。 RisksC and C++ standards have several forms of undefined behavior throughout, which offers increased liberty in compiler implementations and compile-time checks at the expense of undefined run-time behavior if present. In particular, there is an appendix section dedicated to a non-exhaustive listing of common sources of undefined behavior in C. Moreoever, compilers are not required to diagnose code that relies on undefined behavior, due to current static analysis limitations. Hence, it is common for programmers, even experienced ones, to unintentionally rely on undefined behavior either by mistake, or simply because they are not well-versed in the rules of the language that can span over hundreds of pages. This can result in bugs that are exposed when optimizations are enabled on the compiler, or when a compiler of a different vendor or version is used. Testing or fuzzing with dynamic undefined behavior checks enabled, e.g. the Clang sanitizers, can help to catch undefined behavior not diagnosed by the compiler or static analyzers. In scenarios where security is critical, undefined behavior can lead to security vulnerabilities in software. When GCC’s developers changed their compiler in 2008 such that it omitted certain overflow checks that relied on undefined behavior, CERT issued a warning against the newer versions of the compiler. Linux Weekly News pointed out that the same behavior was observed in PathScale C, Microsoft Visual C++ 2005 and several other compilers; the warning was later amended to warn about various compilers. C和C ++标准在整个制定过程中都有几种不确定的行为，如果存在未定义的运行行为，则会增加编译器执行和编译时检查的自由度。特别是有一个附录部分，专门用于列举C中不确定行为的常见来源。不过，由于当前的静态分析限制，编译器不需要诊断依赖于未定义行为的代码。因此，甚至经验丰富的程序员通常会无意中依赖未定义的行为，或者是因为他们不熟悉可能长达数百页的语言规则。这可能会导致在编译器上启用优化时或在使用不同供应商或版本的编译器时公开的bug。启用动态未定义行为检查（例如Clang sanitizers）的测试或模糊测试可以帮助捕获未经编译器或静态分析器诊断的未定义行为。 在安全性至关重要的情况下，未定义的行为会导致软件中出现安全漏洞。当GCC的开发人员在2008年修改了他们的编译器，从而忽略了某些依赖于未定义行为的溢出检查时，CERT对新版本的编译器发出警告。 Linux Weekly News指出，同样的行为是在 PathScale C, Microsoft Visual C++ 2005和其他一些编译器; 警告规则在后来已经被修订，用来警告各种编译器. 参考资料 ISO/IEC 9899:2011 ，Information technology – Programming languages – C ISO/IEC 9899:1999，Programming languages – C https://zh.wikipedia.org/wiki/%E6%9C%AA%E5%AE%9A%E4%B9%89%E8%A1%8C%E4%B8%BA https://imzlp.me/posts/15272/ https://en.wikipedia.org/wiki/Undefined_behavior#Examples_in_C_and_C++ Undefined behavior can result in time travel. 27 Jun 2014 [2015-03-09]. Lattner, Chris. What Every C Programmer Should Know About Undefined Behavior. LLVM Project Blog. LLVM.org. May 13, 2011 [May 24, 2011]. The Jargon File on “nasal demons”，未定义行为的一个可能后果。]]></content>
      <tags>
        <tag>语言标准</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[初探 UIViewController 生命周期]]></title>
    <url>%2F2017%2F12%2F%E5%88%9D%E6%8E%A2UIViewController-%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%2F</url>
    <content type="text"><![CDATA[对象的生命周期一直是开发者所需要关心的，教授 CS193p 的老师 Paul 也详细的讲述了 UIViewController 的生命周期。 环境 日期 Swift Xcode 2017/12/25 4.0 9.2 探究ViewController 的生命周期，其实指的是它控制的视图（View）的生命周期。每当视图的状态发生变化时，视图控制器会自动调用一系列方法来响应变化。 通过这些方法，我们就可以跟踪到视图的整个生命周期。各个方法按执行顺序排列如下： InitializationStoryboard123OUTPUT:init(coder:)awakeFromNib() init(coder:) 当使用 Storyboard 时，控制器的构造器为 init(coder:) 该构造器为必需构造器，如果重写其他构造器，则必须重写该构造器。 该构造器为可失败构造器，即有可能构造失败，返回 nil。 该方法来源自 NSCoding 协议，而 UIViewController 遵从这一协议。 该方法被调用意味着控制器有可能（并非一定）在未来会显示。 在控制器生命周期中，该方法只会被调用一次。 awakeFromNib() 当使用 Storyboard 时，该方法会被调用。 当调用该方法时，将保证所有的 outlet 和 action 连接已经完成。 该方法内部必须调用父类该方法，虽然默认实现为空，但 UIKit 中许多类的该方法为非空。 由于控制器中对象的初始化顺序不能确定，所以构造器中不应该向其他对象发送消息，而应当在 awakeFromNib() 中安全地发送。 通常使用 awakeFromNib() 可以进行在设计时无法完成的必要额外设置。 Code12OUTPUT:init(nibName:bundle:) - NibName: nil, Bundle: nil init(nibName:bundle:) 当使用纯代码创建控制器，控制器的构造器为 init(nibName:bundle:) 虽然使用代码创建时调用了该构造器，但传入的参数均为 nil。 loadView() loadView() 即加载控制器管理的 view（视图初始化） 不应该直接调用该方法，而是由系统自动调用。当 view 被请求却为 nil 时，该方法加载并创建 view。 若控制器有关联的 Nib 文件，该方法会从 Nib 文件中加载 view；如果没有，则创建空白 UIView 对象。 如果使用 Interface Builder 创建 view，则务必不要重写该方法。 可以使用该方法手动创建视图，且需要将根视图分配为 view；重写 loadView 方法不应该再调用父类的该方法。 执行其他初始化操作，建议放在 viewDidLoad() 中。 viewDidLoad() view 被加载到内存后调用 viewDidLoad() 重写该方法需要首先调用父类该方法。 该方法中可以额外初始化控件，例如移除一些视图，添加子控件，添加约束，修改数据等。 该方法被调用意味着控制器有可能（并非一定）在未来会显示。 在控制器生命周期中，该方法只会被调用一次。 viewWillAppear(_:) 该方法在控制器 view 即将添加到视图层次时以及展示 view 时所有动画配置前被调用。 重写该方法需要首先调用父类该方法。 该方法中可以进行操作即将显示的 view，例如改变当前屏幕方向或状态栏的风格。 该方法被调用意味着控制器将一定会显示。 在控制器生命周期中，该方法可能会被多次调用。 注意⚠️： 如果控制器 A 被展示在另一个控制器 B 的 popover 中，那么控制器 B 不会调用该方法，直到控制器 A 清除。 viewWillLayoutSubviews() 该方法在通知控制器将要布局 view 的子控件时调用。 每当视图的 bounds 改变，view 将调整其子控件位置。 该方法可重写以在 view 布局子控件前做出改变。 该方法的默认实现为空。 该方法调用时，AutoLayout 未起作用。 在控制器生命周期中，该方法可能会被多次调用。 viewDidLayoutSubviews() 该方法在通知控制器已经布局 view 的子控件时调用。 该方法可重写以在 view 布局子控件后做出改变。 该方法的默认实现为空。 该方法调用时，AutoLayout 已经完成。 在控制器生命周期中，该方法可能会被多次调用。 viewDidAppear(_:) 该方法在控制器 view 已经添加到视图层次时被调用。 重写该方法需要首先调用父类该方法。 我们可以在这个方法中，对视图做一些关于展示效果方面的修改。 在控制器生命周期中，该方法可能会被多次调用。 viewWillDisappear(_:) 该方法在控制器 view 将要消失、被覆盖或是隐藏时调用。 类似 viewWillAppear(_:) 该方法可重写以提交变更，取消视图第一响应者状态。 viewDidDisappear(_:) 该方法在控制器 view 已经消失、被覆盖或是隐藏时调用。 类似 viewDidAppear(_:) 该方法可重写以清除或隐藏控件。 viewVillUnload&amp;&amp;viewDidUnload 自 iOS6 起，viewWillUnload 和 viewDidUnload 这两个方法被废除了。当系统发出内存警告的时候，会自动把 view 给清除掉，不用我们再特别处理。 同时系统还会调用 didReceiveMemoryWarning 方法通知视图控制器，我们可以在这里面进行一些操作，来释放一些额外的资源。（通常来说不用操作，比较最占资源的 view 已经被系统给清理了。） didReceiveMemoryWarning() 当内存预警时，该方法被调用。 不能直接手动调用该方法。 该方法可重写以释放资源、内存。 deinit 控制器销毁时（离开堆），调用该方法。 视图状态的转换在实际应用中，视图通常不会按照上面列的流程一次执行下来，可能会在可见与不可见的状态间互相转换。比如一开始视图是可见的，接着我们跳转到另一个 ViewController，这时原来视图就变成不可见的。后面我们又跳转回来，那么这个视图就又是可见的。 当视图的可见性发生变化时，视图控制器对应的方法也会随之响应。具体可见下图： Appearing 和 Disappearing 这两个状态是可以互相转化的 测试样例1.ViewController 是首页视图控制器，我们将里面所有的与生命周期有关的函数都打印出来。 2.同时 ViewController 中添加了一个“跳转”按钮，点击后跳转到另一个视图控制器AnotherViewController。3.AnotherViewController 里有个“返回”按钮，点击又会回到前一个页面。 测试代码ViewController.swift 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455import UIKit class ViewController: UIViewController &#123; //视图初始化 override func loadView() &#123; super.loadView() print("loadView") &#125; //视图加载完成 override func viewDidLoad() &#123; super.viewDidLoad() print("viewDidLoad") //创建跳转按钮 let button:UIButton = UIButton(type: .System) button.frame=CGRectMake(10, 50, 100, 30) button.setTitle("跳转", forState: .Normal) button.addTarget(self,action:#selector(jump),forControlEvents:.TouchUpInside) self.view.addSubview(button); &#125; //视图将要出现的时候执行 override func viewWillAppear(animated: Bool) &#123; print("viewWillAppear") &#125; //视图显示完成后执行 override func viewDidAppear(animated: Bool) &#123; print("viewDidAppear") &#125; //视图将要消失的时候执行 override func viewWillDisappear(animated: Bool) &#123; print("viewWillDisappear") &#125; //视图已经消失的时候执行 override func viewDidDisappear(animated: Bool) &#123; print("viewDidDisappear") &#125; //收到内存警告时执行 override func didReceiveMemoryWarning() &#123; super.didReceiveMemoryWarning() &#125; //跳转到另一个视图 func jump()&#123; print("点击按钮，开始跳转！") let anotherVC = AnotherViewController() presentViewController(anotherVC, animated: true, completion: nil) &#125;&#125; AnotherViewController.swift 12345678910111213141516171819202122232425import UIKit class AnotherViewController: UIViewController &#123; override func viewDidLoad() &#123; super.viewDidLoad() //创建返回按钮 let button:UIButton = UIButton(type: .System) button.frame=CGRectMake(10, 150, 100, 30) button.setTitle("返回", forState: .Normal) button.addTarget(self,action:#selector(back),forControlEvents:.TouchUpInside) self.view.addSubview(button); &#125; //返回之前视图 func back()&#123; print("点击按钮，开始返回！") self.dismissViewControllerAnimated(true, completion: nil) &#125; override func didReceiveMemoryWarning() &#123; super.didReceiveMemoryWarning() &#125;&#125; 运行测试从 ViewController 跳到 AnotherViewController，再从 AnotherViewController 跳回 ViewController。整个控制台打印出来的流程如下： 12345678910loadViewviewDidLoadviewWillAppearviewDidAppear点击按钮，开始跳转！viewWillDisappearviewDidDisappear点击按钮，开始返回！viewWillAppearviewDidAppear NoteRotation OUTPUT: willTransition(to:with:) viewWillLayoutSubviews() - Optional((67.5, 269.5, 240.0, 128.0)) viewDidLayoutSubviews() - Optional((213.5, 123.5, 240.0, 128.0)) viewWillLayoutSubviews() - Optional((213.5, 123.5, 240.0, 128.0)) viewDidLayoutSubviews() - Optional((213.5, 123.5, 240.0, 128.0)) viewWillLayoutSubviews() - Optional((213.5, 123.5, 240.0, 128.0)) viewDidLayoutSubviews() - Optional((213.5, 123.5, 240.0, 128.0)) 当 view 转变，会调用 willTransition(to:with:) 方法。 当屏幕旋转，view 的 bounds 改变，其内部的子控件也需要按照约束调整为新的位置，因此也调用了 viewWillLayoutSubviews() 和 viewDidLayoutSubviews() Present &amp; Dismiss OUTPUT: viewWillDisappear viewDidDisappear viewDidDisappear viewWillAppear viewDidAppear 当在一个控制器内 Present 新的控制器，原先的控制器并不会销毁，但会消失，因此调用了 viewWillDisappear 和 viewDidDisappear 方法。 如果新的控制器 Dismiss，即清除自己，原先的控制器会再一次出现，因此调用了其中的 viewWillAppear 和 viewDidAppear 方法。 Endless loop123456789class LoopViewController: UIViewController &#123; override func loadView() &#123; print(#function) &#125; override func viewDidLoad() &#123; print(#function) let _ = view &#125;&#125; OUTPUT: loadView() viewDidLoad() loadView() viewDidLoad() loadView() viewDidLoad() loadView() viewDidLoad() loadView() 若 loadView() 没有加载 view，viewDidLoad() 会一直调用 loadView() 加载 view，因此构成了死循环，程序即卡死。 Reference CS193P_2017 UIViewController 相关生命周期总结 UIViewController生命周期详解]]></content>
      <tags>
        <tag>Swift</tag>
        <tag>UIkit</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[音乐外链播放器推荐]]></title>
    <url>%2F2017%2F12%2F%E4%BC%98%E7%A7%80%E9%9F%B3%E4%B9%90%E5%A4%96%E9%93%BE%E6%92%AD%E6%94%BE%E5%99%A8%E6%8E%A8%E8%8D%90%2F</url>
    <content type="text"><![CDATA[之前寻找音乐外链，最开始选择的是网易云。但是，网易云功能也太少了，实在忍不了。 前言根据互联网定律之一，既然存在比国内优秀的服务，那么应该也被封得差不多了。（逃 正文话不多说，开始了！ 不对，先婊一下网易云的外链。 这个看起来还好，歌单视图看着像是多少年前的东西了，丑的要死。 Spotify 外链获取作为Spotify的老用户，第一个自然是要推荐它的。（五毛一条） 不过由于版权原因，非付费用户只能听30秒就要切换到下一首歌 首先打开网页播放窗口，神清气爽的界面映入我们眼帘： 搜索喜欢的歌，或者专辑，然后：Copy Playlist link 接下来去往开发者中心，粘贴之前复制的播放列表： 去下方自定义样式然后复制下面的iframe标签，放入html5即可，此方法通用，下文不会再涉及。 效果展示 Soundcloud 外链获取 Soundcloud是一家来自德国的音乐服务商，首先去Soundcloud，搜索喜欢的歌或者专辑，然后点击share 选择Embed，自己自定义喜欢的样式，然后复制code。 效果展示 mixcloud 外链获取 这是来自英国的服务商，服务也很不错，不过是用户自己创作的音乐较多。 网址在这里，同样是搜索歌曲，然后选择share，然后选择具体样式 效果展示 soundsgood 外链获取这是我最推荐的一个，不仅可以切换来源，还可以播放视频。如果你可以绕过GFW,你就会发现这是世界上最好的选择 首先还是打开Soundsgood，自己折腾注册和账号绑定。 自己创建歌单，自定义封面，然后点击EMBED获取外链 效果展示 应该有墙 结尾估计要被喜欢网易云音乐的人们萌豚打死了（逃]]></content>
  </entry>
  <entry>
    <title><![CDATA[iOS降级通用教程]]></title>
    <url>%2F2017%2F12%2FiOS%E9%99%8D%E7%BA%A7%E9%80%9A%E7%94%A8%E6%95%99%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[此文只设计如何降级到可联网验证的版本，适合纯小白。想要降级到iOS10，9，8请自行SHSH 前言：此文之说明如何降级何关闭更新提示，越狱后请自行探索(ง๑ •̀_•́)ง 准备工作 一部未越狱iPhone的且系统版本高于iOS11.1.2 一台安装了iTunes且可联网的电脑（最好是你自己的） 一根可连接电脑和iTunes的数据线 一双没有瞎的眼睛 如果没有，还请准备完毕后开始教程(´_ゝ`) 开始降级查询可降级验证版本在查询iOS固件状态后 发现iOS目前可支持验证更新的最低版本是iOS11.0.1，由于每年苹果都会陆续关闭验证通道，所以推荐尽快完成降级。 备份手机资料 安全起见，手机有价，数据无价。我们首先应该进行备份。首先连接手机到电脑，打开iTunes，点击资料库左边的手机样式，在左边设置里面选择摘要—备份，然后点击立即备份到电脑。 这个时候只需等待即可，通常来讲，文件越多，备份所需时间也会越长。具体备份文件地址请访问Apple支持 下载固件 我推荐iOS11.1版本，即将在圣诞节发布的越狱工具首先就是iOS11.1测试成功，为了稳定我推荐iOS11.1版本 首先确认自己的手机版本号，在手机背后下面即可看到产品型号。 一定要确定自己的型号！！ iPhone版本 手机型号&amp;&amp;下载固件 iPhone 8 Plus A1864 iPhone 8 A1863 iPhone 7 Plus A1784， A1661,A1786 iPhone 7 A1778，A1660,A1780 iPhone SE A1723,A1724 iPhone 6s Plus A1699,A1634,A1687 iPhone 6s A1700,A1688,A1633 iPhone 6 Plus A1524,A1522,A1593 iPhone 6 A1586,A1549,A1589 iPhone 5S A1533,A1453， A1518,A1528,A1530,A1457 关闭查找我的设备 前往“设置”&gt;“[您的名字]”&gt;“iCloud”（或“设置”&gt;“iCloud”），然后关闭“查找我的 [iPhone]”。 输入iCloud账号密码，点击关闭 开始刷机降级设备连接iTunes，进入设备详情页面之后查看 如果和我一样是最新版系统，只能通过按住键盘Shift键（Mac电脑按住Control ⌃键）点击【恢复iPhone】，然后选中之前下好的固件（ipsw格式），你的手机将会重置，所以务必前往“设置”&gt;“[您的名字]”&gt;“iCloud”（或“设置”&gt;“iCloud”）查看是否开启了iCloud备份个人数据。 如果你未更新最新版本，检查更新按钮应该是更新，那么按住键盘Shift键（Mac电脑按住Control ⌃键）点击更新将会保留原本的数据，同样选择之前下载的固件进行更新（实际是降级） 静静等待奇迹发生吧，如果失败，你还有备份，还原就好。 关闭手机自动更新降级成功的第一件事就是先关闭手机的系统更新 打开safari，地址栏输入: 1https://oldcat.me/web/NOOTA9.mobileconfig 然后回车按照要求安装此描述文件即可，然后重启，点击检查更新你就会发现目前你的系统是最新版本。]]></content>
      <tags>
        <tag>iOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[I Wish you a Merry Christmas]]></title>
    <url>%2F2017%2F12%2FI-wish-you-a-Merry-Christmas%2F</url>
    <content type="text"><![CDATA[圣诞节快乐米娜桑ε٩(๑&gt; ₃ &lt;)۶з～ 又是一年圣诞季，祝大家都能开开心心的～ 有男女朋友的除外 冬が来る——嬉しくて切ない、永遠の一瞬が 年末总结今年年初过得还不错吧，经历过高考复习的紧张和压抑，枯燥但充实。反省一下高考前还一直通宵打游戏 也感受到了毕业后的放松和对大学的期待。感谢高中三年的同学友谊，无论是17班还是11班，都是我的一份记忆。前者给了我深刻的记忆，后者则给了我永久的回忆。特别感谢你，陪我度过的那些日子，尽管结局不太美好但我希望你在未来会过上你喜欢的生活。 高考成绩不好评判，总之在意料之中吧。进了大学认识了很多小伙伴，也加入了计协这个大家庭，同时也感受到了来自优秀学长们的压力。有压力才有动力，虽然一直在熬夜通宵，学到了很多东西，我也在尽力朝我喜欢的方向发展，但是高数挂了。 一切还算满意，只不过感情很不顺利，希望尽早能找到能一个陪我的人。自己确实感觉到有些孤单 喜欢我的赶紧表白啊，我永远喜欢成熟的小姐姐（发文章的时候记得删掉这一条 希望我在乎的人能开开心心的。我讨厌的人的妈年末买菜必定超级涨价。 圣诞礼物圣诞礼物就是给大家推荐一个网址人工智能图片放大，以后大家碰见喜欢的图，但是又找不到高清图，就可以用这个试试哟～ 然后再送大家几张冬季壁纸（会陆续更新 作品名/Title: ﾒﾘｸﾘ🍥🎀插画作者/Artist: ダンミルC93 🍤3日目東シ71b‏ 原始尺寸/Pic Size: 700 × 904px 放大后尺寸/After Enlarge Size: 8x倍放大 5600 × 7232px 来源链接Illustration ID: 8x倍放大 5600 × 7232 像素高清版（17.3 MB） 下载8x 4x倍放大 2800 × 3616 像素高清版（6 MB） 下载4x 作品名/Title: サンタ榛名描きました插画作者/Artist: 京極燈弥＠金曜東ヤ02ｂ 原始尺寸/Pic Size: 724 × 1023px 放大后尺寸/After Enlarge Size: 2x倍放大 1448 × 2046px 4x放大 2896 × 4092px 2x倍放大 1448 × 2046 像素高清版（0.45 MB） 下载2x 4x倍放大 2896 × 4092 像素高清版（1.2 MB） 下载4x 作品名/Title: 動く、動く插画作者/Artist: ガゥ 🐺2日目H-11a 原始尺寸/Pic Size: 1073×985px 放大后尺寸/After Enlarge Size: 8x倍放大 8584 × 7880px 来源链接/Illustration ID: 描述/Description：少女終末旅行のチト×ユーリ可愛いぃ!! 冬コミ新刊にちょこっと載ります… 8x倍放大 8584 × 7880 像素高清版（3 MB） 下载8x 4x倍放大 4292 × 3940 像素高清版（1.1 MB） 下载4x 作品名/Title: Alter插画作者/Artist: TID原始尺寸/Pic Size: 1000×1520px 放大后尺寸/After Enlarge Size: 4x倍放大 4000 × 6080px 来源链接/Illustration ID: 4x倍放大 4000 × 6080 像素高清版（14.2 MB） 下载4x 2x倍放大 2000 × 3040 像素高清版（4.9 MB） 下载2x 更新结束～算了找不到女朋友就找不到吧]]></content>
      <tags>
        <tag>日常</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[c语言课后实验作业9]]></title>
    <url>%2F2017%2F12%2Fc%E8%AF%AD%E8%A8%80%E8%AF%BE%E5%90%8E%E5%AE%9E%E9%AA%8C%E4%BD%9C%E4%B8%9A9%2F</url>
    <content type="text"><![CDATA[今天算是见识到了某人的恶心之处 基础练习以后基本上都只会放源码了，因为我想把这个博客做得更具有偏向性，可能以后会全部单独在一篇文章中更新 甚至未来有可能会删除作业内容 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;#include &lt;ctype.h&gt;/*2.1*/void maxmin(int *data, int *max, int *min, int len)&#123; int i; *max=data[0]; *min=data[0]; for(i=0;i&lt;len;i++) &#123; if(data[i]&gt;*max) *max=data[i]; if(data[i]&lt;*min) *min=data[i]; &#125;&#125;/*2.2*/int count(char* string)&#123; int i; int c=0; for(i=0;string[i]!=0;i++) if((string[i]&gt;='a'&amp;&amp;string[i]&lt;='z')||(string[i]&gt;='A'&amp;&amp;string[i]&lt;='Z')) c++; return c;&#125;/*2.3*/int del(int *data,int n,int en)&#123; int i,j; int m=0; for(i=0;i&lt;en;i++) if(data[i]==n) &#123; for (j=i; j&lt;en-i; j++) &#123; data[j]=data[j+1]; &#125; m++; &#125; return en-m;&#125;/*2.4*/int search(int *data, int n, int len)&#123; int i; for(i=0;i&lt;len;i++) &#123; if(n==data[i]) return i; &#125; return -1;&#125;/*2.5*/void delch1(char* string)&#123; int i,j; char ch; fflush(stdin); printf("输入要删除的字符"); scanf("%c",&amp;ch); fflush(stdin); for(i=0;i&lt;strlen(string);i++) &#123; if(string[i]==ch) &#123; j=i; break; &#125; &#125; for(i=j;i&lt;strlen(string)-1;i++) string[i]=string[i+1]; string[strlen(string)-1]=0;&#125;/*2.6*/int searchch(char* string, char ch)&#123; int i; for (i = 0; string[i]; i++) &#123; if (string[i] == ch) return i; &#125; return -1;&#125;/*2.7*/void reverse(int *data, int len)&#123; int i; int a; for(i=0;i&lt;len/2;i++) &#123; a=data[i]; data[i]=data[len-i-1]; data[len-i-1]=a; &#125;&#125;/*2.8*/int changeS(char *string)&#123; unsigned int i; int j=0; int num=0; int a[1024]; for(i=0;string[i];i++) if(string[i]&gt;='0'&amp;&amp;string[i]&lt;='9') a[j++]=string[i]-48; if(string[0]=='-') &#123; for(i=0;i&lt;strlen(string)-1;i++) num+=a[i]*(int)pow(10,strlen(string)-i-2); num=num*-1; &#125; else &#123; for(i=0;i&lt;strlen(string);i++) num+=a[i]*(int)pow(10,strlen(string)-i-1); &#125; return num; &#125;/*2.9*/void swap(int *data,int len)&#123; int n; int i; int j=0,k=0; for(i=0;i&lt;len;i++) &#123; if(data[k]&gt;data[i]) k=i; if(data[j]&lt;data[i]) j=i; &#125; n=data[0]; data[0]=data[k]; data[k]=n; n=data[len-1]; data[len-1]=data[j]; data[j]=n; &#125;/*2.10*//*#include &lt;stdio.h&gt; #include &lt;string.h&gt; #include &lt;stdlib.h&gt; #define N 10 void strsort(char* s[],int n) &#123; int i,j,k; char* temp=NULL; for(i=0;i&lt;n-1;i++) &#123; k=i; for(j=i+1;j&lt;n;j++) if(strcmp(s[j],s[k])&lt;0) k=j; if(k!=i) &#123; temp=s[i]; s[i]=s[k]; s[k]=temp; &#125; &#125; &#125; void main() &#123; char *s[N],**p=NULL; int i; for(i=0; i&lt;N; i++) &#123; s[i]=(char*)malloc(sizeof(char)*20); gets(s[i]); &#125; strsort(s,N); p=s; for(i=0; i&lt;N; i++) &#123; printf("%s\n",*p++); free(s[i]); &#125; &#125;*//*2.11*/char *strin(char* s1,char* s2)&#123; int i,j; int k; for(i=0;s1[i];i++) &#123; j=1; if(s2[0]==s1[i]) &#123; for(k=0;s2[k];k++) if(s2[k]!=s1[i+k]) j=0; if(j!=0) return &amp;s1[i]; &#125; &#125; return 0;&#125;/*2.12*/void change(char *string)&#123; int i; for(i=0;string[i];i++) string[i]=isupper(string[i]);&#125;/*2.13*/int stringlen(char* string)&#123; int i; for(i=0;string[i];i++); return i; &#125;int main()&#123; return 0;&#125; 提醒大家一句，老师只是一个职业，好自为知 进阶练习123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480//Xcode自动添加的时候就是双引号，懒得改，反正都一样#include "stdio.h"#include "stdlib.h"#include "string.h"#include "ctype.h"/*3.1*/void stringcpy(char *to, char *from)&#123; while((*(to++)=*(from++))!=0);&#125;/*3.2*/void merge(int *a,int n,int *b,int m,int *c)&#123; int i,j; for(i=j=0; i&lt;n&amp;&amp;j&lt;m; ) *c++=a[i]&lt;b[j]?a[i++]:b[j++]; while(i&lt;n) *c++=a[i++]; while(j&lt;m) *c++=b[j++]; &#125;/*3.3*/void mstrcpy(char *src,char *des,int m)&#123; int i,j; for(i=0, j=m; src[j-1]; i++, j++) des[i]=src[j];&#125;/*3.4（1）*/int FindMax1(int (*data)[4])&#123; int i,j; int m=0,n=0; for(i=0;i&lt;3;i++) for(j=0;j&lt;4-1;j++) if(*(*(data+m)+n)&lt;*(*(data+i)+j)) &#123; n=j; m=i; &#125; return data[m][n];&#125;/*3.4（2）*/int FindMax2(int *data)&#123; int i; int n=0; for(i=0;i&lt;12;i++) if(*(data+n)&lt;*(data+i)) n=i; return data[n];&#125;/*3.5*/void minvert(int (*maxtrix)[5])&#123; int i,j; int t; for(i=0;i&lt;5;i++) for(j=i;j&lt;5;j++) &#123; t=maxtrix[i][j]; maxtrix[i][j]=maxtrix[j][i]; maxtrix[j][i]=t; &#125;&#125;/*3.6*/void dresort(int *data, int len)&#123; int i,j=0,k=0; int m[4]; int n[5]; for(i=0;i&lt;len-1;i+=2) &#123; n[j++]=data[i]; m[k++]=data[i+1]; &#125; if(len%2==1) &#123; n[j]=data[len-1]; for(i=0;i&lt;len/2;i++) &#123; data[i]=n[i]; data[len/2+i+1]=m[i]; &#125; data[len/2]=n[len/2]; &#125; else &#123; for(i=0;i&lt;len/2;i++) &#123; data[i]=n[i]; data[len/2+i]=m[i]; &#125; &#125;&#125;/*3.7*/void change(int (*m)[5])&#123; int t; int a=0,b=0; int i,j; for(i=0;i&lt;5;i++) for(j=0;j&lt;5;j++) if(m[a][b]&gt;m[i][j]) &#123; a=i; b=j; &#125; if(a!=0||b!=0) &#123; t=m[a][b]; m[a][b]=m[0][0]; m[0][0]=t; &#125; a=0,b=4; for(i=0;i&lt;5;i++) for(j=0;j&lt;5;j++) if(m[a][b]&gt;m[i][j]&amp;&amp;(i!=0||j!=0)) &#123; a=i; b=j; &#125; if(a!=0||b!=4) &#123; t=m[a][b]; m[a][b]=m[0][4]; m[0][4]=t; &#125; a=4,b=0; for(i=0;i&lt;5;i++) for(j=0;j&lt;5;j++) if(m[a][b]&gt;m[i][j]&amp;&amp;(i!=0||j!=0)&amp;&amp;(i!=0||j!=4)) &#123; a=i; b=j; &#125; if(a!=4||b!=0) &#123; t=m[a][b]; m[a][b]=m[4][0]; m[4][0]=t; &#125; a=4,b=4; for(i=0;i&lt;5;i++) for(j=0;j&lt;5;j++) if(m[a][b]&gt;m[i][j]&amp;&amp;(i!=0||j!=0)&amp;&amp;(i!=0||j!=4)&amp;&amp;(i!=4||j!=0)) &#123; a=i; b=j; &#125; if(a!=0||b!=0) &#123; t=m[a][b]; m[a][b]=m[4][4]; m[4][4]=t; &#125; a=2,b=2; for(i=0;i&lt;5;i++) for(j=0;j&lt;5;j++) if(m[a][b]&lt;m[i][j]) &#123; a=i; b=j; &#125; if(a!=0||b!=0) &#123; t=m[a][b]; m[a][b]=m[2][2]; m[2][2]=t; &#125; &#125;/*3.8(1)*/void stuave(float (*score)[5],float ave[10],int n)&#123; int i,j; float sum=0.0; for(i=0;i&lt;n;i++) &#123; sum=0; for(j=0;j&lt;5;j++) sum+=score[i][j]; ave[i]=sum/5; &#125;&#125;/*3.8(2)*/void mscore(float(*score)[5],int *s, int *c)&#123; int i,j; float m=score[0][0]; for(i=0;i&lt;5;i++) for(j=0;j&lt;5;j++) if(m&lt;score[i][j]) &#123; m=score[i][j]; *s=i; *c=j; &#125;&#125;/*3.9*/void sorts(char *(string[1024]),int n)&#123; int i,j; char *t; for(i=0;i&lt;n-1;i++) for(j=0;j&lt;n-1-i;j++) if(strcmp(string[j],string[j+1])&gt;0) &#123; t=string[j]; string[j]=string[j+1]; string[j+1]=t; &#125;&#125;/*3.10*/int fnums(char *str, int *num)&#123; int i,m; int j=0; int k=0; char n[10]=&#123;0&#125;; for(i=0;i&lt;30;i++) num[i]=0; for(i=0;str[i];i++) &#123; for(k=0;str[i]&gt;='0'&amp;&amp;str[i]&lt;='9';i++,k++) &#123; n[k]=str[i]; &#125; if(k!=0) &#123; for(m=k-1;m&gt;=0;m--) num[j]+=(n[m]-'0')*(int)pow(10,k-1-m); j++; &#125; for(;k&gt;=0;k--) n[k]=0; &#125; return j;&#125;/*3.11*/int scmp(char *p1,char *p2)&#123; int i; for(i=0;p1[i]&amp;&amp;p2[i];i++) if(p1[i]-p2[i]!=0) return p1[i]-p2[i]; if(strlen(p1)&gt;strlen(p2)) return p1[i]; else return p2[i]; return 0;&#125;/*3.12*//*#include &lt;stdio.h&gt;char* pMonth[12]=&#123;&#123;"January"&#125;,&#123;"February"&#125;,&#123;"March"&#125;,&#123;"April"&#125;,&#123;"May"&#125;,&#123;"Jule"&#125;,&#123;"July"&#125;,&#123;"August"&#125;,&#123;"September"&#125;,&#123;"October"&#125;,&#123;"November"&#125;,&#123;"December"&#125;&#125;;int main()&#123; while(1) &#123; int nMonth; scanf("%d",&amp;nMonth); if(nMonth&gt;12||nMonth&lt;1) &#123; printf("not found"); break; &#125; printf("\t%s\n",pMonth[nMonth-1]); &#125;&#125;*//*3.13*/void josephu(int *people)&#123; int n=0; int j=0; int m=0; for(;;j++) &#123; if(j&gt;29) j=0; if(people[j]!=0) m++; else continue; if(m==9) &#123; people[j]=0; m=0; n++; &#125; if(n&gt;=15) break; &#125;&#125;/*3.14*/int fact(int x,int *f)&#123; int i; int n=0; for(i=2;i&lt;x;i++) &#123; if(i%2==0) if(x%i==0) f[n++]=i; &#125; f[n]=0; return n;&#125;/*3.15*/void zprocess(int *data,int len)&#123; int i,j; int t; for(i=0;i&lt;len;i++) if(data[i]==0) for(j=i;j&lt;len-1;j++) &#123; t=data[j]; data[j]=data[j+1]; data[j+1]=t; &#125;&#125;/*3.16*/int fwords(char *string,char (*words)[1024])&#123; int i,j; int count=0; for(i=0;string[i];i++) if(string[i]&gt;='a'&amp;&amp;string[i]&lt;='z'||string[i]&gt;='A'&amp;&amp;string[i]&lt;='Z') &#123; for(j=0;string[i]&gt;='a'&amp;&amp;string[i]&lt;='z'||string[i]&gt;='A'&amp;&amp;string[i]&lt;='Z';i++,j++) words[count][j]=string[i]; words[count][j]=0; count++; &#125; return count;&#125;/*3.17*/void stringcat(char *str1,char *str2)&#123; int i; int n; for(n=0;str1[n];n++); for(i=0;str2[i];i++) str1[n-1+i]=str2[i]; str1[n-1+i]=0;&#125;/*3.18*/void stringvert(char *str)&#123; int i,j; char t; for(i=0;str[i];i++); for(j=0;j&lt;i/2;j++) &#123; t=str[j]; str[j]=str[i-1-j]; str[i-j-1]=t; &#125; str[i]=0; &#125;/*3.19*/void svowel(char *s1,char *s2)&#123; int i,j=0; for(i=0;s1[i];i++) if(s1[i]=='a'||s1[i]=='e'||s1[i]=='i'||s1[i]=='o'||s1[i]=='u') s2[j++]=s1[i]; s2[j]=0;&#125;/*3.20*/void strsta(char* string,int* num)&#123; int i; for(i=0;string[i];i++) &#123; if((string[i]&gt;='a'&amp;&amp;string[i]&lt;='z')||string[i]&gt;='A'&amp;&amp;string[i]&lt;='Z') num[0]++; else if(string[i]&gt;='0'&amp;&amp;string[i]&lt;='9') num[1]++; else if(string[i]==' ') num[2]++; else num[3]++; &#125;&#125;/*3.21*/void wpos(char *string, int *begin, int *end)&#123; int i,j; int m=0; for(i=0;string[i];i++) &#123; for(j=0;string[i]&gt;='a'&amp;&amp;string[i]&lt;='z'||string[i]&gt;='A'&amp;&amp;string[i]&lt;='Z';j++,i++); if(j&gt;m) &#123; m=j; *begin=i-j; *end=i-1; &#125; &#125;&#125;/*3.22*/void sortno(char (*stuno)[11],int n)&#123; int i,j; char num[11]; for(i=0;i&lt;n-1;i++) for(j=0;j&lt;n-1-i;j++) if(strcmp(stuno[j],stuno[j+1])&gt;0) &#123; strcpy(num,stuno[j]); strcpy(stuno[j],stuno[j+1]); strcpy(stuno[j+1],num); &#125;&#125;/*3.23*/int searchno(char (*stuno)[11],char *no,int n)&#123; int i,j; int m; for(i=0;i&lt;n;i++) &#123; m=0; for(j=0;j&lt;11;j++) if(stuno[i][j]!=no[j]) &#123; m=1; break; &#125; if(m==0) return i; &#125; return -1;&#125;int main()&#123; return 0;&#125;]]></content>
      <tags>
        <tag>c语言</tag>
        <tag>c语言作业</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[如何给自有域名添加上https服务]]></title>
    <url>%2F2017%2F12%2F%E5%A6%82%E4%BD%95%E7%BB%99%E8%87%AA%E6%9C%89%E5%9F%9F%E5%90%8D%E6%B7%BB%E5%8A%A0%E4%B8%8Ahttps%E6%9C%8D%E5%8A%A1%2F</url>
    <content type="text"><![CDATA[从Chrome56左右开始，对于没有HTTPS的网站，都不会出现一把小绿锁。反之，有了小绿锁的网站，标志着这个网站是HTTPS安全的。 简介什么是https超文本传输安全协议（英语：Hypertext Transfer Protocol Secure，缩写：HTTPS，常称为HTTP over TLS，HTTP over SSL或HTTP Secure）是一种通过计算机网络进行安全通信的传输协议。HTTPS经由HTTP进行通信，但利用SSL/TLS来加密数据包。HTTPS开发的主要目的，是提供对网站服务器的身份认证，保护交换数据的隐私与完整性。这个协议由网景公司（Netscape）在1994年首次提出，随后扩展到互联网上。 历史上，HTTPS连接经常用于万维网上的交易支付和企业信息系统中敏感信息的传输。在2000年代晚期和2010年代早期，HTTPS开始广泛使用于保护所有类型网站上的网页真实性，保护账户和保持用户通信，身份和网络浏览的私密性。 与HTTP的差异 与HTTP的URL由“http://”起始且默认使用端口80不同，HTTPS的URL由“https://”起始且默认使用端口443。 HTTP是不安全的，且攻击者通过监听和中间人攻击等手段，可以获取网站帐户和敏感信息等。HTTPS被设计为可防止前述攻击，并在正确配置时被认为是安全的。 更多资料 步骤注册Cloudflare Cloudflare是国外非常有名的一家网络服务提供商。它提供的其中一项免费服务就是给我们自有域名加上HTTPS。正好符合我们的需求。 注册成功后添加自己的域名。会有三角形的⚠️标示，这代表Cloudflare没有检测到你域名NS的正确指向，不着急，我们解决。 更改DNS服务器地址 然后需要将我们的域名的DNS服务商的地址改成Cloudflare要求的两个DNS服务器地址。每个人分配的不一样，而且必须用分配的否则会失效。 如果域名提供商那里只有添加解析没有更改DNS服务器的选项。例：8a 清空解析，记住你的域名管理密码，然后去代理注册的域名商更改。例：新网 找到dns服务更改并保存，现在一般都是几分钟就生效了，最长也不过48小时 开启HTTPS 找到Crypto选项，这里我们需要开启Flexible的HTTPS选项。 其实Cloudflare做的事就是，当访问我们的域名的时候，实际上走的是Cloudflare的服务器，这个时候这个阶段的访问是有HTTPS的。然后Cloudflare再去请求我们实际的内容，再将内容返回给用户。这一段是没有HTTPS的。也就是实际上是半HTTPS。不过对于我们静态博客来说，这种半HTTPS实际上已经够我们使用了。 重定向 这个时候我们访问https://xxxxx.xxx自然走的是HTTPS。但是如果有人访问了http://xxxxx.xxx，那要如何跳转到HTTPS的页面呢？CloudFare另一个很棒的功能Page Rules就派上用场了。我们可以指定我们的域名强制使用HTTPS，并且当访问是HTTP的时候重定向到HTTPS。这样就能保证访问我们的页面都是通过HTTPS的了。 加入HSTS的列表我们访问自己的网站是走HTTP-&gt;304重定向-&gt;HTTPS。这个是浏览器跟服务器进行了一次通信之后才发生的跳转。我们也可以通过HSTS的Preload List使其访问的是HTTP，但是浏览器识别之后自动转成HTTPS访问，而不经过重定向那一层操作。 可以参考这篇文章对HSTS进行更深入的了解。简单来说，HSTS能够使我们的网站安全性更上一层楼。 还是CloudFare，自有的HSTS功能，开启之后就能很好的满足我们的需要。还是在Crypto选项下，开启HSTS 检查去HSTS Preload List的网站把我们的域名进行检查并收录（不能是子域名，必须是一级域名），如果没通过会给出修改建议，按照建议修改就行。如果通过了，就会放入审核列表。之后可以时不时回来看看自己的网站被收录了没有。我是等了快一周才被收录。网上的说法普遍是几天内（不过我几分钟就审核过了（逃。所以耐心等待收录。一旦被收录就会应用到主流浏览器上，这样你的网站就是更加安全的网站了。 总结因为是Cloudflare的cdn加速，所以在国外访问速度很快，在国内访问的速度会稍慢一些。 话说国内啥时候能有这样的服务啊，万恶的资本主义]]></content>
      <tags>
        <tag>域名</tag>
        <tag>https</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[利用live 2d给博客添加看版娘]]></title>
    <url>%2F2017%2F12%2F%E5%88%A9%E7%94%A8live-2d%E7%BB%99%E5%8D%9A%E5%AE%A2%E6%B7%BB%E5%8A%A0%E7%9C%8B%E7%89%88%E5%A8%98%2F</url>
    <content type="text"><![CDATA[给你的网站加上女朋友 前言现实生活的你是不是没有女朋友呢？没关系，你可以给你自己网页上弄一个 live2d常常被我们用于做手机的动态壁纸增加萌点！live2dviewerex当然你也可以把她放到你的博客上！这样也很卡哇伊不是吗(/ω＼)live2d目前技术还不是很成熟 但是很适合用来做网站的看板娘 转载自@猫与向日葵和@JiuMeng，本人进行一定整合 获取模型&amp;调整：科普：Live2D是一种应用于电子游戏的绘图渲染技术，技术由日本Cybernoids公司开发。通过一系列的连续图像和人物建模来生成一种类似三维模型的二维图像，对于以动画风格为主的冒险游戏来说非常有用，缺点是Live 2D人物无法大幅度转身，开发商正设法让该技术可显示360度图像。首先既然是做live2d的看板娘怎么能少了最基础的模型呢！这里是本project的大概流程图： Live2d的模型（你喜欢的）[这里包含了声音调用以及其他的0.0]→官方或者修改的SDK（合成）→上传至网站相应目录→在相应位置插入 js css div以及其他附属→调整css→完工了！ 关于模型如何获取这里不详细讲解 以下为获取途径：1.百度贴吧 （live2d吧 live2dviewerex吧 ）这里面有很多模型 自己去看看吧！看看能不能找到你们的老婆2.在游戏里提取（注意版权问题）这些游戏都是由live2d引擎驱动的像在这些游戏里都能提取出模型 置于方法嘛（自己百度吧）说出来我怕菊花被人捅烂《樱花庄的宠物女孩》【2013/02/14】(角川游戏)PSP/PSV《某魔术和科学的群奏活剧》【2013/02/21】(NBGI)PSP《药水制作师》【2015/3/23】(Sinsiroad) 安卓/ios这里有篇讲如何提取《药水制作师》模型的文章：相关链接获取模型的格式 最好是moc的可编辑工程文件 当然lpk也行 但是lpk能不能用就看你的运气了这里讲讲如何打开模型查看模型需要使用LIVE2D官方提供的Live2D Viewer，下载和安装方法请查看 这个网页然后如果你下载（或者提取的）的是编工程文件的live2d的话 （json已经写好的）你可以吧json拖到live2d-viewer里面就可以预览模型了如果是lpk格式的文件的话 这里讲解一种（菊花被人捅烂的方法解lpk） 先下载好lpk然后用zip压缩工具查看打开这个lpk 然后解压里面的文件出来就可以得到moc 那样的模型了如果你下载的lpk是被加密过的那么这个方法就不能使用了（乖乖换老婆或者想其他办法吧） 提取 没有被加密的lpk解压出来是这样的： 红色部分为lpk配置文件这个不影响我们制作模型可以不管它 打开主题部分： 把这个拖进我们的Live2D Viewer你就会看到： 模型成功加载了！ 同样我们可以把别的模型也拖进去拖进live2d-viewer里 就可以预览模型了打开Live2D Viewer，将json或者moc （网页只调用json）拖入主窗口，可以看到模型已经加载成功，若有贴图错位、动作鬼畜等情况则为上一步的json文件配置有误，测试直到找到正确的模型、动作、贴图组合 有些模型是自带动作以及语音的这样可以测试动作： 选择要测试的动作，点击Playback播放动作以测试动作是否正常，勾选Loop可以循环播放模型测试好了之后就进入下一步吧！ 模型大概就到这里了 下面是主体部分： 准备SDK为了效率最大化，不用把有限的时间投入到与bug无限的斗争和踩坑中；为了不重复造轮子；为了爱与和平 就是因为懒，我们不使用官方的SDK，而是用@EYHN大佬封装好的库来加载并显示模型。相比较官方版本而言，仅需一条命令即可进行模型的加载，无疑方便许多。 但对于「药水制作师」这款游戏的模型来说，上面所说的库还需经过一些修改。 修改原因基于commit #fea64e4修改，修改内容：修复移动鼠标会触发点击事件的问题增加鼠标点击事件移除自带的眨眼动作增加久置动作与事件支持增加自定义HIT_AREA的方法由于原项目使用了GPL v2开源协议，修改后的代码已开源至GitHub，若想修改请参考项目hexo-helper-live2d 鉴于该项目仍在活跃开发中，@猫与向日葵修改的版本可能会随时间变化而过时 编译后的版本可以在这里下载： Download Now 以下部分内容为转载内容：提示功能（可选）这部分直接抄自之前的浮动小人，做了部分修改，非必须项，须jQuery支持若不启用此部分内容，下一步应作相应修改此处代码不可直接套用，应根据自身情况进行修改这里是为小人添加消息提示框的 此部分可以不做 当然你喜欢的话我也是不介意的少女盲目分析中 代码脚本将以下内容保存为waifu-tips.js，放至相应目录 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127function render(template, context) &#123; var tokenReg = /(\\)?\&#123;([^\&#123;\&#125;\\]+)(\\)?\&#125;/g; return template.replace(tokenReg, function (word, slash1, token, slash2) &#123; if (slash1 || slash2) &#123; return word.replace('\\', ''); &#125; var variables = token.replace(/\s/g, '').split('.'); var currentObject = context; var i, length, variable; for (i = 0, length = variables.length; i &amp;amp;amp;lt; length; ++i) &#123; variable = variables[i]; currentObject = currentObject[variable]; if (currentObject === undefined || currentObject === null) return ''; &#125; return currentObject; &#125;);&#125;String.prototype.render = function (context) &#123; return render(this, context);&#125;; var re = /x/;console.log(re);re.toString = function() &#123; showMessage('哈哈，你打开了控制台，是想要看看我的秘密吗？', 5000); return '';&#125;; $(document).on('copy', function ()&#123; showMessage('你都复制了些什么呀，转载要记得加上出处哦', 5000);&#125;); $.ajax(&#123; cache: true, url: "path/to/waifu-tips.json", dataType: "json", success: function (result)&#123; $.each(result.mouseover, function (index, tips)&#123; $(tips.selector).mouseover(function ()&#123; var text = tips.text; if(Array.isArray(tips.text)) text = tips.text[Math.floor(Math.random() * tips.text.length + 1)-1]; text = text.render(&#123;text: $(this).text()&#125;); showMessage(text, 3000); &#125;); &#125;); $.each(result.click, function (index, tips)&#123; $(tips.selector).click(function ()&#123; var text = tips.text; if(Array.isArray(tips.text)) text = tips.text[Math.floor(Math.random() * tips.text.length + 1)-1]; text = text.render(&#123;text: $(this).text()&#125;); showMessage(text, 3000); &#125;); &#125;); &#125;&#125;); (function ()&#123; var text; if(document.referrer !== '')&#123; var referrer = document.createElement('a'); referrer.href = document.referrer; text = 'Hello! 来自 &amp;amp;amp;lt;span style="color:#0099cc;"&amp;amp;amp;gt;' + referrer.hostname + '&amp;amp;amp;lt;/span&amp;amp;amp;gt; 的朋友'; var domain = referrer.hostname.split('.')[1]; if (domain == 'baidu') &#123; text = 'Hello! 来自 百度搜索 的朋友你是搜索 &amp;amp;amp;lt;span style="color:#0099cc;"&amp;amp;amp;gt;' + referrer.search.split('&amp;amp;amp;amp;wd=')[1].split('&amp;amp;amp;amp;')[0] + '&amp;amp;amp;lt;/span&amp;amp;amp;gt; 找到的我吗？'; &#125;else if (domain == 'so') &#123; text = 'Hello! 来自 360搜索 的朋友你是搜索 &amp;amp;amp;lt;span style="color:#0099cc;"&amp;amp;amp;gt;' + referrer.search.split('&amp;amp;amp;amp;q=')[1].split('&amp;amp;amp;amp;')[0] + '&amp;amp;amp;lt;/span&amp;amp;amp;gt; 找到的我吗？'; &#125;else if (domain == 'google') &#123; text = 'Hello! 来自 谷歌搜索 的朋友欢迎阅读&amp;amp;amp;lt;span style="color:#0099cc;"&amp;amp;amp;gt;『' + document.title.split(' - ')[0] + '』&amp;amp;amp;lt;/span&amp;amp;amp;gt;'; &#125; &#125;else &#123; if (window.location.href == 'https://imjad.cn/') &#123; //如果是主页 var now = (new Date()).getHours(); if (now &amp;amp;amp;gt; 23 || now &amp;amp;amp;lt;= 5) &#123; text = '你是夜猫子呀？这么晚还不睡觉，明天起的来嘛'; &#125; else if (now &amp;amp;amp;gt; 5 &amp;amp;amp;amp;&amp;amp;amp;amp; now &amp;amp;amp;lt;= 7) &#123; text = '早上好！一日之计在于晨，美好的一天就要开始了'; &#125; else if (now &amp;amp;amp;gt; 7 &amp;amp;amp;amp;&amp;amp;amp;amp; now &amp;amp;amp;lt;= 11) &#123; text = '上午好！工作顺利嘛，不要久坐，多起来走动走动哦！'; &#125; else if (now &amp;amp;amp;gt; 11 &amp;amp;amp;amp;&amp;amp;amp;amp; now &amp;amp;amp;lt;= 14) &#123; text = '中午了，工作了一个上午，现在是午餐时间！'; &#125; else if (now &amp;amp;amp;gt; 14 &amp;amp;amp;amp;&amp;amp;amp;amp; now &amp;amp;amp;lt;= 17) &#123; text = '午后很容易犯困呢，今天的运动目标完成了吗？'; &#125; else if (now &amp;amp;amp;gt; 17 &amp;amp;amp;amp;&amp;amp;amp;amp; now &amp;amp;amp;lt;= 19) &#123; text = '傍晚了！窗外夕阳的景色很美丽呢，最美不过夕阳红~'; &#125; else if (now &amp;amp;amp;gt; 19 &amp;amp;amp;amp;&amp;amp;amp;amp; now &amp;amp;amp;lt;= 21) &#123; text = '晚上好，今天过得怎么样？'; &#125; else if (now &amp;amp;amp;gt; 21 &amp;amp;amp;amp;&amp;amp;amp;amp; now &amp;amp;amp;lt;= 23) &#123; text = '已经这么晚了呀，早点休息吧，晚安~'; &#125; else &#123; text = '嗨~ 快来逗我玩吧！'; &#125; &#125;else &#123; text = '欢迎阅读&amp;amp;amp;lt;span style="color:#0099cc;"&amp;amp;amp;gt;『' + document.title.split(' - ')[0] + '』&amp;amp;amp;lt;/span&amp;amp;amp;gt;'; &#125; &#125; showMessage(text, 6000);&#125;)(); window.setInterval(showHitokoto,30000); function showHitokoto()&#123; $.getJSON('https://api.imjad.cn/hitokoto/?cat=&amp;amp;amp;amp;charset=utf-8&amp;amp;amp;amp;length=28&amp;amp;amp;amp;encode=json',function(result)&#123; showMessage(result.hitokoto, 5000); &#125;);&#125; function showMessage(text, timeout)&#123; if(Array.isArray(text)) text = text[Math.floor(Math.random() * text.length + 1)-1]; console.log(text); $('.waifu-tips').stop(); $('.waifu-tips').html(text).fadeTo(200, 1); if (timeout === null) timeout = 5000; hideMessage(timeout);&#125;function hideMessage(timeout)&#123; $('.waifu-tips').stop().css('opacity',1); if (timeout === null) timeout = 5000; $('.waifu-tips').delay(timeout).fadeTo(200, 0);&#125; 文本将以下内容保存为waifu-tips.json，放至相应目录 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110&#123; "mouseover": [ &#123; "selector": ".container a[href^='http']", "text": ["要看看 &amp;amp;amp;lt;span style=\"color:#0099cc;\"&amp;amp;amp;gt;&#123;text&#125;&amp;amp;amp;lt;/span&amp;amp;amp;gt; 么？"] &#125;, &#123; "selector": ".fui-home", "text": ["点击前往首页，想回到上一页可以使用浏览器的后退功能哦"] &#125;, &#123; "selector": "#tor_show", "text": ["翻页比较麻烦吗，点击可以显示这篇文章的目录呢"] &#125;, &#123; "selector": "#comment_go,.fui-chat", "text": ["想要去评论些什么吗？"] &#125;, &#123; "selector": "#night_mode", "text": ["深夜时要爱护眼睛呀"] &#125;, &#123; "selector": "#qrcode", "text": ["手机扫一下就能继续看，很方便呢"] &#125;, &#123; "selector": ".comment_reply", "text": ["要吐槽些什么呢"] &#125;, &#123; "selector": "#back-to-top", "text": ["回到开始的地方吧"] &#125;, &#123; "selector": "#author", "text": ["该怎么称呼你呢"] &#125;, &#123; "selector": "#mail", "text": ["留下你的邮箱，不然就是无头像人士了"] &#125;, &#123; "selector": "#url", "text": ["你的家在哪里呢，好让我去参观参观"] &#125;, &#123; "selector": "#textarea", "text": ["认真填写哦，垃圾评论是禁止事项"] &#125;, &#123; "selector": ".OwO-logo", "text": ["要插入一个表情吗"] &#125;, &#123; "selector": "#csubmit", "text": ["要提交了吗，首次评论需要审核，请耐心等待~"] &#125;, &#123; "selector": ".ImageBox", "text": ["点击图片可以放大呢"] &#125;, &#123; "selector": "input[name=s]", "text": ["找不到想看的内容？搜索看看吧"] &#125;, &#123; "selector": ".previous", "text": ["去上一页看看吧"] &#125;, &#123; "selector": ".next", "text": ["去下一页看看吧"] &#125;, &#123; "selector": ".dropdown-toggle", "text": ["这里是菜单"] &#125;, &#123; "selector": "c-player a.play-icon", "text": ["想要听点音乐吗"] &#125;, &#123; "selector": "c-player div.time", "text": ["在这里可以调整&amp;amp;amp;lt;span style=\"color:#0099cc;\"&amp;amp;amp;gt;播放进度&amp;amp;amp;lt;/span&amp;amp;amp;gt;呢"] &#125;, &#123; "selector": "c-player div.volume", "text": ["在这里可以调整&amp;amp;amp;lt;span style=\"color:#0099cc;\"&amp;amp;amp;gt;音量&amp;amp;amp;lt;/span&amp;amp;amp;gt;呢"] &#125;, &#123; "selector": "c-player div.list-button", "text": ["&amp;amp;amp;lt;span style=\"color:#0099cc;\"&amp;amp;amp;gt;播放列表&amp;amp;amp;lt;/span&amp;amp;amp;gt;里都有什么呢"] &#125;, &#123; "selector": "c-player div.lyric-button", "text": ["有&amp;amp;amp;lt;span style=\"color:#0099cc;\"&amp;amp;amp;gt;歌词&amp;amp;amp;lt;/span&amp;amp;amp;gt;的话就能跟着一起唱呢"] &#125;, &#123; "selector": ".waifu #live2d", "text": ["干嘛呢你，快把手拿开", "鼠…鼠标放错地方了！"] &#125; ], "click": [ &#123; "selector": ".waifu #live2d", "text": ["是…是不小心碰到了吧", "萝莉控是什么呀", "你看到我的小熊了吗", "再摸的话我可要报警了！⌇●﹏●⌇", "110吗，这里有个变态一直在摸我(ó﹏ò｡)"] &#125; ]&#125; 引入JS修改header.php，加入以下内容以创建画布和提示框： 1234&amp;amp;lt;div class="waifu"&amp;amp;gt;&amp;amp;lt;div class="waifu-tips"&amp;amp;gt;&amp;amp;lt;/div&amp;amp;gt;&amp;amp;lt;canvas id="live2d" width="280" height="250" class="live2d"&amp;amp;gt;&amp;amp;lt;/canvas&amp;amp;gt;&amp;amp;lt;/div&amp;amp;gt; 在footer.php中加入以下内容： 123&amp;amp;lt;img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-wp-preserve="%3Cscript%20async%20src%3D%22path%2Fto%2Fwaifu-tips.js%22%3E%3C%2Fscript%3E" data-mce-resize="false" data-mce-placeholder="1" class="mce-object" width="20" height="20" alt="&amp;amp;amp;lt;script&amp;amp;amp;gt;" title="&amp;amp;amp;lt;script&amp;amp;amp;gt;" /&amp;amp;gt;&amp;amp;lt;img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-wp-preserve="%3Cscript%20src%3D%22path%2Fto%2Flive2d.js%22%3E%3C%2Fscript%3E" data-mce-resize="false" data-mce-placeholder="1" class="mce-object" width="20" height="20" alt="&amp;amp;amp;lt;script&amp;amp;amp;gt;" title="&amp;amp;amp;lt;script&amp;amp;amp;gt;" /&amp;amp;gt;&amp;amp;lt;img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-wp-preserve="%3Cscript%20type%3D%22text%2Fjavascript%22%3E%0A%20loadlive2d(%22live2d%22%2C%20%22path%2Fto%2Fmodel.json%22)%3B%0A%3C%2Fscript%3E" data-mce-resize="false" data-mce-placeholder="1" class="mce-object" width="20" height="20" alt="&amp;amp;amp;lt;script&amp;amp;amp;gt;" title="&amp;amp;amp;lt;script&amp;amp;amp;gt;" /&amp;amp;gt; model.json修改为以下内容其中hit_areas_custom字段的head_x和body_x定义了头部和身体的HIT_AREA的左上角的坐标，head_y和body_y定义了右下角的坐标 坐标可通过启用DEBUG_MOUSE_LOG获取 源码+声音 已下是可选择内容 修改你的人物.json 这里给的只是某个贴图的格式: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899&#123; "version":"1.0.0", "model":"model.moc", "textures":[ "textures/default-costume.png" ], "layout":&#123; "center_x":0.0, "center_y":-0.05, "width":2.0 &#125;, "hit_areas_custom":&#123; "head_x":[-0.35, 0.6], "head_y":[0.19, -0.2], "body_x":[-0.3, -0.25], "body_y":[0.3, -0.9] &#125;, "motions":&#123; "idle":[ &#123;"file":"motions/WakeUp.mtn"&#125;, &#123;"file":"motions/Breath1.mtn"&#125;, &#123;"file":"motions/Breath2.mtn"&#125;, &#123;"file":"motions/Breath3.mtn"&#125;, &#123;"file":"motions/Breath5.mtn"&#125;, &#123;"file":"motions/Breath7.mtn"&#125;, &#123;"file":"motions/Breath8.mtn"&#125; ], "sleepy":[ &#123;"file":"motions/Sleeping.mtn"&#125; ], "flick_head":[ &#123;"file":"motions/Touch Dere1.mtn"&#125;, &#123;"file":"motions/Touch Dere2.mtn"&#125;, &#123;"file":"motions/Touch Dere3.mtn"&#125;, &#123;"file":"motions/Touch Dere4.mtn"&#125;, &#123;"file":"motions/Touch Dere5.mtn"&#125;, &#123;"file":"motions/Touch Dere6.mtn"&#125; ], "tap_body":[ &#123;"file":"motions/Touch1.mtn"&#125;, &#123;"file":"motions/Touch2.mtn"&#125;, &#123;"file":"motions/Touch3.mtn"&#125;, &#123;"file":"motions/Touch4.mtn"&#125;, &#123;"file":"motions/Touch5.mtn"&#125;, &#123;"file":"motions/Touch6.mtn"&#125; ], "":[ &#123;"file":"motions/Breath1.mtn"&#125;, &#123;"file":"motions/Breath2.mtn"&#125;, &#123;"file":"motions/Breath3.mtn"&#125;, &#123;"file":"motions/Breath4.mtn"&#125;, &#123;"file":"motions/Breath5.mtn"&#125;, &#123;"file":"motions/Breath6.mtn"&#125;, &#123;"file":"motions/Breath7.mtn"&#125;, &#123;"file":"motions/Breath8.mtn"&#125;, &#123;"file":"motions/Fail.mtn"&#125;, &#123;"file":"motions/Sleeping.mtn"&#125;, &#123;"file":"motions/Success.mtn"&#125;, &#123;"file":"motions/Sukebei1.mtn"&#125;, &#123;"file":"motions/Sukebei2.mtn"&#125;, &#123;"file":"motions/Sukebei3.mtn"&#125;, &#123;"file":"motions/Touch Dere1.mtn"&#125;, &#123;"file":"motions/Touch Dere2.mtn"&#125;, &#123;"file":"motions/Touch Dere3.mtn"&#125;, &#123;"file":"motions/Touch Dere4.mtn"&#125;, &#123;"file":"motions/Touch Dere5.mtn"&#125;, &#123;"file":"motions/Touch Dere6.mtn"&#125;, &#123;"file":"motions/Touch1.mtn"&#125;, &#123;"file":"motions/Touch2.mtn"&#125;, &#123;"file":"motions/Touch3.mtn"&#125;, &#123;"file":"motions/Touch4.mtn"&#125;, &#123;"file":"motions/Touch5.mtn"&#125;, &#123;"file":"motions/Touch6.mtn"&#125;, &#123;"file":"motions/WakeUp.mtn"&#125; ], "tap_body": [ &#123; "file":"motions/Touch Dere3.mtn" , "sound":"sounds/1.mp3"&#125;, &#123; "file":"motions/Touch1.mtn" , "sound":"sounds/3.mp3"&#125;, &#123; "file":"motions/Touch2.mtn" , "sound":"sounds/4.mp3"&#125; ], "pinch_in": [ &#123; "file":"motions/Breath3.mtn", "sound":"sounds/9.mp3" &#125; ], "pinch_out": [ &#123; "file":"motions/Breath5.mtn", "sound":"sounds/8.mp3" &#125; ], "shake": [ &#123; "file":"motions/Breath7.mtn", "sound":"sounds/6.mp3","fade_in":500 &#125; ], "flick_head": [ &#123; "file":"motions/Breath8.mtn", "sound":"sounds/3.mp3" &#125; ] &#125;&#125; 上面的mtn动作以及sounds可以选择添加 这样可以在人物里面添加动作同步声音 增加看板娘萌度！ 其中motions的idle组是放置时的动作，按照次序依次显示，可以在这里添加更多的动作 layout的center_x字段和center_y字段用于偏移显示模型，日后若有显示错位可以修改此处的值 增加样式:把如下源码写成css再调用或者直接插入style.css里再调用都可以 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244.waifu &#123; position: fixed; bottom: 0; left: 0; z-index: 1; font-size: 0; transition: all .3s ease-in-out; -webkit-transform: translateY(3px); transform: translateY(3px);&#125;.waifu:hover &#123; -webkit-transform: translateY(0); transform: translateY(0);&#125;@media (max-width: 768px) &#123; .waifu &#123; display: none; &#125;&#125;.waifu-tips &#123; opacity: 0; width: 200px; height: 60px; margin: -20px 20px; padding: 4px 6px; border: 1px solid rgba(224, 186, 140, 0.62); border-radius: 12px; background-color: rgba(236, 217, 188, 0.5); box-shadow: 0 3px 15px 2px rgba(191, 158, 118, 0.2); font-size: 12px; text-overflow: ellipsis; overflow: hidden; position: absolute; animation-delay: 5s; animation-duration: 50s; animation-iteration-count: infinite; animation-name: shake; animation-timing-function: ease-in-out;&#125;.waifu #live2d&#123; position: relative;&#125; @keyframes shake &#123; 2% &#123; transform: translate(0.5px, -1.5px) rotate(-0.5deg); &#125; 4% &#123; transform: translate(0.5px, 1.5px) rotate(1.5deg); &#125; 6% &#123; transform: translate(1.5px, 1.5px) rotate(1.5deg); &#125; 8% &#123; transform: translate(2.5px, 1.5px) rotate(0.5deg); &#125; 10% &#123; transform: translate(0.5px, 2.5px) rotate(0.5deg); &#125; 12% &#123; transform: translate(1.5px, 1.5px) rotate(0.5deg); &#125; 14% &#123; transform: translate(0.5px, 0.5px) rotate(0.5deg); &#125; 16% &#123; transform: translate(-1.5px, -0.5px) rotate(1.5deg); &#125; 18% &#123; transform: translate(0.5px, 0.5px) rotate(1.5deg); &#125; 20% &#123; transform: translate(2.5px, 2.5px) rotate(1.5deg); &#125; 22% &#123; transform: translate(0.5px, -1.5px) rotate(1.5deg); &#125; 24% &#123; transform: translate(-1.5px, 1.5px) rotate(-0.5deg); &#125; 26% &#123; transform: translate(1.5px, 0.5px) rotate(1.5deg); &#125; 28% &#123; transform: translate(-0.5px, -0.5px) rotate(-0.5deg); &#125; 30% &#123; transform: translate(1.5px, -0.5px) rotate(-0.5deg); &#125; 32% &#123; transform: translate(2.5px, -1.5px) rotate(1.5deg); &#125; 34% &#123; transform: translate(2.5px, 2.5px) rotate(-0.5deg); &#125; 36% &#123; transform: translate(0.5px, -1.5px) rotate(0.5deg); &#125; 38% &#123; transform: translate(2.5px, -0.5px) rotate(-0.5deg); &#125; 40% &#123; transform: translate(-0.5px, 2.5px) rotate(0.5deg); &#125; 42% &#123; transform: translate(-1.5px, 2.5px) rotate(0.5deg); &#125; 44% &#123; transform: translate(-1.5px, 1.5px) rotate(0.5deg); &#125; 46% &#123; transform: translate(1.5px, -0.5px) rotate(-0.5deg); &#125; 48% &#123; transform: translate(2.5px, -0.5px) rotate(0.5deg); &#125; 50% &#123; transform: translate(-1.5px, 1.5px) rotate(0.5deg); &#125; 52% &#123; transform: translate(-0.5px, 1.5px) rotate(0.5deg); &#125; 54% &#123; transform: translate(-1.5px, 1.5px) rotate(0.5deg); &#125; 56% &#123; transform: translate(0.5px, 2.5px) rotate(1.5deg); &#125; 58% &#123; transform: translate(2.5px, 2.5px) rotate(0.5deg); &#125; 60% &#123; transform: translate(2.5px, -1.5px) rotate(1.5deg); &#125; 62% &#123; transform: translate(-1.5px, 0.5px) rotate(1.5deg); &#125; 64% &#123; transform: translate(-1.5px, 1.5px) rotate(1.5deg); &#125; 66% &#123; transform: translate(0.5px, 2.5px) rotate(1.5deg); &#125; 68% &#123; transform: translate(2.5px, -1.5px) rotate(1.5deg); &#125; 70% &#123; transform: translate(2.5px, 2.5px) rotate(0.5deg); &#125; 72% &#123; transform: translate(-0.5px, -1.5px) rotate(1.5deg); &#125; 74% &#123; transform: translate(-1.5px, 2.5px) rotate(1.5deg); &#125; 76% &#123; transform: translate(-1.5px, 2.5px) rotate(1.5deg); &#125; 78% &#123; transform: translate(-1.5px, 2.5px) rotate(0.5deg); &#125; 80% &#123; transform: translate(-1.5px, 0.5px) rotate(-0.5deg); &#125; 82% &#123; transform: translate(-1.5px, 0.5px) rotate(-0.5deg); &#125; 84% &#123; transform: translate(-0.5px, 0.5px) rotate(1.5deg); &#125; 86% &#123; transform: translate(2.5px, 1.5px) rotate(0.5deg); &#125; 88% &#123; transform: translate(-1.5px, 0.5px) rotate(1.5deg); &#125; 90% &#123; transform: translate(-1.5px, -0.5px) rotate(-0.5deg); &#125; 92% &#123; transform: translate(-1.5px, -1.5px) rotate(1.5deg); &#125; 94% &#123; transform: translate(0.5px, 0.5px) rotate(-0.5deg); &#125; 96% &#123; transform: translate(2.5px, -0.5px) rotate(-0.5deg); &#125; 98% &#123; transform: translate(-1.5px, -1.5px) rotate(-0.5deg); &#125; 0%, 100% &#123; transform: translate(0, 0) rotate(0); &#125;&#125; 如果单独写成css的 你就在header.php里面加上 1&amp;amp;lt;link rel="stylesheet" href="https://www.ohyhello.com/live2d/live2d.css" type="text/css"/&amp;amp;gt; 调用你自己的css 如一切正常，刷新网页后，可爱的Pio就会出现在页面左下角，点击会播放不同的动作并有相应提示文字 结语：按照以上步骤的话你的博客大概已经出现了卡哇伊的看板娘了注意检查细节特别是waifu-tips.js里面有调用一个json注意别写错路径了 参考&amp;相关连接hexo-helper-live2dlive2d_src 修改模型@猫与向日葵 部分内容转载@猫与向日葵 部分内容转载@JiuMeng live2d 什么是live2d Live2D Viewer – Live2D Cubism 2 中文說明書 药水制作师Unity StudioUABE]]></content>
      <tags>
        <tag>网页</tag>
        <tag>JavaScript</tag>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[给网页添加鼠标点击特效]]></title>
    <url>%2F2017%2F12%2F%E7%BB%99%E7%BD%91%E9%A1%B5%E6%B7%BB%E5%8A%A0%E9%BC%A0%E6%A0%87%E7%82%B9%E5%87%BB%E7%89%B9%E6%95%88%2F</url>
    <content type="text"><![CDATA[最近折腾网页，会陆续分享一些东西给大家 前言偶尔看见别人网页鼠标点击会有特殊效果，一般都是基于js/css实现的，这篇文章会介绍anime.js和如何添加鼠标点击效果 Anime.js 简介Github项目 anime.js是一款功能强大的Javascript动画库插件。anime.js可以和CSS3属性，SVG，DOM元素和JS对象一起工作，制作出各种高性能，平滑过渡的动画效果。 浏览器支持 Chrome Safari IE / Edge Firefox Opera 24+ 6+ 10+ 32+ 15+ 使用123$ npm install animejs# OR$ bower install animejs 1import anime from 'animejs' 或者手动 下载 然后在你的网页上链接 anime.min.js ： 1&lt;script src="anime.min.js"&gt;&lt;/script&gt; 自定义anime.js功能极其强大，具体参数设置详见官方文档，点我了解代码详情 有兴趣可以移步。 你也可以找到喜欢的样式时看看源代码，如果包含了anime.min.js/anime.js你就需要找到另外一个自定义的js文件然后保存到网站目录 添加在&lt;/body&gt;前添加 12345&lt;script type="text/javascript" src="你的文件目录/anime.js"&gt;&lt;/script&gt;&lt;script type="text/javascript" src="你的文件目录/xxxx.js"&gt;&lt;/script&gt;或者&lt;script type="text/javascript" src="你的文件目录/anime.min.js"&gt;&lt;/script&gt;&lt;script type="text/javascript" src="你的文件目录/xxxx.js"&gt;&lt;/script&gt; Download anime.js Now Download anime.min.js Now 后话碰见自己喜欢的js/css一定要保存下来。就和妹子一样]]></content>
      <tags>
        <tag>网页</tag>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[c语言课后实验作业8]]></title>
    <url>%2F2017%2F12%2Fc%E8%AF%AD%E8%A8%80%E8%AF%BE%E5%90%8E%E5%AE%9E%E9%AA%8C%E4%BD%9C%E4%B8%9A8%2F</url>
    <content type="text"><![CDATA[考完四级，心态如下 答案只有函数，存放在了一个文件里基础练习123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150//就只写了函数/*2.1*/double carea(double r)&#123; return r*r*3.1415926;&#125;/*2.2*/int gcd(int numa, int numb)&#123; int i; for(i=numa;i&gt;=1;i--)&#123; if(numa%i==0&amp;&amp;numb%i==0) break; &#125; return i; &#125;/*2.3*/double distance(int x1, int y1, int x2, int y2)&#123; double resul; resul=sqrt((double)pow(x1-x2,2)+pow(y1-y2,2)); return resul;&#125;/*2.4*/double tempt(double temp,char ctype)&#123; if (islower(ctype)=='C') &#123; temp = (temp-32)/1.8; return temp; &#125; if (islower(ctype)=='F') &#123; temp = (32+temp)*1.8; return temp; &#125; else return 0;&#125;/*2.5*/int isOE(int number)&#123; if( (number%2)==0 )&#123; return -1; &#125; else return 1;&#125;/*2.6*/int answer()&#123; printf("答案是：2 3 \n 3 4"); return 0;&#125;/*2.7*/void sa(int x1,int x2,int *sum,int *mul)&#123; *sum=(x1+x2); *mul=(x1*x2);&#125;/*2.8*/void exchange(int *n1,int *n2)&#123; int x; x=*n1; *n1=*n2; *n2=x;&#125;/*2.9*/int isprime(int *data,int *primes,int len)&#123; int i,j,number=0; for (i = 0,j=0; i&lt;=len; i++) &#123; int t=1; for (j = 2;j&lt;i ; j++) &#123; if (*(data+i)%j==0) &#123; t=0; break; &#125; &#125; if (t==1) &#123; primes[j++]=*(data+i); number++; &#125; &#125; return number;&#125;/*2.10*/void MatrixSearch(double matrix[][], double *pMax, double *pMin, int n)&#123; *pMax=*pMin=matrix[0][0]; for(i=0;i&lt;(*matrix);i++)&#123; for(j=0;j&lt;(**matrix);j++)&#123; if(matrix[i][j]&gt;*pMax) *pMax=matrix[i][j]; if(matrix[i][j]&lt;*pMin) *pMin=matrix[i][j]; &#125; &#125;&#125;/*2.11*/void sort(int *arry,int len)&#123; int i,j; int flag = 1; for (i = 0; i &lt; len &amp;&amp; flag; i++) &#123; flag = 0; //只要flag在下一次外循环条件检测的时候值为0，就说明已经排好序，不用继续循环 for (j = len-1; j &gt; i; j--) &#123; if (array[j] &lt; array[j-1]) &#123; temp = array[j]; array[j] = array[j-1]; array[j-1] = temp; lag = 1; //如果有交换，就将标记变量赋1 &#125; &#125; &#125; for (i = 0; i &lt; len; i++) &#123; printf("%d\n", array[i]); &#125; return 0;&#125;/*2.12*/int search(char *list,char c,int len)&#123; int low=0,high=len-1,k; while (low=high) &#123; k=(low+high)/2; if (list[k]==c) &#123; high=k-1; &#125; else if(list[k]&gt;c) high=k-1; &#125; return -1;&#125;//importFucint main()&#123; return 0;&#125; 进阶练习123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156#include "stdio.h"#include "stdlib.h"#include &lt;stdbool.h&gt;#include "math.h"/*3.2*/int findmax(int n1,int n2,int n3)&#123; return ((((n1&gt;n2)?n1:n2)&gt;n3)?((n1&gt;n2)?n1:n2):n3);&#125;/*3.3*/double cvolume(double r,double h)&#123; return (3.1415926*r*r*h);&#125;/*3.4*/int lcm(int x1,int x2)&#123; int x, y, temp; if(x1 &lt; x2)&#123; temp = x1; x1 = x2; x2 = temp; &#125; x = x1; y = x2; while(y != 0)&#123; temp = x%y; x = y; y = temp; &#125; return x1*x2/x; //return x1;//the max&#125;/*3.5*/long fact(int n)&#123; if (n&gt;0) &#123; return n*fact(n-1); &#125; else if (n==0) return 1; else return 0;&#125;/*3.6*/double power(double n,int p)&#123; return pow(n,p);&#125;/*3.7*/int cday(int year,int month,int day)&#123; int i, num,d[12]; d[0] = 31; d[1] = 28; d[2] = 31; d[3] = 30; d[4] = 31; d[5] = 30; d[6] = 31; d[7] = 31; d[8] = 30; d[9] = 31; d[10] = 30; d[11] = 31; num = 0; if (year % 4 == 0)&#123; d[1] = 29; &#125; for (i = 0; i &lt; month - 1; i++)&#123; num += d[i]; &#125; num += day; printf("是%d年第%d天",year,num); return 0;&#125;/*3.8*/void data(int num,int *month,int *day,int *year)&#123; /*int main()&#123; int num=20170412,m=0,d=0,y=0; int *month=&amp;m; int *day=&amp;d; int *year=&amp;y; data(num, month, day, year); return 0; &#125;*/ *day = num % 100; num /= 100; *month = num % 100; *year = num / 100; printf("%4d-%02d-%02d\n",*year,*month,*day);&#125;/*3.9*/long fun(int k)&#123; if (k&gt;0) &#123; return k*fun(k-1); &#125; else if (k==0)&#123; return 1; &#125; else return 0;&#125;/*3.10*/int fibonacci(int n)&#123; if (n &lt;= 2)&#123; return 1 ; &#125; else&#123; return fibonacci(n-1) + fibonacci(n-2) ; &#125;&#125;/*3.11*/void hanoi(int n, char x, char y, char z)&#123; if(n == 1) printf("%d. %c -&gt; %c\n",n,x,z); else &#123; hanoi(n-1,x,y,z); printf("%d. %c -&gt; %c\n",n,x,z); hanoi(n-1,y,x,z); &#125; &#125;/*int main()&#123; //A,B,C分别代表三个柱子 char ch1 = 'A'; char ch2 = 'B'; char ch3 = 'C'; int n; //n代表圆盘的个数 printf("请输入圆盘的个数："); scanf("%d",&amp;n); move(n,ch1,ch2,ch3); return 0; */ int main()&#123; return 0;&#125; 话说，最近好累啊，马上实验室招新活动= =]]></content>
      <tags>
        <tag>c语言</tag>
        <tag>c语言作业</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[解决Win VS编译的文件到xCode出现乱码的问题]]></title>
    <url>%2F2017%2F12%2F%E8%A7%A3%E5%86%B3Win-VS%E7%BC%96%E8%AF%91%E7%9A%84%E6%96%87%E4%BB%B6%E5%88%B0xCode%E5%87%BA%E7%8E%B0%E4%B9%B1%E7%A0%81%E7%9A%84%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[在iOS混编的时候，经常会共用跨平台文件，导入到xcode中，有的格式就可能会识别不了，就会变成乱码，比如说GBK，GB2312（理论上有的文件xcode是可以识别的）。为了可以统一转化这些文件的编码，可以使用Node.js来完成这项工作。 今天心情相当复杂 一.Node.js简介Node.js 不是一种独立的语言,Node.js 也不是一个 JavaScript 框架。Node.js 是一个让 JavaScript 运行在服务端的开发平台。他跳过了http服务器，速度更快，性能更高！ 学习网站：点我跳转 V8引擎本身就是用于Chrome浏览器的JS解释部分，但是Ryan Dahl把V8搬到了服务器上，用于做服务器的软件。 Node.js是一个让JavaScript运行在服务器端的开发平台，它让JavaScript的触角伸到了服务器端，可以与PHP、JSP、Pythod、Ruby平起平坐。 但Node有点不同： Node.js不是一种独立的语言，与php、ASP.Net、JSP、Pythod、Perl、Ruby的既是语言，也是平台不同，Node.js的使用JavaScript进行编程，运行在chrome V8引擎上。 与php、JSP等相比（php、asp.Net、JSP、.net都需要运行在服务器上），Node.js跳过了Apache、Nginx、IIS等HTTP服务器，它自己不用建设在任何服务器软件上，Node.js的许多设计理念与经典架构（LAMP）有着很大的不同，可以提供强大的伸缩能力。 Node.js 与 JavaScript JavaScript 是由 ECMAScript、文档对象模型（DOM）和浏览器对象模型（BOM）组成的，而 Mozilla 则指出 JavaScript 由Core JavaScript 和 Client JavaScript 组成。我们可以认为，Node.js 中所谓的 JavaScript 只是 Core JavaScript，或者说是 ECMAScript 的一个实现，不包含 DOM、BOM 或者 Client JavaScript。这是因为 Node.js 不运行在浏览器中，所以不需要使用浏览器中的许多特性。 Node.js 是一个让 JavaScript 运行在浏览器之外的平台。它实现了诸如文件系统、模块、包、操作系统 API、网络通信等 Core JavaScript 没有或者不完善的功能。历史上将 JavaScript移植到浏览器外的计划不止一个，但Node.js 是最出色的一个。 Node.js 的 JavaScript 引擎是 V8，来自 Google Chrome 项目。V8 号称是目前世界上最快的 JavaScript 引擎，经历了数次引擎革命，它的 JIT（Just-in-time Compilation，即时编译）执行速度已经快到了接近本地代码的执行速度。Node.js 不运行在浏览器中，所以也就不存在 JavaScript 的浏览器兼容性问题，你可以放心地使用 JavaScript 语言的所有特性 二.Node.js配置1.安装1.NodeJS提供了一些安装程序，都可以在nodejs.org这里下载并安装。 2.通过brew安装（brew 又叫Homebrew，是Mac OSX上的软件包管理工具，能在Mac中方便的安装软件或者卸载软件， 只需要一个命令） i&gt;.首先安装brew 12&gt; /usr/bin/ruby -e "$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)"&gt; 将以上命令粘贴至终端。 脚本会在执行前暂停，并说明将它将做什么。高级安装选项在 这里。 ii&gt;.通过brew安装node brew install node Homebrew 会将软件包安装到独立目录，并将其文件软链接至 /usr/local 2.更新node.js 一行命令 版本升级 npm install -g n # 显示错误 所以用 sudo npm install -g n 来代替 如果提示错误，在打开bash的时候使用 sudo -s 回车输入密码即可。 三.iconv-lite配置输入npm install iconv-lite就可以安装了 四.完整代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950// 文件名 index.jsconst fs = require('fs'); const path = require('path'); const iconv = require('iconv-lite');console.log('爬虫程序开始运行...')var root = path.join(__dirname) readDir(path.join(root)) console.log('爬虫程序结束运行...')function readDir(subPath)&#123; fs.readdir(subPath,function(err,menu)&#123; if(!menu) return; menu.forEach(function(ele)&#123; fs.stat(subPath+"/"+ele,function(err,info)&#123; if(info.isDirectory())&#123; readDir(subPath+"/"+ele); &#125;else&#123; // 先判断后缀名 if (isContains(ele, '.h') || isContains(ele, '.hpp') || isContains(ele, '.cpp') || isContains(ele, '.c') || isContains(ele, '.m') || isContains(ele, '.mm')) &#123; transStr(subPath, ele) &#125; &#125; &#125;) &#125;) &#125;) &#125; // 判断是是否包含字符串function isContains(str, substr) &#123; return str.indexOf(substr) &gt;= 0;&#125;// 转化文件中的编码方式function transStr(fontPath, subPath) &#123; var filePath = path.resolve(fontPath, subPath); console.log("file: " + filePath) var data = fs.readFileSync(filePath); var change_data = iconv.decode(data,'gb2312'); var aie = iconv.encode(change_data,'utf8'); fs.writeFileSync(filePath, aie);&#125; 有哪个文件夹中的文件需要转化，那就把这个文件（index.js命名可以随便）放在哪个文件夹或者是上一层，只要在终端中，跳转到当前的目录下，然后执行node index.js就可以了。 现在我们简单的分析一下代码的流程 1. 导入模块123const fs = require('fs'); const path = require('path'); const iconv = require('iconv-lite'); 导入需要用到的三个node的模块，fs是处理文件流的，path是处理路径的，iconv-lite是进行编码转化的。 2. 获取路径12var root = path.join(__dirname) readDir(path.join(root)) __dirname 获得当前文件所在目录的完整目录名 3. 遍历所有文件夹中的文件1234567891011121314151617181920212223function readDir(subPath)&#123; fs.readdir(subPath,function(err,menu)&#123; if(!menu) return; menu.forEach(function(ele)&#123; fs.stat(subPath+"/"+ele,function(err,info)&#123; if(info.isDirectory())&#123; readDir(subPath+"/"+ele); &#125;else&#123; // 先判断后缀名 if (isContains(ele, '.h') || isContains(ele, '.hpp') || isContains(ele, '.cpp') || isContains(ele, '.c') || isContains(ele, '.m') || isContains(ele, '.mm')) &#123; transStr(subPath, ele) &#125; &#125; &#125;) &#125;) &#125;) &#125; 这里是利用递归的方式来获取文件夹的所有目录的。 fs.readdir(path, [callback(err,files)]) 以异步的方式读取文件目录。 fs.stat(path, [callback(err, stats)]) 获取文件信息 在这里加了一个判断，如果文件的后缀名是.h .hpp .c .cpp .m .mm的的时候，才会进行编码的转化。 4. 转化文件中的编码方式12345678910function transStr(fontPath, subPath) &#123; var filePath = path.resolve(fontPath, subPath); console.log("file: " + filePath) var data = fs.readFileSync(filePath); var change_data = iconv.decode(data,'gb2312'); var aie = iconv.encode(change_data,'utf8'); fs.writeFileSync(filePath, aie);&#125; 最后一部分，才是本文的重点 path.resolve([from ...], to) 将参数 to 位置的字符解析到一个绝对路径里，这里解析出文件的绝对路径。 fs.readFileSync(filename, [encoding]) 异步获取文件中的数据。 fs.writeFileSync(filename, data, [options]) 异步将数据写入到文件。 iconv.decode() iconv.encode() 解码和编码数据的格式，这里的gb2312 utf8只是一个例子，还可以替换成其他的格式(比如gbk ISO-8859)，这个就需要尝试精神，因为有的时候我们也不知道他到底是什么编码。。。。。。]]></content>
      <tags>
        <tag>Xcode相关</tag>
        <tag>Node.js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[c语言malloc与realloc，calloc和_alloca的简要介绍]]></title>
    <url>%2F2017%2F12%2Fc%E8%AF%AD%E8%A8%80malloc%E4%B8%8Erealloc%EF%BC%8Ccalloc%E5%92%8C-alloca%E7%9A%84%E7%AE%80%E8%A6%81%E4%BB%8B%E7%BB%8D%2F</url>
    <content type="text"><![CDATA[主要是说说这个malloc与realloc，calloc和_alloca的区别 在了解之前首先得知道c语言跟内存分配的方式 1.C语言跟内存分配方式1&gt;.从静态存储区域分配.​ 内存是在程序编译的时候就已经分配好，而且这块内存在程序的整个运行期间都存在.例如全局变量、static变量等等。。 2&gt;.在栈上创建.​ 在执行函数时，函数内局部变量的存储单元都可以在栈上创建，函数执行结束时这些存储单元自动被释放.栈内存分配运算内置于处理器的指令集中，效率很高，但是分配的内存容量有限. 3&gt;.从堆上分配，又称动态内存分配.​ 程序在运行的时候用malloc或new申请任意多少的内存，而写程序的人负责在何时用free或delete释放内存.动态内存的生存期由用户自己决定，使用非常灵活，但问题也最多. 2.C语言跟内存申请相关主要的函数​ _alloca是向栈申请内存,因此无需释放.(仅供了解)​ malloc分配的内存是位于堆中的,并且没有初始化内存的内容,因此基本上malloc之后调用函数memset来初始化这部分的内存空间.​ calloc则将初始化这部分的内存,设置为0.​ realloc则对malloc申请的内存进行大小的调整. 3.简要的概述1&gt;malloc:函数原型为：extern void *malloc(unsigned int num_bytes); 功能：分配长度为num_bytes字节的内存块 返回值：如果分配成功则返回指向被分配内存的指针(此存储区中的初始值不确定)，否则返回空指针NULL。当内存不再使用时，应使用free()函数将内存块释放。函数返回的指针一定要适当对齐，使其可以用于任何数据对象。 说明：malloc 向系统申请分配指定size个字节的内存空间。返回类型是 void 类型。void 表示未确定类型的指针。C,C++规定，void* 类型可以强制转换为任何其它类型的指针。 用法： char p = (char )malloc(sizeof(char)); 正常程序 123456789101112131415161718192021typedef struct data_type&#123; int age; char name[20];&#125;data;data*bob=NULL; bob=(data*)malloc(sizeof(data));if(bob!=NULL)&#123; bob-&gt;age=22; strcpy(bob-&gt;name,"Robert"); printf("%sis%dyearsold\n",bob-&gt;name,bob-&gt;age);&#125; else &#123; printf("mallocerror!\n"); exit(-1);&#125; free(bob);bob=NULL; 内存泄漏实例 例子1 123456789101112131415161718192021222324#include "stdio.h"#include "malloc.h"//malloc()函数被包含在malloc.h里面int main(void)&#123; char *a = NULL;//声明一个指向a的char*类型的指针 a = (char*)malloc(100*sizeof(char));//使用malloc分配内存的首地址，然后赋值给a if(!a)//如果malloc失败，可以得到一些log &#123; perror("malloc"); return -1; &#125; sprintf(a,"%s","HelloWorld\n");//"HelloWorld\n"写入a指向的地址 printf("%s\n",a);//输出用户输入的数据 free(a);//释放掉使用的内存地址 return 0;//例2有无内存泄露？ &#125; 例子2 1234567891011121314151617#include "stdio.h"#include "malloc.h"//malloc()函数被包含在malloc.h里面int main(void)&#123; char *a = NULL;//声明一个指向a的char*类型的指针 a = (char*)malloc(100*sizeof(char));//使用malloc分配内存的首地址，然后赋值给a if(!a)//如果malloc失败，可以得到一些log &#123; perror("malloc"); return -1; &#125; sprintf(a,"%s","HelloWorld\n");//"HelloWorld\n"写入a指向的地址 printf("%s\n",a);//输出用户输入的数据 free(a);//释放掉使用的内存地址 return 0;//例2有无内存泄露？&#125;注：例1：对malloc申请之后没有检测返回值；例2：检测malloc返回值条件有误（例2是对的么？）。 特别注意！！！：函数的实参为 sizeof(int) ，用于指明一个整型数据需要的大小。如果你写成: int p = (int ) malloc (1); 代码也能通过编译，但事实上只分配了1个字节大小的内存空间，当你往里头存入一个整数，就会有3个字节没空间存放，而占了其他的位置！造成的结果是后面的内存中原有数据内容被改写。 2&gt;realloc:函数原型为：extern void realloc(void mem_address, unsigned int newsize); 功能：先判断当前的指针是否有足够的连续空间，如果有，扩大mem_address指向的地址，并且将mem_address返回，如果空间不够，先按照newsize指定的大小分配空间，将原有数据从头到尾拷贝到新分配的内存区域，而后释放原来mem_address所指内存区域，同时返回新分配的内存区域的首地址。即重新分配存储器块的地址。新的大小一定要大于原来的大小不然的话会导致数据丢失！ 返回值：如果重新分配成功则返回指向被分配内存的指针，否则返回空指针NULL。 语法：指针名=（数据类型*）realloc（要改变内存大小的指针名，新的大小） 用法： 12char *p = (char *)malloc(sizeof(char));p= (char *)realloc(p, 256);//将p所指向的对象的大小改为size个字节. 实例 例1 123456789101112131415161718#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;int main()&#123; inti; int*pn=(int*)malloc(5*sizeof(int)); printf("malloc%p\n",pn); for(i=0;i&lt;5;i++) pn[i]=i; pn=(int*)realloc(pn,10*sizeof(int)); printf("realloc%p\n",pn); for(i=5;i&lt;10;i++) pn[i]=i; for(i=0;i&lt;10;i++) printf("%3d",pn[i]); free(pn); return 0;&#125; 例2 12345678910111213141516171819202122//realloc.c#include&lt;syslib.h&gt;#include&lt;alloc.h&gt;main()&#123; char*p; clrscr();//clearscreen p=(char*)malloc(100); if(p) printf("Memory Allocatedat:%x",p); else printf("Not Enough Memory!\n"); getchar(); p=(char*)realloc(p,256); if(p) printf("Memory Reallocatedat:%x",p); else printf("Not Enough Memory!\n"); free(p); getchar(); return 0;&#125; 3&gt;calloc:函数原型为：void *calloc(unsigned n,unsigned size)； 功能：在内存的动态存储区中分配n个长度为size的连续空间，函数返回一个指向分配起始地址的指针；如果分配不成功，返回NULL。 返回值：如果分配成功则返回指向被分配内存的指针(此存储区中的初始值为零)，否则返回空指针NULL。当内存不再使用时，应使用free()函数将内存块释放。函数返回的指针一定要适当对齐，使其可以用于任何数据对象。 与malloc的区别：calloc在动态分配完内存后，自动初始化该内存空间为零，而malloc不初始化，里边数据是随机的垃圾数据。 用法： void *malloc(size_t size); 1str = (char*)calloc(10,sizeof(char)) 实例 例1 123456789101112#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#include&lt;string.h&gt;int main()&#123; char*str = NULL; str = (char*)calloc(10,sizeof(char));/*分配内存空间*/ strcpy(str, "Hello");/*将hello写入*/ printf("String is %s\n",str);/*显示变量内容*/ free(str);/*释放空间*/ return 0;&#125; 例2 123456789101112#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;int main()&#123; int i; int* pn = (int*)calloc(10, sizeof(int)); for(i = 0;i &lt; 10;i++) printf("%d", pn[i]); printf("\n"); free(pn); return 0;&#125; 4&gt;_alloca:函数原型为：void * __cdecl alloca(size_t); 介绍：内存分配函数,与malloc,calloc,realloc类似. 但是注意一个重要的区别,_alloca是在栈(stack)上申请空间,用完马上就释放. 包含在头文件malloc.h中. 在某些系统中会宏定义成alloca使用. #define alloca _alloca 注意 在调用 _alloca的函数返回的时候, 它分配的内存会自动释放。 也就是说, 用 alloca 分配的内存在栈上。 _alloca 不具可移植性, 而且在没有传统堆栈的机器上很难实现。 当它的返回值直接传入另一个函数时会带来问题,因为他分配在栈上. 由于这些原因, _alloca 不宜使用在必须广泛移植的程序中, 不管它可能多么有用。 既然 C99 支持变长数组, 它可以用来更好的 完成 alloca() 以前的任务。]]></content>
      <tags>
        <tag>c语言</tag>
        <tag>c语言语法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[c语言课后实验作业7]]></title>
    <url>%2F2017%2F12%2Fc%E8%AF%AD%E8%A8%80%E8%AF%BE%E5%90%8E%E5%AE%9E%E9%AA%8C%E4%BD%9C%E4%B8%9A7%2F</url>
    <content type="text"><![CDATA[其实重点在隔壁。。。。。 实验7ps：实验3.1和实验3.3实际是一样的，顺序有点乱（其实我懒得重新写了，逃 进阶练习3.3程序中指定个数，再进行分配的办法12345678910111213141516171819202122232425262728#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;int main()&#123; int n,i,sum = 0; double avg; printf("先输入个数："); scanf("%d",&amp;n); int *in = (int *)malloc(sizeof(int) * n); printf("输入数："); for(i = 0;i &lt; n;i++) &#123; scanf("%d",in+i); &#125; for(i = 0;i &lt; n;i++) &#123; sum += *(in + i); &#125; avg = (double)sum / n printf("和为：%d，平均值为:%.2lf\n",sum,avg); &#125; for(i = 0;i &lt; n;i++) &#123; printf("%d 对应的差值是 %.2lf \n",in+i,avg-*(in+i); &#125; free(in); return 0;&#125; 但实际上，题目要求的是“键盘输入若干个整数”，而没有提到要预先输入个数，严格来说，这样是错误的，没有达到题目要求。 123456789101112131415161718192021222324252627282930313233//于是 ”一个惊叹号“ 同学在我的提醒下开始看书，查找方法解决这个问题，终于。。。#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;int main ()&#123; int *p = NULL; float ave; int sum = 0, count = 0;//count用来计数 int room = 5, temp;//保证第一次输入有空间 int i; p = (int*)malloc(room*sizeof(int));//分配第一次输入的内存 printf("输入整数 一个整数输入后按下回车进行下一次输入\n"); printf("输入-1，结束输入，开始运行程序\n"); for(i = 0; ; i++) &#123; scanf("%d",&amp;temp); if(temp == -1) break; p[count] = temp; sum+=p[count]; count++; if(count == room)//判断内存是否已满 room+=5;//待申请内存新的大小 p = realloc(p,room*sizeof(int));//realloc 拓展内存 &#125; ave = (float)sum/count; printf("平均数为%f\n",ave); for(i = 0; i&lt;count; i++)&#123; printf("第%d个数与平均数的差值为%f\n", i+1, p[i]-ave); &#125; free(p); return 0;&#125; 不过还有些小东西没有完善。。具体是什么，请看实验3.1 进阶练习3.2常规操作1234567891011121314151617#include &lt;stdio.h&gt;#include &lt;ctype.h&gt;int main() &#123; char s[1024]; int i,j; printf("输入字符串:\n"); while(fgets(s,1024,stdin)) &#123; for(i = 0,j = 0;s[i];++i)&#123; if(isalpha(s[i]))&#123; s[j++] = s[i]; &#125; &#125; s[j] = '\0'; printf("%s\n",s); &#125; return 0;&#125; 只有常规操作，坐下进阶练习3.1好好体会（逃12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;ctype.h&gt;#define ROOM 5int main()&#123; double *values = NULL; int capacity = 0; double *temp = NULL; double sum = 0.0; int count = 0; char answer = 'n'; do &#123; if(count == capacity) &#123; capacity += ROOM; temp = realloc(values, capacity*sizeof(double)); if(!temp) &#123; printf("Memory allocation failed.Bye"); exit(1); &#125; values = temp; temp = NULL; &#125; printf("Enter a value: "); scanf("%lf", values+count++); printf("Do you want to enter another(y/Y or n/N)? "); scanf(" %c", &amp;answer); &#125;while(tolower(answer) == 'y'); for(size_t i = 0 ; i &lt; count ; ++i) sum += *(values + i); printf("The average is %f.\n", sum/count); for(size_t i = 0 ; i &lt; count ; ++i)&#123; printf("%f -&gt; %f\n",(*(values + i)),((*(values + i))-(sum/count))); &#125; printf("\n"); free(values); return 0;&#125; 其实重点在隔壁，你们可以去瞅瞅]]></content>
      <tags>
        <tag>c语言</tag>
        <tag>c语言作业</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CocoaPods安装和使用教程]]></title>
    <url>%2F2017%2F11%2FCocoaPods%E5%AE%89%E8%A3%85%E5%92%8C%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[CocoaPods安装和使用教程CocoaPods是什么？当你开发iOS应用时，会经常使用到很多第三方开源类库，比如JSONKit，AFNetWorking等等。可能某个类库又用到其他类库，所以要使用它，必须得另外下载其他类库，而其他类库又用到其他类库，“子子孙孙无穷尽也”，这也许是比较特殊的情况。总之我的意思就是，手动一个个去下载所需类库十分麻烦。另外一种常见情况是，你项目中用到的类库有更新，你必须得重新下载新版本，重新加入到项目中，十分麻烦。如果能有什么工具能解决这些恼人的问题，那将“善莫大焉”。所以，你需要 CocoaPods。 CocoaPods应该是iOS最常用最有名的类库管理工具了，上述两个烦人的问题，通过cocoaPods，只需要一行命令就可以完全解决，当然前提是你必须正确设置它。重要的是，绝大部分有名的开源类库，都支持CocoaPods。所以，作为iOS程序员的我们，掌握CocoaPods的使用是必不可少的基本技能了。 如何下载和安装CocoaPods？在安装CocoaPods之前，首先要在本地安装好Ruby环境。至于如何在Mac中安装好Ruby环境，请google一下，本文不再涉及。 假如你在本地已经安装好Ruby环境，那么下载和安装CocoaPods将十分简单，只需要一行命令。在Terminator（也就是终端）中输入以下命令（注意，本文所有命令都是在终端中输入并运行的。什么，你不知道什么是终端？请你点击左上角谢谢。） 1sudo gem install cocoapods 但是，且慢。如果你在天朝，在终端中敲入这个命令之后，有可能会发现半天没有任何反应。原因无他，因为那堵墙阻挡了cocoapods.org。我们可以用淘宝的Ruby镜像来访问cocoapods。按照下面的顺序在终端中敲入依次敲入命令： 123$ gem sources --remove https://rubygems.org/ //等有反应之后再敲入以下命令 $ gem sources -a http://ruby.taobao.org/ 为了验证你的Ruby镜像是并且仅是taobao，可以用以下命令查看： 1$ gem sources -l 只有在终端中出现下面文字才表明你上面的命令是成功的： 123*** CURRENT SOURCES *** http://ruby.taobao.org/ 上面所有的命令完成之时,你再次在终端中运行： 1$ sudo gem install cocoapods 等上十几秒钟，CocoaPods就可以在你本地下载并且安装好了，不再需要其他设置。 ##如何使用CocoaPods？ 好了，安装好CocoPods之后，接下来就是使用它。所幸，使用CocoPods和安装它一样简单，也是通过一两行命令就可以搞定。 小编在这里用两种使用场景来具体说明如何使用CocoaPods。 场景1：利用CocoaPods，在项目中导入AFNetworking类库AFNetworking类库在GitHub地址是：https://github.com/AFNetworking/AFNetworking 为了确定AFNetworking是否支持CocoaPods，可以用CocoaPods的搜索功能验证一下。在终端中输入： 1$ pod search AFNetworking 过几秒钟之后，你会在终端中看到关于AFNetworking类库的一些信息。这说明，AFNetworking是支持CocoaPods，所以我们可以利用CocoaPods将AFNetworking导入你的项目中。 首先，我们需要在我们的项目中加入CocoaPods的支持。你看到这里也许会问，CocoaPods为什么能下载AFNetworking呢，而不是下载其他类库呢？这个问题的答案是，有个文件来控制CocoaPods该下载什么。这个文件就叫做“Podfile”（注意，一定得是这个文件名，而且没有后缀）。你创建一个Podfile文件，然后在里面添加你需要下载的类库，也就是告诉CocoaPods，“某某和某某和某某某，快到碗里来！”。每个项目只需要一个Podfile文件。 好吧，废话少说，我们先创建这个神奇的PodFile。在终端中进入（cd命令）你项目所在目录，然后在当前目录下，利用vim创建Podfile，运行： 1$ vim Podfile 然后在Podfile文件中输入以下文字： 12platform :ios, &apos;7.0&apos; pod &quot;AFNetworking&quot;, &quot;~&gt; 2.0&quot; 注意，这段文字不是凭空生成的，可以在AFNetworking的github页面找到。这两句文字的意思是，当前AFNetworking支持的iOS最高版本是iOS 7.0, 要下载的AFNetworking版本是2.0。 然后保存退出。vim环境下，保存退出命令是： 1:wq 这时候，你会发现你的项目目录中，出现一个名字为Podfile的文件，而且文件内容就是你刚刚输入的内容。注意，Podfile文件应该和你的工程文件.xcodeproj在同一个目录下。 这时候，你就可以利用CocoPods下载AFNetworking类库了。还是在终端中的当前项目目录下，运行以下命令： 1$ pod install 因为是在你的项目中导入AFNetworking，这就是为什么这个命令需要你进入你的项目所在目录中运行。 运行上述命令之后，终端出现以下信息： 12345678EricmatoMacBook-Pro:CocoaPodsDemo ericwang$ pod install Analyzing dependencies Downloading dependencies Installing AFNetworking (2.0.2) Generating Pods project Integrating client project [!] From now on use `CocoaPodsDemo.xcworkspace`. 注意最后一句话，意思是：以后打开项目就用 CocoaPodsDemo.xcworkspace 打开，而不是之前的.xcodeproj文件。 你也许会郁闷，为什么会出现.xcodeproj文件呢。这正是你刚刚运行$ pod install命令产生的新文件。除了这个文件，你会发现还多了另外一个文件“Podfile.lock”和一个文件夹“Pods”。 点击 CocoaPodsDemo.xcworkspace 打开之后工程之后你会惊喜地发现，AFNetwoking已经成功导入项目了！ 现在，你就可以开始使用AFNetworking.h啦。可以稍微测试一下，在你的项目任意代码文件中输入： 天、123#import &lt;AFNetworking.h&gt; 或者 #import "AFNetworking.h" 然后编译，看看是否出错。 至此，CocoPods的第一个应用场景讲述完毕。其实过程是十分简单的。总结一下就是： 先在项目中创建Podfile，Podfile的内容是你想导入的类库。一般类库的原作者会告诉你导入该类库应该如何写Podfile； 运行命令：`$ pod install. 下面，继续讲述第二种使用场景。 场景2：如何正确编译运行一个包含CocoPods类库的项目你也许曾经遇到过（特别是新手iOS开发者）这种情况，好不容易在GitHub上找到一份代码符合自己想需求，兴冲冲下载下来，一编译，傻眼了，发现有各种各样错误。一看，原来是缺失了各种其他第三方类库。这时候莫慌，你再仔细一看，会发现你下载的代码包含了Podfile。没错，这意味着你可以用CocoaPods很方便下载所需要的类库。 下面，以代码 UAAppReviewManager 为例来说明如何正确编译运行一个包含CocoPods类库的项目。 UAAppReviewManager是一个能够让你方便地将提醒用户评分的功能加入你的应用中。当你去UAAppReviewManager的GitHub地址下载这份代码之后，打开Example工程（UAAppReviewManagerExample），编译，你会发现Xcode报告一大堆错误，基本都是说你编译的这份代码找不到某某头文件，这就意味着你要成功编译UAAppReviewManager的Example代码，必须先导入一些第三方类库。同时你会发现在UAAppReviewManagerExample文件夹下面有三个跟CocosPods相关的文件（文件夹）：Podfile，Podfile.lock和Pods 这时候，打开终端，进入UAAppReviewManagerExample所在的目录，也就是和Podfile在同一目录下，和场景1一样，输入以下命令（由于已经有Podfile，所以不需要再创建Podfile）： 1$ pod update 过几秒（也许需要十几秒，取决于你的网络状况）之后，终端出现： 12345678Analyzing dependencies Fetching podspec for `UAAppReviewManager` from `../` Downloading dependencies Installing UAAppReviewManager (0.1.6) Generating Pods project Integrating client project [!] From now on use `UAAppReviewManagerExample.xcworkspace`. 这时候，再回到UAAppReviewManagerExample文件夹看一看，会看到多了一个文件UAAppReviewManagerExample.xcworkspace： 根据终端的信息提示，你以后就需用新产生的UAAppReviewManagerExample.xcworkspace来运行这个Example代码了。 打开UAAppReviewManagerExample.xcworkspace，编译运行，成功！ 注意，这里有个小问题，如果刚刚你不是输入$ pod update，而是输入$ pod install，会发现类库导入不成功，并且终端出现下面提示： 12[!] Required version (UAAppReviewManager (from `../`)) not found for `UAAppReviewManager`. Available versions: 0.1.6 这里的意思大概是Podfile文件过期，类库有升级，但是Podfile没有更改。$ pod install只会按照Podfile的要求来请求类库，如果类库版本号有变化，那么将获取失败。但是 $ pod update会更新所有的类库，获取最新版本的类库。而且你会发现，如果用了 $ pod update，再用 $ pod install 就成功了。 那你也许会问，什么时候用 $ pod install，什么时候用 $ pod update 呢，不知道类库有没有新版本。那你每次直接用 $ pod update 或者先用 $ pod install，如果不行，再用 $ pod update。 上述都只是CocoaPods的最基本用法。要继续研究CocoaPods其他高级用法，请点击这里CocoaPods Wiki。]]></content>
      <tags>
        <tag>Swift</tag>
        <tag>iOS开发</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Swift-自动布局SnapKit]]></title>
    <url>%2F2017%2F11%2FSwift-%E8%87%AA%E5%8A%A8%E5%B8%83%E5%B1%80SnapKit%2F</url>
    <content type="text"><![CDATA[Swift自动布局SnapKit的详细使用介绍简介SnapKit，一个经典的Swift版的第三方库，专门用于项目的自动布局，目前在github上的stars就高达11346颗星，这是一个不小的数字，亦足以证明它存在的非凡意义和作用。作者认为，在iOS开发（swift）中，它是用于项目最优秀的自动布局的必选库之一。它的作者仍然是写Objective-C的第三方库Masonry的大牛 - Robert Payne，开门见山，本文将详细介绍介绍SnapKit的详细使用和安装，相信对于初入门该库的开发者或许会有一定的帮助，当然，鉴于作者能力有限，如有不足之处，欢迎指点和批评。 Snapkit的安装环境配置要求： iOS 8.0 / Mac OS X 10.11+ Xcode 8.0+ Swift 3.0+ 安装在已经安装CocoaPods的前提下， 即可以进行下列步骤。 在你的项目工程里的Podfile文件里面添加 123456789source &apos;https://github.com/CocoaPods/Specs.git&apos;platform :ios, &apos;10.0&apos;use_frameworks!target &apos;这里是你的工程名称&apos; do pod &apos;SnapKit&apos;, &apos;~&gt; 3.0&apos;end 老生常谈，运行CocoaPods的如下命令 1pod install 到此，不出意外的话，你已经将SnapKit集成到你的项目中了。然后，就开始讲怎么使用它了。 Snapkit的布局使用1、 实现一个宽高为100，居于当前视图的中心的视图布局，示例代码如下 123456789101112131415161718import UIKitimport SnapKitclass ViewController: UIViewController &#123; override func viewDidLoad() &#123; super.viewDidLoad() let testView = UIView() testView.backgroundColor = UIColor.cyan view.addSubview(testView) testView.snp.makeConstraints &#123; (make) in make.width.equalTo(100) // 宽为100 make.height.equalTo(100) // 高为100 make.center.equalTo(view) // 位于当前视图的中心 &#125; &#125;&#125; 更简洁的写法可以 1234567891011121314151617import UIKitimport SnapKitclass ViewController: UIViewController &#123; override func viewDidLoad() &#123; super.viewDidLoad() let testView = UIView() testView.backgroundColor = UIColor.cyan view.addSubview(testView) testView.snp.makeConstraints &#123; (make) in make.width.height.equalTo(100) // 链式语法直接定义宽高 make.center.equalToSuperview() // 直接在父视图居中 &#125; &#125;&#125; 效果图 2、View2位于View1内， view2位于View1的中心， 并且距离View的边距的距离都为20 123456789101112131415161718192021222324252627import UIKitimport SnapKitclass ViewController: UIViewController &#123; override func viewDidLoad() &#123; super.viewDidLoad() // 黑色视图作为父视图 let view1 = UIView() view1.frame = CGRect(x: 0, y: 0, width: 300, height: 300) view1.center = view.center view1.backgroundColor = UIColor.black view.addSubview(view1) // 测试视图 let view2 = UIView() view2.backgroundColor = UIColor.magenta view1.addSubview(view2) view2.snp.makeConstraints &#123; (make) in make.top.equalToSuperview().offset(20) // 当前视图的顶部距离父视图的顶部：20（父视图顶部+20） make.left.equalToSuperview().offset(20) // 当前视图的左边距离父视图的左边：20（父视图左边+20） make.bottom.equalToSuperview().offset(-20) // 当前视图的底部距离父视图的底部：-20（父视图底部-20） make.right.equalToSuperview().offset(-20) // 当前视图的右边距离父视图的右边：-20（父视图右边-20） &#125; &#125;&#125; 更简洁的写法 123456789101112131415161718192021222324import UIKitimport SnapKitclass ViewController: UIViewController &#123; override func viewDidLoad() &#123; super.viewDidLoad() // 黑色视图作为父视图 let view1 = UIView() view1.frame = CGRect(x: 0, y: 0, width: 300, height: 300) view1.center = view.center view1.backgroundColor = UIColor.black view.addSubview(view1) // 测试视图 let view2 = UIView() view2.backgroundColor = UIColor.magenta view1.addSubview(view2) view2.snp.makeConstraints &#123; (make) in make.edges.equalToSuperview().inset(UIEdgeInsets(top: 20, left: 20, bottom: 20, right: 20)) &#125; &#125;&#125; 效果图 3、布局一个视图view2， 让它的水平中心线小于等于另一个视图view2的左边，可以这样布局 1234567891011121314151617181920212223242526272829import UIKitimport SnapKitclass ViewController: UIViewController &#123; override func viewDidLoad() &#123; super.viewDidLoad() // 黑色视图作为父视图 let view1 = UIView() view1.frame = CGRect(x: 0, y: 0, width: 300, height: 300) view1.center = view.center view1.backgroundColor = UIColor.black view.addSubview(view1) // 测试视图 let view2 = UIView() view2.backgroundColor = UIColor.magenta view1.addSubview(view2) view2.snp.makeConstraints &#123; (make) in // 让顶部距离view1的底部为10的距离 make.top.equalTo(view1.snp.bottom).offset(10) // 设置宽、高 make.width.height.equalTo(100) // 水平中心线&lt;=view1的左边 make.centerX.lessThanOrEqualTo(view1.snp.leading) &#125; &#125;&#125; 效果图 视图的属性说明通过上面的大致简单布局我们对SnapKit有了一个基本的了解，那么， 它的布局属性是怎么来的呢？和原生的布局类有什么关联？ 下面看一个SnapKit的布局属性表 从表中，我们知道，Snapkit的布局属性都是源自于系统的NSLayoutAttribute，那么，NSLayoutAttribute是个什么呢？其实，它在swift中是一个枚举，内部列举了很多布局属性诸如top、left、leading、centerX等，Snapkit的布局属性与它们都存在一一的对应关系。 Snapkit 的 greaterThanOrEqualTo 属性如果想让视图View2的左边&gt;=父视图View1的左边， 这时我们就可以用到greaterThanOrEqualTo 12345678910111213141516171819202122232425262728293031import UIKitimport SnapKitclass ViewController: UIViewController &#123; override func viewDidLoad() &#123; super.viewDidLoad() // 黑色视图作为父视图 let view1 = UIView() view1.frame = CGRect(x: 0, y: 0, width: 300, height: 300) view1.center = view.center view1.backgroundColor = UIColor.black view.addSubview(view1) // 测试视图 let view2 = UIView() view2.backgroundColor = UIColor.magenta view1.addSubview(view2) view2.snp.makeConstraints &#123; (make) in // 让顶部距离view1的底部为10的距离 make.top.equalTo(view1.snp.bottom).offset(10) // 设置宽、高 make.width.height.equalTo(100) // 水平中心线&lt;=view1的左边 make.left.greaterThanOrEqualTo(view1) // 或者, 和上面一行代码一样的效果// make.left.greaterThanOrEqualTo(view1.snp.left) &#125; &#125;&#125; 效果图 其实，greaterThanOrEqualTo这个属性有点多余，比如上面这行代码 make.left.greaterThanOrEqualTo(view1) ， 我们可以换成 make.left.equalToSuperview()或make.left.equalTo(view1.snp.left)， 效果是一样的，也就是说，一般情况下 &gt;= 或 &lt;= 我们都可以直接用equalTo来代替！ SnapKit的greaterThanOrEqualTo和lessThanOrEqualTo联合使用当我们想要让某个视图的width或height大于等于某个特定的值，小于等于某个特定的值的时候，一般而言，Snapkit会以greaterThanOrEqualTo为准，这里举一个width的例子，为了方便，这里指贴出了viewDidLoad中的代码（其他没必要） 1234567891011121314151617// 黑色视图作为父视图let view1 = UIView()view1.frame = CGRect(x: 0, y: 0, width: 300, height: 300)view1.center = view.centerview1.backgroundColor = UIColor.blackview.addSubview(view1)// 测试视图let view2 = UIView()view2.backgroundColor = UIColor.magentaview1.addSubview(view2)view2.snp.makeConstraints &#123; (make) in make.width.lessThanOrEqualTo(300) make.width.greaterThanOrEqualTo(200) make.height.equalTo(100) make.center.equalToSuperview()&#125; 接着，我们来看一下效果图 很明显，最后的宽度是以make.width.greaterThanOrEqualTo(200)为标准的，也可以这样的，在同时使用两者的情况下，greaterThanOrEqualTo的优先级略比lessThanOrEqualTo的优先级高。值得一提的是， 在上面的例子中，如果我们只设置make.width.lessThanOrEqualTo(300)，那么view2是不会显示出来的，因为view2不知道你要表达的是要显示多少，小于等于300，到底是100还是200呢？(这里指针对width和height）所以它不能确定这个约束的值，但是，如果我们单独设置make.width.greaterThanOrEqualTo(200)，那么就和上面的效果一样，因为它会以200为标准布局约束！ lessThanOrEqualTo的用于上、下、左、右如果我们想要视图view2的左边 &lt;= view1.left + 10, 那么就可以直接用到lessThanOrEqualTo布局了，看下面这个例子 1234567891011121314151617// 黑色视图作为父视图let view1 = UIView()view1.frame = CGRect(x: 0, y: 0, width: 300, height: 300)view1.center = view.centerview1.backgroundColor = UIColor.blackview.addSubview(view1)// 测试视图let view2 = UIView()view2.backgroundColor = UIColor.magentaview1.addSubview(view2)view2.snp.makeConstraints &#123; (make) in make.left.lessThanOrEqualTo(20) // &lt;= 父视图的左边+20 make.right.equalTo(-40) // = 父视图的右边-40 make.height.equalTo(100) make.center.equalToSuperview()&#125; 效果图 Snapkit布局的灵活性 Snapkit布局灵活性很强， 我们看下面的例子, 他们的效果是一样的 123make.left.equalToSuperview().offset(10)make.left.equalTo(10)make.left.equalTo(view1.snp.left).offset(10) 设置视图的大小（width，height）,他们效果是一样的 123456make.width.height.equalTo(100)或make.width.equalTo(100)make.height.equalTo(100)或make.size.equalTo(CGSize(width: 100, height: 100)) 优先级(priority) 我们来看一下Snapkit的优先级设置， 优先级都是附加在约束链的末尾处，看下面的使用方法 1234567891011121314151617// 黑色视图作为父视图let view1 = UIView()view1.frame = CGRect(x: 0, y: 0, width: 300, height: 300)view1.center = view.centerview1.backgroundColor = UIColor.blackview.addSubview(view1)// 测试视图let view2 = UIView()view2.backgroundColor = UIColor.magentaview1.addSubview(view2)view2.snp.makeConstraints &#123; (make) in make.width.equalTo(100).priority(666) make.width.equalTo(250).priority(999) make.height.equalTo(111) make.center.equalToSuperview()&#125; 效果图 从上面我们可以知道, 我们设置了两个优先级：make.width.equalTo(100).priority(666) 和 make.width.equalTo(250).priority(999)， 那运行结果是一个哪个为准呢？显然是以优先级为 999的为准，因为 priority(999)&gt;priotity(666)， 所以在使用Snapkit的过程中，有时我们可以使用优先级priority来设置我们的约束， 另外，值得一提的是，SnapKit的优先级最大值只能是 1000， 如果优先级的数值超过1000，则运行时就会Crash！这里要尤其注意。 更新约束（引用约束） 我们可以通过保存某一个约束布局来更新相应的约束，或者保存一组约束布局到一个数组中更新约束， 具体看下面代码 12345678910111213141516171819202122232425262728293031323334// 保存约束（引用约束）var updateConstraint: Constraint?override func viewDidLoad() &#123; super.viewDidLoad() // 黑色视图作为父视图 let view1 = UIView() view1.frame = CGRect(x: 0, y: 0, width: 300, height: 300) view1.center = view.center view1.backgroundColor = UIColor.black view.addSubview(view1) // 测试视图 let view2 = UIView() view2.backgroundColor = UIColor.magenta view1.addSubview(view2) view2.snp.makeConstraints &#123; (make) in make.width.height.equalTo(100) // 宽高为100 self.updateConstraint = make.top.left.equalTo(10).constraint // 距离父视图上、左为10 &#125; let updateButton = UIButton(type: .custom) updateButton.backgroundColor = UIColor.brown updateButton.frame = CGRect(x: 100, y: 80, width: 50, height: 30) updateButton.setTitle("更新", for: .normal) updateButton.addTarget(self, action: #selector(updateConstraintMethod), for: .touchUpInside) view.addSubview(updateButton)&#125;// 更新约束func updateConstraintMethod() &#123; self.updateConstraint?.update(offset: 50) // 更新距离父视图上、左为50&#125; 更新约束(snp.updateConstraints) 说起这个updateConstraints, 我也懵逼过，那么它到底有何作用呢？又怎么用呢？它和一开始就使用的makeConstraints又有什么明确的区别呢？请继续往下看 说明1：如果你这是更新某个约束或某几个约束的常量值，你就可以使用updateConstraints而不是makeConstraints。 说明2：这个也是苹果推荐用来添加或更新约束的方式 说明3：这个方法可以调用多次，会相应setNeedsUpdateConstraints, 在控制器中，可以写在override func updateViewConstraints()方法里面（当然也可以写在你想要什么时候更新的点击事件里面） 12345678910111213141516171819202122232425262728293031323334import UIKitimport SnapKitclass ViewController: UIViewController &#123; lazy var blackView = UIView() override func viewDidLoad() &#123; super.viewDidLoad() blackView.backgroundColor = UIColor.black view.addSubview(blackView) blackView.snp.makeConstraints &#123; (make) in // 四个约束确定位置和大小 make.width.equalTo(100) make.height.equalTo(150) make.top.equalTo(10) make.centerX.equalToSuperview() &#125; &#125; override func updateViewConstraints() &#123; blackView.snp.updateConstraints &#123; (make) in // 更新距离父视图顶部的约束（从 10 ---&gt; 300 ） make.top.equalTo(300) &#125; // 根据苹果，调用父类应该放在末尾 super.updateViewConstraints() &#125;&#125; 注意: 从上面的代码中我们很明确地知道， blackView通过width、height、top、centerX确定了它本身的大小和位置， 但是， 在 run 出来之后，它的top改变了距离， 从 10 变成了 300，其他三个约束保持不变， 见下图效果： 显而易见， 除了top约束， 其他都没有改变！ 也就是说，约束被更新（相当于系统升级一样，是一个道理） 现在，我们通过UIButton的点击事件来证明一下制作约束makeConstraints和updateConstraints具体的区别在哪里？ 1234567891011121314151617181920212223242526272829303132lazy var blackView = UIView()override func viewDidLoad() &#123; super.viewDidLoad() blackView.backgroundColor = UIColor.black view.addSubview(blackView) blackView.snp.makeConstraints &#123; (make) in make.width.equalTo(100) make.height.equalTo(150) make.top.equalTo(50) make.centerX.equalToSuperview() &#125; let btn = UIButton(type: .custom) btn.backgroundColor = UIColor.brown btn.frame = CGRect(x: 100, y: 200, width: 60, height: 30) btn.addTarget(self, action: #selector(buttonAction), for: .touchUpInside) view.addSubview(btn)&#125;// 点击更新/制作约束func buttonAction() &#123; blackView.snp.makeConstraints &#123; (make) in make.width.height.equalTo(20) make.top.equalTo(300) &#125;&#125; 先看效果图 点击事件发生前(图1）： 点击事件发生后（图2） 图3 图4 上面，我们知道，视图 blackView一开始是由四个约束确定位置和大小，在点击事情响应后，我们又给 blackView 制作（记住，是制作，而不是重做，两者有明确的区别）了3个约束，分别是 width、height、top, 那么这样做问题出现在哪里呢？ 第一， 点击事情发生前（图1）， 在点击事件发生后（见图2）， 我们发现，blackView的width、height约束改变了，但是 top却没有改变，还是原来的距离父视图顶部 50 的距离， 原因在于，我们在原来的约束基础上又添加了多余的约束， 也就是说，约束从4个变成了7个（见图3左边constraints）， 这样就产生了约束不明确，进而导致snapkit的警告（见图4）， 这样布局显然是不可取的，在项目中这样做极其危险，甚至可能会导致异常奔溃！！！！ 现在， 我们该将点击事件中的约束布局从makeConstraints改变成updateConstraints来试试两者有什么区别(下面只添加了点击事件的代码，其他事重复的就不多此一举了） 12345678func buttonAction() &#123; // 注意这里是updateConstraints， 而不是makeConstraints blackView.snp.updateConstraints &#123; (make) in make.width.height.equalTo(20) make.top.equalTo(300) &#125; print(&quot;这里试试snapkit有没有报警告&quot;)&#125; 接着看点击事件后的效果图 图5 图6 图7 发现没有，在将makeConstraints改变成updateConstraints之后，约束还是4个，snapkit没有报警告，点击事件中的width、height、top全部起了作用，而这就是两者的本质区别：makeConstraints是制作约束，在原来的基础上再添加另外的约束，也就是画蛇添足，约束增加，视图布局就有不确定性，从而有些约束起作用，有些不起作用（如上面的top），snapkit报警告！！！而updateConstraints是更新约束，改变原有约束，约束不会增加，没经过updateConstraints处理的保持原有约束，经过处理就更新约束，约束不会减少，snapkit不会产生警告，这是正常标准的更新约束的正确方式！！！ 重做约束（remakeConstraints） 重做约束的本质就是：去掉已有的所有约束， 重新做约束，记住，是做约束， 也就是说， 使用了remakeConstraints后，重做的约束必须要能确定相应视图的大小和位置, 之前makeConstraints的约束已经不会存在了，完全销毁！！！ 1234567891011// 点击更新/制作约束func buttonAction() &#123; // 注意这里是 remakeConstraints blackView.snp.remakeConstraints &#123; (make) in make.width.height.equalTo(20) make.top.equalTo(300) &#125; print("这里试试snapkit有没有报警告")&#125; 效果图 图（1） 图（2） 图（3） 我们看到， blackView重做了约束， 之前的约束不起任何作用，由于它在重做约束后只有 3 个约束分别是 width、height、top, 但是这里有一个问题，就是这 3 个约束只能确定大小，无法确定视图的位置， 所以在水平方向上或者左右缺少一个布局条件， 故 blackView整体视图的x紧靠左边（默认）！ 另外我们发现， 在图（3）中，右上角出现了一个感叹号“！”, 那是因为告诉你缺少了一个约束条件：x-xcode-debug-views://7f81fcbc7900: runtime: Layout Issues: Horizontal position is ambiguous for UIView. 小结通过以上学习，我们或深或浅地学习了布局三方库SnapKit的使用， 我相信，只要将上述布局会使用，并且懂得布局的原则和道理，基本上就可以“高枕无忧”了，至于涉及动态布局、动画布局等知识，后续有时间会更新文档。]]></content>
      <tags>
        <tag>Swift库</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[c语言课后实验作业6]]></title>
    <url>%2F2017%2F11%2Fc%E8%AF%AD%E8%A8%80%E8%AF%BE%E5%90%8E%E5%AE%9E%E9%AA%8C%E4%BD%9C%E4%B8%9A6%2F</url>
    <content type="text"><![CDATA[想起来了立马更新=。= 感觉实验6好简单吖 进阶练习3.1没啥好说的，老师上课也讲了。 123456789101112131415161718192021222324252627282930313233343536373839404142434445#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;#define N 1024int main()&#123; char str[N]; int num[26][2]; int i,j,t; for (i =0 ; i&lt;26; i++) &#123; num[i][0] = 'a'+i; num[i][1] = 0; &#125; gets(str); for ( i = 0; i&lt;strlen(str); i++) &#123; if (str[i]&gt;='a' &amp;&amp; str[i]&lt;='z') &#123; num[str[i]-'a'][1]++; &#125; &#125; for ( i = 0; i&lt;26-1; i++) &#123; for ( j = 0; j&lt;26-1; j++) &#123; if (num[j][1]&lt;num[j+1][1]) &#123; t = num[j+1][1]; num[j+1][1] = num[j][1]; num[j][1] = t; &#125; &#125; &#125; for (i = 0; i&lt;26; i++) &#123; if (num[i][1]&gt;0) &#123; printf("%c\t%d\n",num[i][0],num[i][1]); &#125; &#125; return 0;&#125; 进阶练习3.212345678910111213141516171819202122232425262728293031323334353637383940414243#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;int main()&#123; char str[3][81]; int upper = 0,lower = 0,digit = 0,space = 0,other = 0; int i,j; printf ("请输入三行字符：\n"); for (i=0;i&lt;3;i++) gets(str[i]); for (i=0;i&lt;3;i++) &#123; for (j=0;j&lt;strlen(str[i]);j++)//注意这里要用strlen来计算长度作为循环的标准 &#123; if (str[i][j]&gt;='A' &amp;&amp; str[i][j]&lt;='Z')&#123; upper++; &#125; else if (str[i][j]&gt;='a' &amp;&amp; str[i][j]&lt;='z')&#123; lower++; &#125; else if (str[i][j]&gt;='0' &amp;&amp; str[i][j]&lt;='9')&#123; digit++; &#125; else if ((str[i][j]=' '))&#123; space++; &#125; else&#123; other++; &#125; &#125; &#125; printf("大写字母：%d 个\n",upper); printf("小写字母：%d 个\n",lower); printf("数 字：%d 个\n",digit); printf("空 格：%d 个\n",space); printf("其 它：%d 个\n",other); return 0;&#125; 进阶练习3.312345678910111213141516171819#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;int main()&#123; char str[1024]; gets(str); for (int i =0; i&lt;strlen(str);i++) &#123; if (str[i]==',') &#123; str[i]='\n';//直接检测到逗号就替换为换行，这是最简单办法 &#125; else ; &#125; puts(str); return 0;&#125; 进阶练习3.412FIB WARRING:practice is missing，the police is searching..... &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;/// OOO ///警方突袭进行中/// OOO ///&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt; 我也不知哪里去了，或许3.4逃走了吧。。。 进阶练习3.512345678910111213141516171819202122232425262728293031323334353637383940//貌似有点不美观，不过再次懒得改了- -！#include&lt;stdio.h&gt;#include&lt;string.h&gt;int main()&#123; int i,flag,top=0; unsigned long len;//编译器提示：Implicit conversion loses integer precision: 'unsigned long' to 'int'，说明推荐我们使用unsigned long，因为len可能会超出限制长度 char str1[1024],str2[1024];//st2存放的只有字母 gets(str1); len=strlen(str1); for(i=0;i&lt;len;i++)//用来判断字符，如果是字母就移动位置到前一个地方 &#123; if((str1[i]&gt;='a'&amp;&amp;str1[i]&lt;='z')||(str1[i]&gt;='A'&amp;&amp;str1[i]&lt;='Z')) str2[top++]=str1[i]; &#125; flag = 1; len = strlen(str2); for(i = 0; i &lt; len/2; i ++)//此时开始从两头往中间开始判断 &#123; if(str2[i] != str2[len - 1 -i]) &#123; flag = 0; break; &#125; &#125; if(flag)&#123; printf("Yes!\n"); &#125; else&#123; printf("No!\n"); &#125; return 0;&#125; 看完了？]]></content>
      <tags>
        <tag>c语言</tag>
        <tag>c语言作业</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[c语言struct结构体简介]]></title>
    <url>%2F2017%2F11%2Fc%E8%AF%AD%E8%A8%80struct%E7%BB%93%E6%9E%84%E4%BD%93%E7%AE%80%E4%BB%8B%2F</url>
    <content type="text"><![CDATA[这篇文章简要的介绍了c语言结构体的一些用法和定义=。= 初见想必大家已经对数组比较了解了，它是一组具有相同类型的数据的集合。但在实际的编程过程中，我们往往还需要一组类型不同的数据，例如对于学生信息登记表，姓名为字符串，学号为整数，年龄为整数，所在的学习小组为字符，成绩为小数，因为数据类型不同，显然不能用一个数组来存放。 在C语言中，可以使用结构体（Struct）来存放一组不同类型的数据。通俗讲就像是打包封装，把一些有共同特征（比如同属于某一类事物的属性，往往是某种业务相关属性的聚合）的变量封装在内部，通过一定方法访问修改内部变量。 结构体是一种集合，它里面包含了多个变量或数组，它们的类型可以相同，也可以不同，每个这样的变量或数组都称为结构体的成员（Member）。结构名是结构的标识符不是变量名。构成结构的每一个类型变量称为结构成员, 它象数组的元素一样, 但数组中元素是以下标来访问的, 而结构是按变量名字来访问成员的。 定义第一种：只有结构体定义12345struct stuff&#123; char job[20]; int age; float height;&#125;; 第二种：附加该结构体类型的“结构体变量”的初始化的结构体定义123456//直接带变量名hhh2233struct stuff&#123; char job[20]; int age; float height; &#125;bang; 也许初期看不习惯容易困惑，其实这就相当于： 123456struct stuff&#123; char job[20]; int age; float height;&#125;;struct stuff bang; 第三种：如果该结构体你只用一个变量hhh2233，而不再需要用去定义第二个变量。1struct stuff yourname; 那么，附加变量初始化的结构体定义还可进一步简化出 第三种：12345struct&#123; char job[20]; int age; float height;&#125;bang; 把结构体名称去掉，这样更简洁，不过也不能定义其他同结构体变量了 结构体变量及其内部成员变量的定义及访问： 绕口吧？要分清结构体变量和结构体内部成员变量的概念。 就像刚才的第二种提到的，结构体变量的声明可以用： 1struct stuff yourname; 其成员变量的定义可以随声明进行： 1struct stuff bang = &#123;"manager",30,185&#125;; 也可以考虑结构体之间的赋值： 1234 struct stuff faker = bang;//或 struct stuff faker2;// faker2 = faker; 可见结构体的每一个成员变量一模一样 如果不使用上边两种方法，那么成员数组的操作会稍微麻烦（用for循环可能好点） 1234bang.job[0] = 'M';bang.job[1] = 'a';bang.age = 27;bang.height = 185; 结构体成员变量的访问除了可以借助符号”.”，还可以用”-&gt;”访问（下边会提）。 引用（C++）、指针和数组：首先是 引用和指针：12345678910111213141516171819int main()&#123; struct stuff bang; struct stuff &amp;ref = bang; ref.age = 100; printf("bang.age is %d\n",bang.age); printf("ref.age is %d\n",ref.age); struct stuff *ptr = &amp;bang; ptr-&gt;age = 200; printf("bang.age is %d\n",bang.age); printf("ptr-&gt;age is %d\n",bang.age);//指针引用也加上了 struct stuff *&amp;refToPtr = ptr; refToPtr-&gt;age = 300; printf("bang.age is %d\n",bang.age); printf("refToPtr-&gt;age is %d\n",refToPtr-&gt;age);&#125; 结构体也不能免俗，必须有数组： 123456789101112struct test&#123; int a[3]; int b;&#125;;//对于数组和变量同时存在的情况，有如下定义方法： struct test student[3] = &#123;&#123;&#123;66,77,55&#125;,0&#125;, &#123;&#123;44,65,33&#125;,0&#125;, &#123;&#123;46,99,77&#125;,0&#125;&#125;;//特别的，可以简化成： struct test student[3] = &#123;&#123;66,77,55,0&#125;, &#123;44,65,33,0&#125;, &#123;46,99,77,0&#125;&#125;; 变长结构体可以变长的数组 123456789101112131415161718192021#include &lt;stdio.h&gt;#include &lt;malloc.h&gt;#include &lt;string.h&gt;typedef struct changeable&#123; int iCnt; char pc[0];&#125;schangeable;main()&#123; printf("size of struct changeable : %d\n",sizeof(schangeable)); schangeable *pchangeable = (schangeable *)malloc(sizeof(schangeable) + 10*sizeof(char)); printf("size of pchangeable : %d\n",sizeof(pchangeable)); schangeable *pchangeable2 = (schangeable *)malloc(sizeof(schangeable) + 20*sizeof(char)); pchangeable2-&gt;iCnt = 20; printf("pchangeable2-&gt;iCnt : %d\n",pchangeable2-&gt;iCnt); strncpy(pchangeable2-&gt;pc,"hello world",11); printf("%s\n",pchangeable2-&gt;pc); printf("size of pchangeable2 : %d\n",sizeof(pchangeable2));&#125; 运行结果 12345size of struct changeable : 4size of pchangeable : 4pchangeable2-&gt;iCnt : 20hello worldsize of pchangeable2 : 4 结构体本身长度就是一个int长度（这个int值通常只为了表示后边的数组长度），后边的数组长度不计算在内，但是该数组可以直接使用。说后边是个指针吧？指针也占长度！这个是不占的！原理很简单，这个东西完全是数组后边的尾巴，malloc开辟的是一片连续空间。 Ps：非弹性数组不能用”char a[]”这种形式定义弹性（flexible）变量，必须明确大小。 弹性数组在结构体中，下面的形式是唯一允许的： 12345struct s&#123; int a; char b[] ;&#125;; 顺序颠倒会让b和a数据重合，会在编译时不通过。 char b[] = “hell”;也不行（C和C++都不行） 少了整型变量a又会让整个结构体长度为0，compiler不允许编译通过。不同的是， 其实C++形式上是允许空结构体的，本质上是通过机制避免了纯空结构体和类对象，自动给空结构体对象分配一个字节（sizeof（）返回1）方便区分对象，避免地址重合！ 所以呢，C如果有空结构体，定义两个（或一打，或干脆一个数组）该结构体的变量（对象），地址是完全一样的。调试看程序运行，这些语句其实根本没有运行，没有实际意义，C压根不支持空结构体这种东西。 123456789101112struct s2&#123;// char a[] = "hasd" ;// int c;&#125;;int main()&#123; struct s2 s22; struct s2 s23; struct s2 s24; struct s2 s25;&#125; 例外的是，C++唯独不给带弹性数组的结构体分配空间（可能怕和变长结构体机制产生某种冲突，比如大小怎么算）: 12345678910//程序一struct s &#123; char b[] ; &#125;; //程序二struct s&#123; char b[] ;&#125;; C++中两者是不一样的，空的结构体反而“大”（sizeof()返回1） 这个机制利用了一个非常重要的特性——数组和指针的区别！数组和指针在很多操作上是一样的，但是本质不一样。最直观的，指针可以改指向，数组不可以，因为数组占用的每一个内存地址都用来保存变量或者对象，而指针占用的内存地址保存的是一个地址，数组没有单独的保存指向地址的这样一个结构。数组的位置是固定的，正如指针变量自身的位置也是固定的，改的是指针的值，是指向的目标地址，而因为数组不存储目标地址，所以改不了指向。企图把地址强制赋值给数组的话，也只是说把指针赋值给数组，类型不兼容。 结构体嵌套：结构体嵌套其实没有太意外的东西，只要遵循一定规律即可： 12345678910//对于“一锤子买卖”，只对最终的结构体变量感兴趣，其中A、B也可删，不过最好带着struct A&#123; struct B&#123; int c; &#125; b;&#125;a;//使用如下方式访问：a.b.c = 10; Specially,可以一边定义结构体B，一边就使用上： 12345678struct A&#123; struct B&#123; int c; &#125;b; struct B sb;&#125;a; 使用方法与测试： 12345a.b.c = 11;printf("%d\n",a.b.c);a.sb.c = 22;printf("%d\n",a.sb.c);//运行正确 但是如果嵌套的结构体B是在A内部才声明的，并且没定义一个对应的对象实体b，这个结构体B的大小还是不算进结构体A中。 结构体与函数：关于传参，首先： 12void func(int);func(a.b.c); 把结构体中的int成员变量当做和普通int变量一样的东西来使用，是不用脑子就想到的一种方法。 另外两种就是传递副本和指针了 ： 12345678910111213141516//struct A定义同上//设立了两个函数，分别传递struct A结构体和其指针。void func1(struct A a)&#123; printf("%d\n",a.b.c);&#125;void func2(struct A* a)&#123; printf("%d\n",a-&gt;b.c);&#125;main()&#123; a.b.c = 112; struct A * pa; pa = &amp;a; func1(a); func2(&amp;a); func2(pa);&#125; 占用内存空间： struct结构体，在结构体定义的时候不能申请内存空间，不过如果是结构体变量，声明的时候就可以分配——两者关系就像C++的类与对象，对象才分配内存（不过严格讲，作为代码段，结构体定义部分“.text”真的就不占空间了么？当然，这是另外一个范畴的话题）。 结构体的大小通常（只是通常）是结构体所含变量大小的总和，下面打印输出上述结构体的size： 123printf("size of struct man:%d\n",sizeof(struct man));printf("size:%d\n",sizeof(Huqinwei));结果是28：分别是char数组20，int变量4，浮点变量4. 下边说说不通常： 对于结构体中比较小的成员，可能会被强行对齐，造成空间的空置，这和读取内存的机制有关，为了效率。通常32位机按4字节对齐，小于的都当4字节，有连续小于4字节的，可以不着急对齐，等到凑够了整，加上下一个元素超出一个对齐位置，才开始调整，比如3+2或者1+4，后者都需要另起（下边的结构体大小是8bytes），相关例子就多了，不赘述。 123456struct s&#123;char a;short b;int c;&#125; 相应的，64位机按8字节对齐。不过对齐不是绝对的，用#pragma pack()可以修改对齐，如果 改成1，结构体大小就是实实在在的成员变量大小的总和了。 和C++的类不一样，结构体不可以给结构体内部变量初始化，。 如下，为错误示范： 12345678#include&lt;stdio.h&gt;//直接带变量名bangstruct stuff&#123; char job[20] = "Programmer"; char job[]; int age = 27; float height = 185;&#125;bang;//错误示范！ PS：结构体的声明也要注意位置的，作用域不一样。C++的结构体变量的声明定义和C有略微不同，说白了就是更“面向对象”风格化，要求更低。 PSS：typedef定义结构体例如 12345typedef struct person &#123;int age ;char *name;char *sex;&#125; student; 我们可以用student来定义一个结构体变量：student stu1；typedef的作用就相当于给你struct person取了一个别名，如果我们不用typedef定义我们就不能用student定义，此时student就是一个结构体变量，如果要定义结构体变量的话就得用struct person来定义 struct person stu1. ####typedef的其它定义： typedef char name[51]; 如果想要定义多个相同类型长51的数组，我们可以直接用name定义比如name sex;可能大家对这里不太好理解，如果看过关于数据类型的介绍方面的知识大家就很好理解了，或者经常用java编写程序的就很好理解的 其实我们可以可以把 typedef char name【51】看作 typedef char【51】name，更具typedef的语法可以知道name是给 char name 【51】取得别名。这些知道怎么回事了吧。 其实c结构体和对象编程 像java等里面的类是非常相似的。不过像C++里面对结构体进行了扩展，c++里面的结构体是可以包含方法的，但是C里面是不能够的。]]></content>
      <tags>
        <tag>c语言</tag>
        <tag>c语言语法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[c语言课后作业实验5]]></title>
    <url>%2F2017%2F11%2Fc%E8%AF%AD%E8%A8%80%E8%AF%BE%E5%90%8E%E5%AE%9E%E9%AA%8C%E4%BD%9C%E4%B8%9A5%2F</url>
    <content type="text"><![CDATA[#差点就忘记了- -！（汗） 最近在忙做作品，所以会断断续续的更= =Ps：之前群里有人问一道oj题，然而本人基本没做过oj，就点简单的写了些（在底部），其中我用了struct，会单独放一篇文章讲解。 感觉实验5没啥需要po出来的=。= 基础练习2.7只是添加了一个自己输入行数的功能而已= 。= 123456789101112131415161718192021222324252627282930#include &lt;stdio.h&gt;int main(int argc, const char * argv[])&#123; int arr[30][30]= &#123;0&#125;; int n; printf("input n:"); scanf("%d",&amp;n); for(int i=1; i&lt;=n; i++) &#123; arr[i][1]=1; arr[i][i]=1; if(i&gt;=2) &#123; for(int j=1; j&lt;=i; j++) &#123; arr[i][j]=arr[i-1][j-1]+arr[i-1][j]; &#125; &#125; &#125; for(int i=1; i&lt;=n; i++) &#123; for(int j=1; j&lt;=i; j++) &#123; printf("%3d ",arr[i][j]); &#125; putchar('\n'); &#125; return 0; &#125; 进阶练习3.2既然是要同时输出之前的顺序，不如设定两个数组。(坐下！基本操作而已。) 1234567891011121314151617181920212223242526272829303132333435363738#include &lt;stdio.h&gt;int main(int argc, const char * argv[])&#123; int i, j,k,l,t1,t2; int a[20], b[20]; printf("please enter 20 numbers:"); for( i=0, j=1; i&lt;20; i++, j++) &#123; scanf("%d", &amp;a[i]); b[i] = j; &#125; for( k = 0; k&lt;20; k++)&#123; for( l =k+1; l&lt;=19; l++) &#123; if(a[k]&gt;a[l]) &#123; t1 = a[l];a[l] = a[k];a[k] = t1; t2 = b[l];b[l] = b[k];b[k] = t2; &#125; &#125; &#125; for( i=0; i&lt;20; i++) &#123; printf("%d", a[i]); if(i&lt;19) printf(" "); &#125; printf("\n"); for(i=0; i&lt;20; i++) &#123; printf("%d", b[i]); if(i&lt;19) printf(" "); &#125; printf("\n"); return 0;&#125; 进阶练习3.8123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778//代码写得很不规范，不过我懒得改了=。=#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;void bubbleSortPlus(int a[10])//改进版冒泡排序&#123; int i,j,flag; for(i=0;i&lt;9;i++) &#123; flag=1; for(j=0;j&lt;9-i;j++) &#123; if(a[j] &lt; a[j+1]) &#123; int tmp=a[j]; a[j]=a[j+1]; a[j+1]=tmp; flag=0; &#125; &#125; if(flag == 1) break; &#125; for(i=10;i&gt;0;i--)&#123; printf("%d ",a[i]); &#125; putchar('\n');&#125;void quikSort(int a[],int low,int high)//快速排序&#123; int i = low; int j = high; int temp = a[i]; if( low &lt; high) &#123; while(i &lt; j) &#123; while((a[j] &gt;= temp) &amp;&amp; (i &lt; j)) &#123; j--; &#125; a[i] = a[j]; while((a[i] &lt;= temp) &amp;&amp; (i &lt; j)) &#123; i++; &#125; a[j]= a[i]; &#125; a[i] = temp; quikSort(a,low,i-1); quikSort(a,j+1,high); &#125; else &#123; return; &#125; for(i=0;i&lt;10;i++)&#123; printf("%d ",a[i]); &#125; putchar('\n');&#125;int main()&#123; int i=0,a[10]; printf("Please enter 10 numbers:"); for (i=0; i&lt;10; i++) &#123; scanf("%d",&amp;a[i]); &#125; bubbleSortPlus(a);//调用冒泡 quikSort(a,0,4);//调用快速排序 return 0;&#125; 杭电（hdu）2085 核反应堆题Time Limit: 1000/1000 MS (Java/Others) Memory Limit: 32768/32768 K (Java/Others)Total Submission(s): 12219 Accepted Submission(s): 5547 Problem Description 某核反应堆有两类事件发生：高能质点碰击核子时，质点被吸收，放出3个高能质点和1个低能质点；低能质点碰击核子时，质点被吸收，放出2个高能质点和1个低能质点。假定开始的时候（0微秒）只有一个高能质点射入核反应堆，每一微秒引起一个事件发生(对于一个事件，当前存在的所有质点都会撞击核子)，试确定n微秒时高能质点和低能质点的数目。 Input 输入含有一些整数n(0≤n≤33)，以微秒为单位，若n为-1表示处理结束。 Output 分别输出n微秒时刻高能质点和低能质点的数量，高能质点与低能质点数量之间以逗号空格分隔。每个输出占一行。 Sample Input 125 2-1 Sample Output 12571, 20911, 4 简单分析分析题目得到，某秒的高能质点数是它的前一秒乘3再加上前一秒的低能质点数乘2。 所以不难写出 12345678910111213141516171819202122#include &lt;stdio.h&gt;struct nuclearReactor&#123; long long high,low;&#125;;int main(void)&#123; int i,n; struct nuclearReactor narr[35]; narr[0].high=1; narr[0].low=0; for(i=1; i&lt;=33; i++) &#123; narr[i].high=narr[i-1].high*3+narr[i-1].low*2; narr[i].low=narr[i-1].high+narr[i-1].low; &#125; while((void)(scanf("%d",&amp;n)!=EOF),n!=-1) &#123; printf("%lld, %lld\n",narr[n].high,narr[n].low); &#125; return 0;&#125; 想了解结构体的用法就去看我发布的结构体文章啦～]]></content>
      <tags>
        <tag>c语言</tag>
        <tag>c语言作业</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[为什么 Kotlin 比你们用的那些垃圾语言都好]]></title>
    <url>%2F2017%2F11%2F%E4%B8%BA%E4%BB%80%E4%B9%88Kotlin-%E6%AF%94%E4%BD%A0%E4%BB%AC%E7%94%A8%E7%9A%84%E9%82%A3%E4%BA%9B%E5%9E%83%E5%9C%BE%E8%AF%AD%E8%A8%80%E9%83%BD%E5%A5%BD%2F</url>
    <content type="text"><![CDATA[5月18日，安卓团队在谷歌 I/O 2017 大会上宣布 Kotlin 成为官方头等支持语言。这条爆炸性资讯在当天就是 Hacker News 首页热门讨论，与此同时，谷歌技术大牛 Steve Yegge 也写了一篇关于 Kotlin 的使用体会总结文章，同样也在首页热门，并引发大量讨论（点击进入原文） ​ （Steve Yegge ） 为什么说 Kotlin 比你们用的那些垃圾语言都好哈，这个标题党的题目让你点进来看了吧。不要奇怪，现在标题党在网上很普遍的。而且这篇文章给出的回答，肯定能震撼到你。 说真的，其实我不想去攻击你们的语言信仰……至少不会“大大地”想。毕竟你喜欢的语言大放异彩的时期，可能要追溯到冰川时代了，对不？如果你喜欢的语言到今天还没有死，那只能说明这门语言在逐渐地改进和更新，保持与时俱进。 但改进的速度呢？好吧……假设你现在用的语言碰巧是 Java，并且你也沉溺于 Java 曾经是一门非常优秀的语言的想法，那么你就完蛋了。而且是早就完蛋了。尽管人类都不太喜欢思考终极命运问题，但是相比于在 20 多年前刚刚问世，Java 8 仅仅是做了部分语言特性的替换，对此你禁不住要想：“我真的要和这种语言来共度过的余生么？还是说 Java 也就只能这样了？” 因为终于要开始做 Android 开发了，我把各种老旧的语言问题又过了一遍。我写过一个老游戏 Wyvern，这个游戏已经有一个 iOS 版本了，最近我决定再搞一个 Android 版本。我从来没料到计算机语言会折腾到让我“思考人生”（例如“我这是他娘的在浪费生命么？”）如果你写过 Android 程序的话，你就知道在 Android 领域，语言的问题是会让你相当难熬的。 我第一次尝试写 Android 程序是在去年夏天，我的个老天爷，那感觉简直糟透了。其实是有人警告过我的。他们都说：“那些 API 可是很难搞啊。”而我却不听劝。一意孤行。 我想：这些玩意儿能糟糕到哪儿去呢？反正不就是 Java 么？ 历史代码的灾难真是很不走运——因为很复杂的历史原因，并且也没人在意——造成 Android 的核心 API 实在是糟糕透顶。我是说：真的很糟，真的很糟，真的很糟。你只能关掉参考书，深呼吸，然后出去猛喝咖啡来压压惊。人们之前给我的告诫看来是完全正确的。 Android API 库就是一个百宝箱。很多 API 真的是非常好用。我可以说，很多在 iOS 开发里非常难搞的事情在 Android 里面却很容易。Product flavors、Downloads 服务、findViewById() 方法、Preferences activity 等等，这些都是很好的例子。有太多 Android 里面有的东西在 iOS 里面是诶有的，所以在 iOS 里面你总能看到：开发者自己实现的恶心的和优雅的应用库并存。 但是！注意左边是一个大写加粗的但是！在写 Android 程序的时候，人们只关注那些不好的 API，就像你开车时候只会数路上遇到了几个红灯一样，绿灯的数量是没人关心的。因为人们只会通过红灯的数量来评价路途是否通顺。 Android 确实有几个很糟糕的“红灯”API。例如 Fragments，这就是在 Andoird “红灯” API 中的招牌 API。这个 API 的整个生命周期的糟糕程度达到了令人发指的地步，好吧其实 Activities 和 Fragments 都是如此。说句不中听的，iOS 反而却没有这么糟糕的API。去年夏天我试了试这些API，它们是如此之糟糕以至于我当时就放弃了。我算是彻底服了。去它的，我还是以后找个人来帮我写这些程序吧。 接下来的一年半，我就没再碰过 Android 编程。 来自俄罗斯的救星我一直听说，有一种新语言叫做 Kotlin，可以用来写基于 JVM 或者 Android 程序。发明这种语言的不是别国，正是战斗的民族俄罗斯。更具体一点儿，它是由 JetBrains 开发。JetBrains 可是世界知名的 IDE 开发商，代表作是 Intellij IDEA，还有他们那可爱而且大名鼎鼎的橘色，绿色，紫色和黑色混合的暗色“Darcula”主题。 图：一个千年老妖按捺不住对 Java 8 的兴奋 那么为什么要给这种语言起名叫 Kotlin 呢？好吧，有一种说法是因为 Java 的第一个字母是“J”，而 Kotlin 则用了Java 的下一个字母“K”作为开头。除此之外，有人还猜想（这种猜想可能来自加州大学伯克利分校），“Kotlin”这个名字的灵感还来源于“克里姆林宫”，“赫鲁晓夫”以及“克格勃”。这些都是前苏联的骄傲，所以他们就用了一个前苏联军事基地的名字“Kotlin”来命名这种语言。总之这个名字不错，而且你会习惯它的。 伯乐在线补充：Steve Yegge 在前文关于 Kotlin 的名字来源，应该错了。在他自己原文评论中，也有网友指出了。 正确的应该是：① JetBrains 是一家注册地在捷克布拉格的公司，在全球共有 6 个办公点：布拉格、圣彼得堡、莫斯科、波士顿、慕尼黑和新西伯利亚。但主要管理层和开发者是在圣彼得堡。② 芬兰湾中有个岛就是「Kotlin/科特林」，在圣彼得堡以西 32 公里。 我发现去年业界关于 Kotlin 只是有不少“嘀咕（buzz）”。注意，只是“嘀咕”，不是天花乱坠地吹牛宣传。人们只是低调地“嘀咕”着。好吧，总之，我当时看了一下，然后就觉得这个语言和我过去 15 年看过的 50 ~ 100 种计算机语言一样，这也是一门可以替代 Java 的语言，当然，我认为任何理性的语言都能替代 Java。 对 Kotlin 的第一印象我第一次看到 Kotlin 的时候，真心觉得这种语言不可能在现实生活中用到，真的是一点可能性都没有。其实我也就是走马观花。我的第一印象？这个语言也没什么大问题。它很简洁，也具有先进的特性。如果说它时髦也行，因为它几乎囊括了计算机语言设计上的所有最新潮流。不过这也没什么大不了，因为很多语言也都满足这一点。比如，Rust。Rust 也是一门健壮的，名字起得很好的，但是没什么人用的语言。 Kotlin 给我的一种奇怪的感觉是“似曾相识”，后来我才反应过来，原来这是因为它和 Swift 很像。我之所以没有马上反应过来，是因为我的 iOS 程序因为历史代码的原因不得不用 Objective-C 而不是 Swift 来写。当然现在我也弄明白了：其实 Kotlin 的历史比 Swift 要悠久几年，所以正确的说法应该是：Swift 和 Kotlin 很像。 不过即便如此我当时也没准备用这种语言干活。Kotlin 对我来说确实是一种语法优雅的语言，但是我觉得我对这门语言还没有掌握到足够的程度，以至于让我可以用它来应付残酷的现实工作。 从 Java 叛逃到 Kotlin我不太记得我是具体怎么爱上 Kotlin 的了。但是我敢肯定的是这绝对不是有意为之。 我努力回忆了一下，事情是这样的，我做的那个游戏的玩家跟我说了好久，让我开发一个 Android 版本。这个游戏是 12 月份在 Apple Store 上架的，然后几周之内，大量粉丝就跟我说，他们是 Andorid 用户，所以没法玩到这个游戏。所以，尽管我已经“发誓”再也不碰Android 编程了，但是用户就是上帝，所以我又开始尝试了。不过这一次要换个玩儿法——不能再把胃口坏在 Android 的 Java 语言上了。我需要有个现成的框架，或者什么类似的东西，来让工作变得简单一点儿。 在 1 月中旬，我做了一个粗略评估，然后就决定用 Kotlin 来开发了，Kotlin 当时可同时支持 Dalvik 和 Art 两种 Android 虚拟机。我觉得我的评估是基于以下几个原因： \1. Kotlin 已经小有名气； \2. 当时我写 iOS 版的时候就想用 Swift（但是没用成）； \3. Kotlin有一种挺不错的 Android DSL 叫做 Anko，这勾起了我的兴趣，虽然最后我并没有真的用到它。 所以我就用 Kotlin 开始做了。在接下来的 4-5 周内，我用 Kotlin 重写了游戏的服务平台。要知道这个平台之前已经有 20 多年历史了。用了一个月的 Kotlin，我就被完全征服了。我不是要说 Scala 或者其他语言的坏话，但是对我这种普通码农来说，Koltin 是完美的。我的要求不高，给口饭吃就行，知道不？Scala 固然很好，但是它好得过头了，就像牛蛙\牛脑\松露蜗牛这些高档菜那么好。要知道我就是个蓝领，Clojure、Scala 这类的语言对我来说太高大上了。 我大约花了 3 天时间来学习 Kotlin 的各种语法，然后就开始正式编程了，虽然我还是很不熟练，但是我知道这种语言和 IDE 工具足以让我解决各种麻烦。 当我对这种语言稍微熟悉了一些以后，我就知道，我应该不会再去爱上另外一种语言了，因为 Kotlin 实在是太迷人了。你在代码写出来的东西让你觉得很酷。当然我以前用其他的语言编程的时候也体验过类似的感觉，但是那些语言的学习曲线一般都非常陡峭。Kotlin呢，它就是大救星：当 Java 程序员为了 Java 8 弄出来的一大堆新概念挠头的时候，Kotlin 出现了。Kotlin 能实现 Java 8 的各种新特性，并且通过对 coroutines 的支持，其实能实现更强大的功能，而且语法表现力更简洁。Java 8 确实也能表达很有意思的逻辑，但是很繁琐，感觉就像让你说话之前要先给你嘴里塞沙子。 我想 Kotlin 上手很容易的原因太显而易见了，要归功于它的 IDE 支持。现在几乎所有的 JVM 语言或者 Android 语言的 IDE 支持都是由社区的几个志愿者在维护（当然 Java 除外）。而 Kotlin 则是来自世界级的 IDE 厂商（Jetbrains），所以 Kotlin 打一开始就是自带 IDE 支持的。有多少语言能做到从发明伊始就能有 IDE 支持呢？编程语言的进化历程一般做不到这一点。况且有的编程语言从一开始就是要避开 IDE 这个因素的（Hi！Rob）另外一个能一开始就做到 IDE 支持的语言就是 C#，当然 C# 毫无疑问是全世界最好的编程语言之一。 伯乐在线译注：上面这段中的 Rob，应该是指 Go 语言的发明者 Rob Pike，作者在这里也许是暗讽 Go 语言从发明到现在都没有一个靠谱的 IDE 支持吧。 作为一个自带 IDE 支持的语言，你在 Kotlin buffer 敲代码的时候，打字基本对就可以了。IDE 会帮你补全你没写完的部分。你知道吗，你甚至可以把Java代码复制到IDE里面，然后 IDE 会帮你自动转换成Kotlin代码。如果你觉得 Java 的 IDE 都还不错，那么我可以很荣幸地告诉你，Kotlin IDE 会把这种“不错”推进到前所未有的地步。甚至有一个前微软工程师跟我说：“我本以为微软的 Visual Studio 是 IDE 界的标杆，是不可超越的。但是我觉得 IntelliJ IDEA 的确要更好。”在我看来，因为我对 Visual Studio 不熟悉，所以我在这里只是引用他说的话。不过我认为 IntelliJ IDEA 至少和 VS 是同等水平。 诚然，在现实工作中我还是要经常切换到 Emacs 的。IntelliJ 在你打字很快的时候还是有点儿反应不过来。如果你打字总是只打一半儿的话，那么自动补全动能的运行压力还是很大。况且对纯文本的处理也很糟糕，这是所有 IDE 的通病。所以 IDE 和 Emacs 你都是需要用到的。不幸的是，目前 Emcacs 对 Kotlin 的支持现在也就那么回事儿，不过相信以后会越来越好。我现在反正就是在 Emacs 和 IntelliJ 之间来回切换。目前还算是 OK。 就是这样了。我曾经花了大约 10 年的时间，来找一种语言来取代 Java。我真的找得很努力很辛苦。讽刺的是，在我放弃了以后，这种东西居然出来了。去看看吧。Kudos 对 JetBrains 来说，是一个惊艳的成就。 Android：Kotlin 的杀手锏这年头新生编程语言几乎很难产生什么巨大影响力。不是说现在没有新语言产生了，相反是每年都有质量不错的新语言产生，但是然并卵，没人用！要给“不可能”划定界限很难。但是计算机语言的市场已经非常饱和了。如果要让一个新的语言能够大火（而且这个规律在过去 10 到 20 年都成立），那么这个语言就必须有一个“杀手级”的应用。这门语言需要绑定一个平台，让大家都非常迫切地区使用这个平台，这才能促进大家学习这门语言以便在这个平台上编程。 就目前看来，我们上面所说的杀手级应用——也就是我们上面扯了这么多的东西——却是 Android 恶心的 API。每当你顺着 Android 路线往下走，一遇到 API 就会卡壳，这只会让你去诅咒 Android 这个平台。Android 不论有多少优秀的 API 都不管用，重要的是，Android 糟糕的 API 太多了，所以你不得不停下来去找”现成”的办法（solution）。 不过兄弟，Android 里面解决问题的“现成办法”可是不少。对于新手来说，有一大堆 Java annotation processors可用，这就为语言的问题埋下伏笔。更不要提一堆迷你的框架（比如 Lyft 的 Scoop）。还有那些和 Android（Java）完全独立的框架：React Native、Cordova、Xamarin、Flutter等等。 如果以上说的技术你都不喜欢，那么你还可以从语言的角度来解决问题。当然，那些完全独立的框架是基于特定语言的，而并不是Java。 Kotlin 的竞争优势在于它并不是完全隔离于 Java 语言。它基本上是 100% 可与 Java 相互翻译转换的。这很像C++ 与 C 的关系一样（但它们做不到 100% ）。Kotlin 也是在不断进化的。所以你可以直接把你写的 Kotlin 代码扔到 Android 工程中，连目录都不用改，然后程序就能正常运行了，方便得眼睛都不用眨一下。 其他种类的 Android 平台都倾向于迫使你去学习一种全新的语言以及对应的平台，其编程范式，理念和特性都各不相同。Kotlin 则是让你直接写出 Android 可运行的类，就跟其他 Android 程序员用 Java 写出来的一样。其实其底层的 API 都是一样的，但是 Kotlin 组织得要好很多。 还记得我去年夏天把 Android 编程书扔了然后再也不打算看了么。现在 Kotlin 则让我感觉：Android 编程是快乐的？我甚至觉得可能 Android 那些糟糕的 API 很可能并不是那么糟，只是 Java 把它搞得太恶心了而已。 Kotlin 致力于让大家绕过 Android API 那些恶心的东西，并且能让你充分发挥你的经验，这一点甚至比 iOS 做得还要好。好吧，至少来说比 Objective-C 做得好，因为我觉得 Swift 肯定也不会差。知道为什么吗？因为 Swift 和 Kotlin 很像啊。 我特别喜欢 Kotlin 的地方有哪些？嗯，这个话题其实要细说就很大了，我觉得我最好再开一篇文章来写这个。这里我就提一下那些高级（high-level）且共性的点。 Kotlin 很像 Java。它长得不像 Clojure 或者 Scala 那么奇怪（承认现实把，这两种语言就是挺奇怪的）。所以你学 Kotlin 应该很快。这门语言显然就是写给 Java 开发者来用的。 它比 Java 更安全。Java 很多需要 annotation processors 来做的事情在 Kotlin 里则是内置的，例如 overriding，nullability等等。而且 Kotlin 对数值转换的规则也更安全，虽然我不太喜欢 Kotlin 的处理方式，但是我还是很感谢这门语言强制我去思考我的数值表现形式。 Kotlin 和 Java 是可以互译的。真的是指无缝互译。我见过很多 JVM 语言最后挂掉，就是因为其不支持子类继承机制。我不知道什么时候就会用到静态内部类，非静态内部类，或者什么破玩意儿类。Kotlin 在设计时就把和Java互译的属性放在第一位，也就是说，把 Java 翻译到 Kotlin 可以逐渐进行，一次可以直接转换一个文件。 Kotlin 很简洁。你要知道我也算是个高尔夫球手，所以我实话实说。如果在一切都相同的情况下，我更喜欢短的程序，只要它写的逻辑清楚。Kotlin 对我来说就像是打了一轮好局。平均下来我发现 Kotlin 的代码长度比相同逻辑的 Jython 代码短了 5%-10%（这可是我用某种“黄金标准”测出来的），而且还能保证程序的可读性和类型安全。 Kotlin 更贴近实际。Kotlin 支持在一个文件里定义多个类，支持一等方法，操作符重载，扩展方法，类型别名，字符串模板，还有一堆看上去没什么新意的语言特性它都支持。而我就是不明白为什么 Java 什么都不支持，连人们需要的语言特性它都不做。 Kotlin 进化很快。例如刚刚宣布启动的对 coroutine 的支持，将会成为提供 asyn/await， geneator 以及所有其他无锁并发特性的基础设施。 Kotlin 很擅长“拿来主义”。Kotlin 经常从其他的计算机语言设计中抄点子，并且也毫不避讳。他们说：“我们很喜欢 C# 的处理方式，所以我们就自己照着撸了一个。” Kotlin 支持 DSL。DSL 不到深思熟虑万不得已的话千万不要引入，但是不得不承认 DSL 威力巨大。例如你看 Gradle 的 DSL 和 Maven 比，在典型的 Maven 项目里，配置代码肯定要超过上千行。所以 Kotlin 是来给你降工作压力的。 Kotlin 的 IDE 是在是太棒了。刚才不久我才在 Emacs 里写程序文件，结果 Emacs 报了一对错。而我把同样的代码拷贝到 IntelliJ 里面，然后按 Alt-Enter 逐一自动修复了 50 多条，然后所有的错误就都搞定了。这真是帮了大忙啊。 ​ Kotlin 很有趣。我跟你们说，Kotlin 就是有趣。也许这是我发自潜意识地在做广告。Kolint 的关键字和方法名都很有意思。Kotlin 把我从一个只会死编程的码农转变为了一个计算机语言的爱好者。 总之，你就这么想：我收拾东西搬家，然后碰到了邻居 Kotlin。我之前也算见过的一堆计算机语言，但是只有 Kotlin，能够让我在那么短的时间内重写我的游戏服务器代码。而我现在则是在用 Kotlin 重写我之前写过的一切。 我也知道还有好多其他的程序员也对 Kotlin 感觉非常好，打算成为 Kotlin 程序员。其中大部分的人应该在 1-2 年之内水平就能超过我了。我们私下里谈论过，互相都说“Kotlin 让编程感觉美好的感觉又回来了。”还不错，再我们尚未对编程全部失去兴趣之前，Kotlin 来了。就仿佛你只要把语言的语法学会了。这回把你带回到那种第一次学编程的感觉，无论写什么都觉得自己很牛逼。 再一次，向 JetBrains 致敬。他们对计算机语言做出了巨大的贡献！我脱帽致敬。 那么 Kotlin 比你用的任何其他编程语言都好吗？我想对我来说是的。因为，如果你碰巧是在用 Java 的话。如果你一整天就是泡在椅子面前写 Java，那么你会发现 Kotlin 简直就是一股清流。所以也让我知道你们是怎么想的吧。 免责声明：本文只是阐述Steve Yegge对 Android 开发的观点，并不代表Google或者 JetBrains 的观点。]]></content>
      <tags>
        <tag>Kotlin</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[c指针详解]]></title>
    <url>%2F2017%2F11%2Fc%E6%8C%87%E9%92%88%E8%AF%A6%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[前言:复杂类型说明​ 要了解指针,多多少少会出现一些比较复杂的类型, 所以我先介绍一下如何完全理解一个复杂类型,要理解复杂类型其实很简单,一个类型里会出现很多运算符,他们也像普通的表达式一样,有优先级,其优先级和运算优先级一样,所以我总结了一下其原则:从变量名处起,根据运算符优先级结合,一步一步分析.下面让我们先从简单的类型开始慢慢分析吧: 123456789int p; //这是一个普通的整型变量int *p; //首先从P 处开始,先与*结合,所以说明P 是一个指针,然后再与int 结合,说明指针所指向的内容的类型为int 型.所以P是一个返回整型数据的指针int p[3]; //首先从P 处开始,先与[]结合,说明P 是一个数组,然后与int 结合,说明数组里的元素是整型的,所以P 是一个由整型数据组成的数组int *p[3]; //首先从P 处开始,先与[]结合,因为其优先级比*高,所以P 是一个数组,然后再与*结合,说明数组里的元素是指针类型,然后再与int 结合,说明指针所指向的内容的类型是整型的,所以P 是一个由返回整型数据的指针所组成的数组int (*p)[3]; //首先从P 处开始,先与*结合,说明P 是一个指针然后再与[]结合(与"()"这步可以忽略,只是为了改变优先级),说明指针所指向的内容是一个数组,然后再与int 结合,说明数组里的元素是整型的.所以P 是一个指向由整型数据组成的数组的指针int **p; //首先从P 开始,先与*结合,说是P 是一个指针,然后再与*结合,说明指针所指向的元素是指针,然后再与int 结合,说明该指针所指向的元素是整型数据.由于二级指针以及更高级的指针极少用在复杂的类型中,所以后面更复杂的类型我们就不考虑多级指针了,最多只考虑一级指针.int p(int); //从P 处起,先与()结合,说明P 是一个函数,然后进入()里分析,说明该函数有一个整型变量的参数,然后再与外面的int 结合,说明函数的返回值是一个整型数据Int (*p)(int); //从P 处开始,先与指针结合,说明P 是一个指针,然后与()结合,说明指针指向的是一个函数,然后再与()里的int 结合,说明函数有一个int 型的参数,再与最外层的int 结合,说明函数的返回类型是整型,所以P 是一个指向有一个整型参数且返回类型为整型的函数的指针int *(*p(int))[3]; //可以先跳过,不看这个类型,过于复杂从P 开始,先与()结合,说明P 是一个函数,然后进入()里面,与int 结合,说明函数有一个整型变量参数,然后再与外面的*结合,说明函数返回的是一个指针,,然后到最外面一层,先与[]结合,说明返回的指针指向的是一个数组,然后再与*结合,说明数组里的元素是指针,然后再与int 结合,说明指针指向的内容是整型数据.所以P 是一个参数为一个整数据且返回一个指向由整型指针变量组成的数组的指针变量的函数. 说到这里也就差不多了,我们的任务也就这么多,理解了这几个类型,其它的类型对我们来说也是小菜了,不过我们一般不会用太复杂的类型,那样会大大减小程序的可读性,请慎用,这上面的几种类型已经足够我们用了. 一、细说指针指针是一个特殊的变量，它里面存储的数值被解释成为内存里的一个地址。要搞清一个指针需要搞清指针的四方面的内容：指针的类型、指针所指向的类型、指针的值或者叫指针所指向的内存区、指针本身所占据的内存区。让我们分别说明。 先声明几个指针放着做例子： 例一： 12345(1)int*ptr;(2)char*ptr;(3)int**ptr;(4)int(*ptr)[3];(5)int*(*ptr)[4]; 1.指针的类型从语法的角度看，你只要把指针声明语句里的指针名字去掉，剩下的部分就是这个指针的类型。这是指针本身所具有的类型。让我们看看例一中各个指针的类型： (1)intptr;//指针的类型是int (2)charptr;//指针的类型是char (3)intptr;//指针的类型是int (4)int(ptr)[3];//指针的类型是int()[3] (5)int(ptr)[4];//指针的类型是int()[4] 怎么样？找出指针的类型的方法是不是很简单？ 2.指针所指向的类型当你通过指针来访问指针所指向的内存区时，指针所指向的类型决定了编译器将把那片内存区里的内容当做什么来看待。 从语法上看，你只须把指针声明语句中的指针名字和名字左边的指针声明符*去掉，剩下的就是指针所指向的类型。例如： (1)int*ptr; //指针所指向的类型是int (2)char*ptr; //指针所指向的的类型是char (3)int*ptr; //指针所指向的的类型是int (4)int(*ptr)[3]; //指针所指向的的类型是int()[3] (5)int(ptr)[4]; //指针所指向的的类型是int*()[4] 在指针的算术运算中，指针所指向的类型有很大的作用。 指针的类型(即指针本身的类型)和指针所指向的类型是两个概念。当你对C 越来越熟悉时，你会发现，把与指针搅和在一起的”类型”这个概念分成”指针的类型”和”指针所指向的类型”两个概念，是精通指针的关键点之一。我看了不少书，发现有些写得差的书中，就把指针的这两个概念搅在一起了，所以看起书来前后矛盾，越看越糊涂。 3.指针的值—-或者叫指针所指向的内存区或地址指针的值是指针本身存储的数值，这个值将被编译器当作一个地址，而不是一个一般的数值。在32 位程序里，所有类型的指针的值都是一个32 位整数，因为32 位程序里内存地址全都是32 位长。指针所指向的内存区就是从指针的值所代表的那个内存地址开始，长度为si zeof(指针所指向的类型)的一片内存区。以后，我们说一个指针的值是XX，就相当于说该指针指向了以XX 为首地址的一片内存区域；我们说一个指针指向了某块内存区域，就相当于说该指针的值是这块内存区域的首地址。指针所指向的内存区和指针所指向的类型是两个完全不同的概念。在例一中，指针所指向的类型已经有了，但由于指针还未初始化，所以它所指向的内存区是不存在的，或者说是无意义的。 以后，每遇到一个指针，都应该问问：这个指针的类型是什么？指针指的类型是什么？该指针指向了哪里？（重点注意） 4 指针本身所占据的内存区指针本身占了多大的内存？你只要用函数sizeof(指针的类型)测一下就知道了。在32 位平台里，指针本身占据了4 个字节的长度。指针本身占据的内存这个概念在判断一个指针表达式（后面会解释）是否是左值时很有用。 二、指针的算术运算指针可以加上或减去一个整数。指针的这种运算的意义和通常的数值的加减运算的意义是不一样的，以单元为单位。例如： 例二： 123char a[20];int *ptr=(int *)a; //强制类型转换并不会改变a 的类型ptr++; 在上例中，指针ptr 的类型是int*,它指向的类型是int，它被初始化为指向整型变量a。接下来的第3句中，指针ptr被加了1，编译器是这样处理的：它把指针ptr 的值加上了sizeof(int)，在32 位程序中，是被加上了4，因为在32 位程序中，int 占4 个字节。由于地址是用字节做单位的，故ptr 所指向的地址由原来的变量a 的地址向高地址方向增加了4 个字节。由于char 类型的长度是一个字节，所以，原来ptr 是指向数组a 的第0 号单元开始的四个字节，此时指向了数组a 中从第4 号单元开始的四个字节。我们可以用一个指针和一个循环来遍历一个数组，看例子： 例三： 1234567int array[20]=&#123;0&#125;;int *ptr=array;for(i=0;i&lt;20;i++)&#123; (*ptr)++; ptr++；&#125; 这个例子将整型数组中各个单元的值加1。由于每次循环都将指针ptr加1 个单元，所以每次循环都能访问数组的下一个单元。 再看例子： 例四： 123char a[20]="You_are_a_girl";int *ptr=(int *)a;ptr+=5; 在这个例子中，ptr 被加上了5，编译器是这样处理的：将指针ptr 的值加上5 乘sizeof(int)，在32 位程序中就是加上了5 乘4=20。由于地址的单位是字节，故现在的ptr 所指向的地址比起加5 后的ptr 所指向的地址来说，向高地址方向移动了20 个字节。在这个例子中，没加5 前的ptr 指向数组a 的第0 号单元开始的四个字节，加5 后，ptr 已经指向了数组a 的合法范围之外了。虽然这种情况在应用上会出问题，但在语法上却是可以的。这也体现出了指针的灵活性。如果上例中，ptr 是被减去5，那么处理过程大同小异，只不过ptr 的值是被减去5 乘sizeof(int)，新的ptr 指向的地址将比原来的ptr 所指向的地址向低地址方向移动了20 个字节。下面请允许我再举一个例子:(一个误区) 例五: 123456789101112131415#include&lt;stdio.h&gt;int main()&#123; char a[20]=" You_are_a_girl"; char *p=a; char **ptr=&amp;p; //printf("p=%d\n",p); //printf("ptr=%d\n",ptr); //printf("*ptr=%d\n",*ptr); printf("**ptr=%c\n",**ptr); ptr++; //printf("ptr=%d\n",ptr); //printf("*ptr=%d\n",*ptr); printf("**ptr=%c\n",**ptr);&#125; 误区一、输出答案为Y 和o误解:ptr 是一个char 的二级指针,当执行ptr++;时,会使指针加一个sizeof(char),所以输出如上结果,这个可能只是少部分人的结果.误区二、输出答案为Y 和a误解:ptr 指向的是一个char 类型,当执行ptr++;时,会使指针加一个sizeof(char )(有可能会有人认为这个值为1,那就会得到误区一的答案,这个值应该是4,参考前面内容), 即&amp;p+4; 那进行一次取值运算不就指向数组中的第五个元素了吗?那输出的结果不就是数组中第五个元素了吗?答案是否定的.正解: ptr 的类型是char ,指向的类型是一个char 类型,该指向的地址就是p的地址(&amp;p),当执行ptr++;时,会使指针加一个sizeof(char),即&amp;p+4;那*(&amp;p+4)指向哪呢,这个你去问上帝吧,或者他会告诉你在哪?所以最后的输出会是一个随机的值,或许是一个非法操作. 总结一下:**一个指针ptrold 加(减)一个整数n 后，结果是一个新的指针ptrnew，ptrnew 的类型和ptrold 的类型相同，ptrnew 所指向的类型和ptrold所指向的类型也相同。ptrnew 的值将比ptrold 的值增加(减少)了n 乘sizeof(ptrold 所指向的类型)个字节。就是说，ptrnew 所指向的内存区将比ptrold 所指向的内存区向高(低)地址方向移动了n 乘sizeof(ptrold 所指向的类型)个字节。指针和指针进行加减：两个指针不能进行加法运算，这是非法操作，因为进行加法后，得到的结果指向一个不知所向的地方，而且毫无意义。两个指针可以进行减法操作，但必须类型相同，一般用在数组方面，不多说了。 三、运算符&amp;和*这里&amp;是取地址运算符，*是间接运算符。 &amp;a 的运算结果是一个指针，指针的类型是a 的类型加个*，指针所指向的类型是a 的类型，指针所指向的地址嘛，那就是a 的地址。 p 的运算结果就五花八门了。总之p 的结果是p 所指向的东西，这个东西有这些特点：它的类型是p 指向的类型，它所占用的地址是p所指向的地址。 例六： 12345678910111213int a=12; int b; int *p; int **ptr;p=&amp;a; //&amp;a 的结果是一个指针，类型是int*，指向的类型是//int，指向的地址是a 的地址。*p=24; //*p 的结果，在这里它的类型是int，它所占用的地址是//p 所指向的地址，显然，*p 就是变量a。ptr=&amp;p; //&amp;p 的结果是个指针，该指针的类型是p 的类型加个*，//在这里是int **。该指针所指向的类型是p 的类型，这//里是int*。该指针所指向的地址就是指针p 自己的地址。*ptr=&amp;b; //*ptr 是个指针，&amp;b 的结果也是个指针，且这两个指针//的类型和所指向的类型是一样的，所以用&amp;b 来给*ptr 赋//值就是毫无问题的了。**ptr=34; //*ptr 的结果是ptr 所指向的东西，在这里是一个指针，//对这个指针再做一次*运算，结果是一个int 类型的变量。 四、指针表达式一个表达式的结果如果是一个指针，那么这个表达式就叫指针表式。 下面是一些指针表达式的例子： 例七： 12345678int a,b;int array[10];int *pa;pa=&amp;a; //&amp;a 是一个指针表达式。Int **ptr=&amp;pa; //&amp;pa 也是一个指针表达式。*ptr=&amp;b; //*ptr 和&amp;b 都是指针表达式。pa=array;pa++; //这也是指针表达式。 例八： 123456char *arr[20];char **parr=arr; //如果把arr 看作指针的话，arr 也是指针表达式char *str;str=*parr; //*parr 是指针表达式str=*(parr+1); //*(parr+1)是指针表达式str=*(parr+2); //*(parr+2)是指针表达式 由于指针表达式的结果是一个指针，所以指针表达式也具有指针所具有的四个要素：指针的类型，指针所指向的类型，指针指向的内存区，指针自身占据的内存。好了，当一个指针表达式的结果指针已经明确地具有了指针自身占据的内存的话，这个指针表达式就是一个左值，否则就不是一个左值。在例七中，&amp;a 不是一个左值，因为它还没有占据明确的内存。ptr 是一个左值，因为ptr 这个指针已经占据了内存，其实ptr 就是指针pa，既然pa 已经在内存中有了自己的位置，那么ptr 当然也有了自己的位置。 五、数组和指针的关系数组的数组名其实可以看作一个指针。看下例： 例九： 1234int array[10]=&#123;0,1,2,3,4,5,6,7,8,9&#125;,value;value=array[0]; //也可写成：value=*array;value=array[3]; //也可写成：value=*(array+3);value=array[4]; //也可写成：value=*(array+4); 上例中，一般而言数组名array 代表数组本身，类型是int[10]，但如果把array 看做指针的话，它指向数组的第0 个单元，类型是int 所指向的类型是数组单元的类型即int。因此array 等于0 就一点也不奇怪了。同理，array+3 是一个指向数组第3 个单元的指针，所以(array+3)等于3。其它依此类推。*例十： 123456789char *str[3]=&#123; "Hello,thisisasample!", "Hi,goodmorning.", "Helloworld"&#125;;char s[80]；strcpy(s,str[0]); //也可写成strcpy(s,*str);strcpy(s,str[1]); //也可写成strcpy(s,*(str+1));strcpy(s,str[2]); //也可写成strcpy(s,*(str+2)); 上例中，str 是一个三单元的数组，该数组的每个单元都是一个指针，这些指针各指向一个字符串。把指针数组名str 当作一个指针的话，它指向数组的第0 号单元，它的类型是char ，它指向的类型是char 。 str 也是一个指针，它的类型是char *，它所指向的类型是char，它指向的地址是字符串”Hello,thisisasample!”的第一个字符的地址，即’H’的地址。注意:字符串相当于是一个数组,在内存中以数组的形式储存,只不过字符串是一个数组常量,内容不可改变,且只能是右值.如果看成指针的话,他即是常量指针,也是指针常量.str+1 也是一个指针，它指向数组的第1 号单元，它的类型是char，它指向的类型是char。 (str+1)也是一个指针，它的类型是char*，它所指向的类型是char，它指向”Hi,goodmorning.”的第一个字符’H’ 下面总结一下数组的数组名(数组中储存的也是数组)的问题:声明了一个数组TYPE array[n]，则数组名称array 就有了两重含义：第一，它代表整个数组，它的类型是TYPE[n]；第二，它是一个常量指针，该指针的类型是TYPE，该指针指向的类型是TYPE，也就是数组单元的类型，该指针指向的内存区就是数组第0 号单元，该指针自己占有单独的内存区，注意它和数组第0 号单元占据的内存区是不同的。该指针的值是不能修改的，即类似array++的表达式是错误的。在不同的表达式中数组名array 可以扮演不同的角色。在表达式sizeof(array)中，数组名array 代表数组本身，故这时sizeof 函数测出的是整个数组的大小。在表达式array 中，array 扮演的是指针，因此这个表达式的结果就是数组第0 号单元的值。sizeof(array)测出的是数组单元的大小。表达式array+n（其中n=0，1，2，…..）中，array 扮演的是指针，故array+n 的结果是一个指针，它的类型是TYPE ，它指向的类型是TYPE，它指向数组第n号单元。故sizeof(array+n)测出的是指针类型的大小。在32 位程序中结果是4例十一: 123int array[10];int (*ptr)[10];ptr=&amp;array;： 上例中ptr 是一个指针，它的类型是int()[10]，他指向的类型是int[10] ，我们用整个数组的首地址来初始化它。在语句ptr=&amp;array中，array 代表数组本身。本节中提到了函数sizeof()，那么我来问一问，sizeof(指针名称)测出的究竟是指针自身类型的大小呢还是指针所指向的类型的大小？答案是前者。例如：int(ptr)[10];则在32 位程序中，有：sizeof(int(*)[10])==4sizeof(int[10])==40sizeof(ptr)==4实际上，sizeof(对象)测出的都是对象自身的类型的大小，而不是别的什么类型的大小。 六、指针和结构类型的关系可以声明一个指向结构类型对象的指针。 例十二： 1234567891011121314struct MyStruct&#123; int a; int b; int c;&#125;;struct MyStruct ss=&#123;20,30,40&#125;;//声明了结构对象ss，并把ss 的成员初始化为20，30 和40。struct MyStruct *ptr=&amp;ss;//声明了一个指向结构对象ss 的指针。它的类型是//MyStruct *,它指向的类型是MyStruct。int *pstr=(int*)&amp;ss;//声明了一个指向结构对象ss 的指针。但是pstr 和//它被指向的类型ptr 是不同的。 请问怎样通过指针ptr 来访问ss 的三个成员变量？答案： ptr-&gt;a; //指向运算符，或者可以这们(*ptr).a,建议使用前者 ptr-&gt;b; ptr-&gt;c; 又请问怎样通过指针pstr 来访问ss 的三个成员变量？答案： *pstr； //访问了ss 的成员a。 *(pstr+1); //访问了ss 的成员b。 *(pstr+2) //访问了ss 的成员c。 虽然我在我的MSVC++6.0 上调式过上述代码，但是要知道，这样使用pstr 来访问结构成员是不正规的，为了说明为什么不正规，让我们看看怎样通过指针来访问数组的各个单元: (将结构体换成数组) 例十三： 123456int array[3]=&#123;35,56,37&#125;;int *pa=array;//通过指针pa 访问数组array 的三个单元的方法是：*pa; //访问了第0 号单元*(pa+1); //访问了第1 号单元*(pa+2); //访问了第2 号单元 从格式上看倒是与通过指针访问结构成员的不正规方法的格式一样。所有的C/C++编译器在排列数组的单元时，总是把各个数组单元存放在连续的存储区里，单元和单元之间没有空隙。但在存放结构对象的各个成员时，在某种编译环境下，可能会需要字对齐或双字对齐或者是别的什么对齐，需要在相邻两个成员之间加若干个”填充字节”，这就导致各个成员之间可能会有若干个字节的空隙。所以，在例十二中，即使pstr 访问到了结构对象ss 的第一个成员变量a，也不能保证(pstr+1)就一定能访问到结构成员b。因为成员a 和成员b 之间可能会有若干填充字节，说不定*(pstr+1)就正好访问到了这些填充字节呢。这也证明了指针的灵活性。要是你的目的就是想看看各个结构成员之间到底有没有填充字节，嘿，这倒是个不错的方法。不过指针访问结构成员的正确方法应该是象例十二中使用指针ptr 的方法。 七、指针和函数的关系可以把一个指针声明成为一个指向函数的指针。 int fun1(char *,int); int (pfun1)(char ,int); pfun1=fun1; int a=(*pfun1)(“abcdefg”,7); //通过函数指针调用函数。 可以把指针作为函数的形参。在函数调用语句中，可以用指针表达式来作为实参。 例十四： 12345678910111213int fun(char *);inta;char str[]="abcdefghijklmn";a=fun(str);int fun(char *s)&#123; int num=0; for(int i=0;;) &#123; num+=*s;s++; &#125; return num;&#125; 这个例子中的函数fun 统计一个字符串中各个字符的ASCII 码值之和。前面说了，数组的名字也是一个指针。在函数调用中，当把str作为实参传递给形参s 后，实际是把str 的值传递给了s，s 所指向的地址就和str 所指向的地址一致，但是str 和s 各自占用各自的存储空间。在函数体内对s 进行自加1 运算，并不意味着同时对str 进行了自加1 运算。 八、指针类型转换当我们初始化一个指针或给一个指针赋值时，赋值号的左边是一个指针，赋值号的右边是一个指针表达式。在我们前面所举的例子中，绝大多数情况下，指针的类型和指针表达式的类型是一样的，指针所指向的类型和指针表达式所指向的类型是一样的。 例十五： 123float f=12.3;float *fptr=&amp;f;int *p; 在上面的例子中，假如我们想让指针p 指向实数f，应该怎么办？是用下面的语句吗？p=&f;不对。因为指针p 的类型是int ，它指向的类型是int。表达式&amp;f 的结果是一个指针，指针的类型是float ,它指向的类型是float。两者不一致，直接赋值的方法是不行的。至少在我的MSVC++6.0 上，对指针的赋值语句要求赋值号两边的类型一致，所指向的类型也一致，其它的编译器上我没试过，大家可以试试。为了实现我们的目的，需要进行”强制类型转换”：p=(int)&f;如果有一个指针p，我们需要把它的类型和所指向的类型改为TYEP TYPE， 那么语法格式是： (TYPE )p；这样强制类型转换的结果是一个新指针，该新指针的类型是TYPE ，它指向的类型是TYPE，它指向的地址就是原指针指向的地址。而原来的指针p 的一切属性都没有被修改。（切记）一个函数如果使用了指针作为形参，那么在函数调用语句的实参和形参的结合过程中，必须保证类型一致，否则需要强制转换例十六： 123456789void fun(char*);int a=125,b;fun((char*)&amp;a);void fun(char*s)&#123; charc; c=*(s+3);*(s+3)=*(s+0);*(s+0)=c; c=*(s+2);*(s+2)=*(s+1);*(s+1)=c;&#125; 注意这是一个32 位程序，故int 类型占了四个字节，char 类型占一个字节。函数fun 的作用是把一个整数的四个字节的顺序来个颠倒。注意到了吗？在函数调用语句中，实参&amp;a 的结果是一个指针，它的类型是int ，它指向的类型是int。形参这个指针的类型是char ，它指向的类型是char。这样，在实参和形参的结合过程中，我们必须进行一次从int 类型到char 类型的转换。结合这个例子，我们可以这样来想象编译器进行转换的过程：编译器先构造一个临时指针char temp，然后执行temp=(char )&amp;a，最后再把temp 的值传递给s。所以最后的结果是：s 的类型是char *,它指向的类型是char，它指向的地址就是a 的首地址。我们已经知道，指针的值就是指针指向的地址，在32 位程序中，指针的值其实是一个32 位整数。那可不可以把一个整数当作指针的值直接赋给指针呢？就象下面的语句： 1234567891011unsigned int a;TYPE *ptr; //TYPE 是int，char 或结构类型等等类型。a=20345686;ptr=20345686; //我们的目的是要使指针ptr 指向地址20345686ptr=a; //我们的目的是要使指针ptr 指向地址20345686//编译一下吧。结果发现后面两条语句全是错的。那么我们的目的就不能达到了吗？不，还有办法：unsigned int a;TYPE *ptr; //TYPE 是int，char 或结构类型等等类型。a=N //N 必须代表一个合法的地址；ptr=(TYPE*)a； //这就可以了。 严格说来这里的(TYPE )和指针类型转换中的(TYPE )还不一样。这里的(TYPE*)的意思是把无符号整数a 的值当作一个地址来看待。上面强调了a 的值必须代表一个合法的地址，否则的话，在你使用ptr 的时候，就会出现非法操作错误。想想能不能反过来，把指针指向的地址即指针的值当作一个整数取出来。完全可以。下面的例子演示了把一个指针的值当作一个整数取出来，然后再把这个整数当作一个地址赋给一个指针： 例十七： 12345int a=123,b;int *ptr=&amp;a;char *str;b=(int)ptr; //把指针ptr 的值当作一个整数取出来。str=(char*)b; //把这个整数的值当作一个地址赋给指针str。 现在我们已经知道了，可以把指针的值当作一个整数取出来，也可以把一个整数值当作地址赋给一个指针。 九、指针的安全问题看下面的例子： 例十八： 1234char s='a';int *ptr;ptr=(int *)&amp;s;*ptr=1298； 指针ptr 是一个int 类型的指针，它指向的类型是int。它指向的地址就是s 的首地址。在32 位程序中，s 占一个字节，int 类型占四个字节。最后一条语句不但改变了s 所占的一个字节，还把和s 相临的高地址方向的三个字节也改变了。这三个字节是干什么的？只有编译程序知道，而写程序的人是不太可能知道的。也许这三个字节里存储了非常重要的数据，也许这三个字节里正好是程序的一条代码，而由于你对指针的马虎应用，这三个字节的值被改变了！这会造成崩溃性的错误。让我们再来看一例：*例十九： 1234char a;int *ptr=&amp;a;ptr++;*ptr=115; 该例子完全可以通过编译，并能执行。但是看到没有？第3 句对指针ptr 进行自加1 运算后，ptr 指向了和整形变量a 相邻的高地址方向的一块存储区。这块存储区里是什么？我们不知道。有可能它是一个非常重要的数据，甚至可能是一条代码。而第4 句竟然往这片存储区里写入一个数据！这是严重的错误。所以在使用指针时，程序员心里必须非常清楚：我的指针究竟指向了哪里。在用指针访问数组的时候，也要注意不要超出数组的低端和高端界限，否则也会造成类似的错误。在指针的强制类型转换：ptr1=(TYPE *)ptr2 中，如果sizeof(ptr2的类型)大于sizeof(ptr1 的类型)，那么在使用指针ptr1 来访问ptr2所指向的存储区时是安全的。如果sizeof(ptr2 的类型) 小于sizeof(ptr1 的类型)，那么在使用指针ptr1 来访问ptr2 所指向的存储区时是不安全的。至于为什么，结合例十八来想一想，应该会明白的。]]></content>
      <tags>
        <tag>c语言</tag>
        <tag>c语言语法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C89标准和C99标准C11标准的区别（简单总结版&&较为完整版）]]></title>
    <url>%2F2017%2F11%2FC89%E6%A0%87%E5%87%86%E5%92%8CC99%E6%A0%87%E5%87%86C11%E6%A0%87%E5%87%86%E7%9A%84%E5%8C%BA%E5%88%AB%2F</url>
    <content type="text"><![CDATA[较详细的阐述了c89/c99/c11的一些变化 ###较简单的总结 （1）对数组的增强 ​ 可变长数组 C99中,程序员声明数组时,数组的维数可以由任一有效的整型表达式确定,包括只在运行时才能确定其值的表达式,这类数组就叫做可变长数组,但是只有局部数组才可以是变长的.可变长数组的维数在数组生存期内是不变的,也就是说,可变长数组不是动态的.可以变化的只是数组的大小.可以使用*来定义不确定长的可变长数组。 ​ 数组声明中的类型修饰符 在C99中，如果需要使用数组作为函数变元，可以在数组声明的方括号内使用static关键字，这相当于告诉编译程序，变元所指向的数组将至少包含指定的元素个数。也可以在数组声明的方括号内使用restrict,volatile,const关键字，但只用于函数变元。如果使用restrict，指针是初始访问该对象的惟一途径。如果使用const，指针始终指向同一个数组。使用volatile没有任何意义。 （2）单行注释 引入了单行注释标记 “//“ , 可以象C++一样使用这种注释了。 （3）分散代码与声明 预处理程序的修改 （4）for语句内的变量声明 C99中，程序员可以在for语句的初始化部分定义一个或多个变量，这些变量的作用域仅于本for语句所控制的循环体内。比如：代码:for(int i=0; i&lt;10; i++){ // do someting …} （5）复合赋值 C99中，复合赋值中，可以指定对象类型的数组、结构或联合表达式。当使用复合赋值时，应在括弧内指定类型，后跟由花括号围起来的初始化列表；若类型为数组，则不能指定数组的大小。建成的对象是未命名的。 例： double *fp = (double[]) {1.1, 2.2, 3.3}; 该语句用于建立一个指向double的指针fp，且该指针指向这个3元素数组的第一个元素。 在文件域内建立的复合赋值只在程序的整个生存期内有效。在模块内建立的复合赋值是局部对象，在退出模块后不再存在。 (6)指定的初始化符 C99中，该特性对经常使用稀疏数组的程序员十分有用。指定的初始化符通常有两种用法：用于数组，以及用于结构和联合。用于数组的格式：[index] = vol; 其中，index表示数组的下标，vol表示本数组元素的初始化值。 例如： int x[10] = {[0] = 10, [5] = 30}; 其中只有x[0]和x[5]得到了初始化．用于结构或联合的格式如下： member-name(成员名称) 对结构进行指定的初始化时，允许采用简单的方法对结构中的指定成员进行初始化。 例如： struct example{ int k, m, n; } object = {m = 10,n = 200}; 其中，没有初始化k。对结构成员进行初始化的顺序没有限制 (7)printf()和scanf()函数系列的增强 C99中printf()和scanf()函数系列引进了处理long long int和unsigned long long int数据类型的特性。long long int 类型的格式修饰符是ll。在printf()和scanf()函数中，ll适用于d, i, o, u 和x格式说明符。另外，C99还引进了hh修饰符。当使用d, i, o, u和x格式说明符时，hh用于指定char型变元。ll和hh修饰符均可以用于n说明符。 格式修饰符a和A用在printf()函数中时，结果将会输出十六进制的浮点数。 格式如下：[-]0xh, hhhhp + d 使用A格式修饰符时，x和p必须是大写。A和a格式修饰符也可以用在scanf()函数中，用于读取浮点数。调用printf()函数时，允许在%f说明符前加上l修饰符，即%lf，但不起作用。 (8)C99新增的库 C89中标准的头文件 定义宏assert() 字符处理 错误报告 定义与实现相关的浮点值勤 定义与实现相关的各种极限值 支持函数setlocale() 数学函数库使用的各种定义 支持非局部跳转 定义信号值 支持可变长度的变元列表 定义常用常数 支持文件输入和输出 其他各种声明 支持串函数 支持系统时间函数 C99新增的头文件和库 支持复数算法 给出对浮点状态标记和浮点环境的其他方面的访问 定义标准的、可移植的整型类型集合。也支持处理最大宽度整数的函数 首先在此1995年第一次修订时引进，用于定义对应各种运算符的宏 支持布尔数据类型类型。定义宏bool，以便兼容于C++ 定义标准的、可移植的整型类型集合。该文件包含在中 定义一般类型的浮点宏 首先在1995年第一次修订时引进，用于支持多字节和宽字节函数 首先在1995年第一次修订时引进，用于支持多字节和宽字节分类函数** (10)func预定义标识符 用于指出func所存放的函数名，类似于字符串赋值。** (11) 其它特性的改动 放宽的转换限制 限制 C89标准 C99标准 数据块的嵌套层数 15 127 条件语句的嵌套层数 8 63 内部标识符中的有效字符个数 31 63 外部标识符中的有效字符个数 6 31 结构或联合中的成员个数 127 1023 函数调用中的参数个数 31 127 不再支持隐含式的int规则 删除了隐含式函数声明 对返回值的约束 C99中,非空类型函数必须使用带返回值的return语句. 扩展的整数类型 扩展类型 含义 int16_t 整数长度为精确16位 int_least16_t 整数长度为至少16位 int_fast32_t 最稳固的整数类型,其长度为至少32位 intmax_t 最大整数类型 uintmax_t 最大无符号整数类型 对整数类型提升规则的改进 C89中,表达式中类型为char,short int或int的值可以提升为int或unsigned int类型. C99中,每种整数类型都有一个级别.例如:long long int 的级别高于int, int的级别高于char等.在表达式中,其级别低于int或unsigned int的任何整数类型均可被替换成int或unsigned int类型. (12)新增数据类型 _Bool 值是0或1。C99中增加了用来定义bool、true以及false宏的头文件夹，以便程序员能够编写同时兼容于C与C++的应用程序。在编写新的应用程序时，应该使用头文件中的bool宏。 _Complex and _Imaginary C99标准中定义的复数类型如下：float_Complex; float_Imaginary; double_Complex; double_Imaginary; long double_Complex; long double_Imaginary.头文件中定义了complex和imaginary宏,并将它们扩展为_Complex和_Imaginary,因此在编写新的应用程序时,应该使用头文件中的complex和imaginary宏。 long long int C99标准中引进了long long int（-(2e63 - 1)至2e63 - 1）和unsigned long long int（0 - 2e64 - 1）。long long int能够支持的整数长度为64位。 较完整的阐述C99对C89的改变 1、增加restrict指针 C99中增加了公适用于指针的restrict类型修饰符，它是初始访问指针所指对象的惟一途径，因此只有借助restrict指针表达式才能访问对象。restrict指针指针主要用做函数变元，或者指向由malloc()函数所分配的内存变量。restrict数据类型不改变程序的语义。 如果某个函数定义了两个restrict指针变元，编译程序就假定它们指向两个不同的对象，memcpy()函数就是restrict指针的一个典型应用示例。C89中memcpy()函数原型如下： 代码: void memcpy (void s1, const void *s2, size_t size); 如果s1和s2所指向的对象重叠，其操作就是未定义的。memcpy()函数只能用于不重叠的对象。C99中memcpy()函数原型如下： 代码: void memcpy(void restrict s1, const void *restrict s2,size_t size); 通过使用restrict修饰s1和s2 变元，可确保它们在该原型中指向不同的对象。 2、inline（内联）关键字 内联函数除了保持结构化和函数式的定义方式外,还能使程序员写出高效率的代码.函数的每次调用与返回都会消耗相当大的系统资源,尤其是当函数调用发生在重复次数很多的循环语句中时.一般情况下,当发生一次函数调用时,变元需要进栈,各种寄存器内存需要保存.当函数返回时,寄存器的内容需要恢复。如果该函数在代码内进行联机扩展，当代码执行时，这些保存和恢复操作旅游活动会再发生，而且函数调用的执行速度也会大大加快。函数的联机扩展会产生较长的代码，所以只应该内联对应用程序性能有显著影响的函数以及长度较短的函数。 3、新增数据类型 _Bool 值是0或1。C99中增加了用来定义bool、true以及false宏的头文件夹，以便程序员能够编写同时兼容于C与C++的应用程序。在编写新的应用程序时，应该使用 头文件中的bool宏。 _Complex and _Imaginary C99标准中定义的复数类型如下：float_Complex; float_Imaginary; double_Complex;double_Imaginary; long double_Complex; long double_Imaginary. 头文件中定义了complex和imaginary宏,并将它们扩展为_Complex和_Imaginary,因此在编写新的应用程序时,应该使用头文件中的complex和imaginary宏。 long long int C99标准中引进了long long int（-(2e63 - 1)至2e63 - 1）和unsigned long long int（0 - 2e64- 1）。long long int能够支持的整数长度为64位。 4、对数组的增强 可变长数组 C99中,程序员声明数组时,数组的维数可以由任一有效的整型表达式确定,包括只在运行时才能确定其值的表达式,这类数组就叫做可变长数组,但是只有局部数组才可以是变长的.可变长数组的维数在数组生存期内是不变的,也就是说,可变长数组不是动态的.可以变化的只是数组的大小.可以使用*来定义不确定长的可变长数组。 数组声明中的类型修饰符 在C99中，如果需要使用数组作为函数变元，可以在数组声明的方括号内使用static关键字，这相当于告诉编译程序，变元所指向的数组将至少包含指定的元素个数。也可以在数组声明的方括号内使用restrict,volatile,const关键字，但只用于函数变元。如果使用restrict，指针是初始访问该对象的惟一途径。如果使用const，指针始终指向同一个数组。使用volatile没有任何意义。 5、单行注释 引入了单行注释标记 “//“ , 可以象C++一样使用这种注释了。 6、分散代码与声明 7、预处理程序的修改 ａ、变元列表 宏可以带变元，在宏定义中用省略号（…）表示。内部预处理标识符VA_ARGS决定变元将在何处得到替换。例：#define MySum(…) sum(VA_ARGS) 语句MySum(k,m,n);将被转换成：sum(k, m, n); 变元还可以包含变元。例： #define compare(compf, …)compf(VA_ARGS) 其中的compare(strcmp,”small”, “large”); 将替换成：strcmp(“small”,”large”); ｂ、_Pragma运算符 C99引入了在程序中定义编译指令的另外一种方法：_Pragma运算符。格式如下： _Pragma(“directive”) 其中directive是要满打满算的编译指令。_Pragma运算符允许编译指令参与宏替换。 ｃ、内部编译指令 STDCFP_CONTRACT ON/OFF/DEFAULT 若为ON，浮点表达式被当做基于硬件方式处理的独立单元。默认值是定义的工具。 STDCFEVN_ACCESS ON/OFF/DEFAULT 告诉编译程序可以访问浮点环境。默认值是定义的工具。 STDC CX_LIMITED_RANGE ON/OFF/DEFAULT 若值为ON，相当于告诉编译程序某程序某些含有复数的公式是可靠的。默认是OFF。 ｄ、新增的内部宏 STDC_HOSTED 若操作系统存在，则为1 STDC_VERSION 199991L或更高。代表C的版本 STDC_IEC_599 若支持IEC 60559浮点运算，则为1 STDC_IEC_599_COMPLEX 若支持IEC 60599复数运算，则为1 STDC_ISO_10646 由编译程序支持，用于说明ISO/IEC 10646标准的年和月格式：yyymmmL 8、for语句内的变量声明 C99中，程序员可以在for语句的初始化部分定义一个或多个变量，这些变量的作用域仅于本for语句所控制的循环体内。比如： 代码:for(int i=0; i&lt;10; i++){​ // do someting …} 9、复合赋值 C99中，复合赋值中，可以指定对象类型的数组、结构或联合表达式。当使用复合赋值时，应在括弧内指定类型，后跟由花括号围起来的初始化列表；若类型为数组，则不能指定数组的大小。建成的对象是未命名的。 例： double *fp = (double[]) {1.1, 2.2, 3.3}; 该语句用于建立一个指向double的指针fp，且该指针指向这个3元素数组的第一个元素。 在文件域内建立的复合赋值只在程序的整个生存期内有效。在模块内建立的复合赋值是局部对象，在退出模块后不再存在。 10、柔性数组结构成员 C99中，结构中的最后一个元素允许是未知大小的数组，这就叫做柔性数组成员，但结构中的柔性数组成员前面必须至少一个其他成员。柔性数组成员允许结构中包含一个大小可变的数组。sizeof返回的这种结构大小不包括柔性数组的内存。包含柔性数组成员的结构用malloc()函数进行内存的动态分配，并且分配的内存应该大于结构的大小，以适应柔性数组的预期大小。 11、指定的初始化符 C99中，该特性对经常使用稀疏数组的程序员十分有用。指定的初始化符通常有两种用法：用于数组，以及用于结构和联合。用于数组的格式：[index] = vol; 其中，index表示数组的下标，vol表示本数组元素的初始化值。 例如： int x[10] = {[0] = 10, [5] = 30}; 其中只有x[0]和x[5]得到了初始化．用于结构或联合的格式如下： member-name(成员名称) 对结构进行指定的初始化时，允许采用简单的方法对结构中的指定成员进行初始化。 例如： struct example{ int k, m, n; } object = {m = 10,n = 200}; 其中，没有初始化k。对结构成员进行初始化的顺序没有限制。 12、printf()和scanf()函数系列的增强 C99中printf()和scanf()函数系列引进了处理long long int和unsigned long long int数据类型的特性。long long int 类型的格式修饰符是ll。在printf()和scanf()函数中，ll适用于d, i, o, u 和x格式说明符。另外，C99还引进了hh修饰符。当使用d, i, o, u和x格式说明符时，hh用于指定char型变元。ll和hh修饰符均可以用于n说明符。 格式修饰符a和A用在printf()函数中时，结果将会输出十六进制的浮点数。格式如下：[-]0xh, hhhhp+ d 使用A格式修饰符时，x和p必须是大写。A和a格式修饰符也可以用在scanf()函数中，用于读取浮点数。调用printf()函数时，允许在%f说明符前加上l修饰符，即%lf，但不起作用。 13、C99新增的库 C89中标准的头文件 定义宏assert() 字符处理 错误报告 定义与实现相关的浮点值勤 定义与实现相关的各种极限值 支持函数setlocale() 数学函数库使用的各种定义 支持非局部跳转 定义信号值 支持可变长度的变元列表 定义常用常数 支持文件输入和输出 其他各种声明 支持串函数 支持系统时间函数 C99新增的头文件和库 支持复数算法 给出对浮点状态标记和浮点环境的其他方面的访问 定义标准的、可移植的整型类型集合。也支持处理最大宽度整数的函数（常见） 首先在此1995年第一次修订时引进，用于定义对应各种运算符的宏 支持布尔数据类型类型。定义宏bool，以便兼容于C++ 定义标准的、可移植的整型类型集合。该文件包含在中（常见） 定义一般类型的浮点宏 首先在1995年第一次修订时引进，用于支持多字节和宽字节函数 首先在1995年第一次修订时引进，用于支持多字节和宽字节分类函数 14、func预定义标识符 用于指出func所存放的函数名，类似于字符串赋值。 15、其它特性的改动 放宽的转换限制 限制 C89标准 C99标准 数据块的嵌套层数 15 127 条件语句的嵌套层数 8 63 内部标识符中的有效字符个数 31 63 外部标识符中的有效字符个数 6 31 结构或联合中的成员个数 127 1023 函数调用中的参数个数 31 127 不再支持隐含式的int规则 删除了隐含式函数声明 对返回值的约束 C99中,非空类型函数必须使用带返回值的return语句. 扩展的整数类型 扩展类型 含义 int16_t 整数长度为精确16位 int_least16_t 整数长度为至少16位 int_fast32_t 最稳固的整数类型,其长度为至少32位 intmax_t 最大整数类型 uintmax_t 最大无符号整数类型 对整数类型提升规则的改进 C89中,表达式中类型为char,short int或int的值可以提升为int或unsigned int类型. C99中,每种整数类型都有一个级别.例如:long long int 的级别高于int, int的级别高于char等.在表达式中,其级别低于int或unsigned int的任何整数类型均可被替换成int或unsigned int类型. C11相比C99的变化编辑 对齐处理操作符 alignof，函数 aligned_alloc()，以及 头文件 。见 7.15 节。 _Noreturn 函数标记，类似于 gcc 的 attribute((noreturn))。例子： _Noreturn void thrd_exit(int res); _Generic 关键词，有点儿类似于 gcc 的 typeof。示例代码： 123456789101112131415#include&lt;stdio.h&gt;#defineGENERAL_ABS(x)_Generic((x),int:abs,float:fabsf,double:fabs)(x)int main(void)&#123;printf("intabs:%d\n",GENERAL_ABS(-12));printf("floatabs:%f\n",GENERAL_ABS(-12.04f));printf("doubleabs:%f\n",GENERAL_ABS(-13.09876));inta=10;intb=0,c=0;_Generic(a+0.1f,int:b,float:c,default:b)++;printf("b=%d,c=%d\n",b,c);_Generic(a+=1.1f,int:b,float:c,default:b)++;printf("a=%d,b=%d,c=%d\n",a,b,c);&#125; 静态断言（ static assertions），_Static_assert()，在解释 #if 和 #error 之后被处理。例子： _Static_assert(FOO &gt; 0, “FOO has a wrong value”); 删除了 gets() 函数，C99中已经将此函数被标记为过时，推荐新的替代函数 gets_s()。 新的 fopen() 模式，(“…x”)。类似 POSIX 中的 O_CREAT|O_EXCL，在文件锁中比较常用。 匿名结构体/联合体，这个早已经在 gcc 中了，我们并不陌生，定义在 6.7.2.1 p13。 多线程支持，包括：_Thread_local，头文件 ，里面包含线程的创建和管理函数（比如 thrd_create()，thrd_exit()），mutex （比如 mtx_lock()，mtx_unlock()）等等，更多内容清参考 7.26 节。 _Atomic类型修饰符和 头文件 ，见 7.17 节。 带边界检查（Bounds-checking）的函数接口，定义了新的安全的函数，例如 fopen_s()，strcat_s() 等等。更多参考 Annex K。 改进的 Unicode 支持，新的头文件 等。实例代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include&lt;stdio.h&gt;#include&lt;uchar.h&gt;size_tUTF16StrLen(constchar16_t*utf16String)&#123;if(utf16String==NULL)return0;size_tindex;for(index=0;utf16String[index]!=u'\0';index++);returnindex;&#125; size_tUTF16ToUTF8(char*mbBuffer,constchar16_t*utf16String)&#123;if(mbBuffer==NULL||utf16String==NULL)return0;mbstate_tstate=&#123;&#125;;size_tmbIndex=0;for(intutf16Index=0;utf16String[utf16Index]!=u'\0';utf16Index++)&#123;constsize_tlength=c16rtomb(&amp;mbBuffer[mbIndex],utf16String[utf16Index],&amp;state);mbIndex+=length;&#125;mbBuffer[mbIndex]='\0';returnmbIndex;&#125;intmain(intargc,char*argv[])&#123;char16_tch=u'好'; charchBuffer[64]; mbstate_tstate=&#123;&#125;; size_tlength=c16rtomb(chBuffer,ch,&amp;state); chBuffer[length]='\0'; printf("TheUTF-8characterlengthis:%zu,andthecharacteris:%s\n",length,chBuffer); constchar*utf8Str=u8"你好，世界。"; printf("TheUTF-8stringis:%s\n",utf8Str); constchar16_t*utf16Str=u"你好，世界。"; printf("Theutf16stringlengthis:%zu\n",UTF16StrLen(utf16Str)); length=UTF16ToUTF8(chBuffer,utf16Str); printf("TheUTF-8stringlengthis:%zu,andthecontentis:%s\n",length,chBuffer); printf("IftheconvertedUTF-8stringisequaltotheoriginalone?%s\n",strcmp(chBuffer,utf8Str)==0?"YES":"NO");&#125; 新增 quick_exit() 函数，作为第三种终止程序的方式，当 exit() 失败时可以做最少的清理工作（deinitializition），具体见 7.22.4.7。 创建复数的宏， CMPLX()，见 7.3.9.3。 更多浮点数处理的宏 （More macros for querying the characteristics of floating point types, concerning subnormal floating point numbers and the number of decimal digits the type is able to store）。 struct timespec 成为 time.h 的一部分，以及宏 TIME_UTC，函数 timespec_get()。]]></content>
      <tags>
        <tag>c语言</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[c语言课后作业实验4]]></title>
    <url>%2F2017%2F11%2Fc%E8%AF%AD%E8%A8%80%E8%AF%BE%E5%90%8E%E5%AE%9E%E9%AA%8C%E4%BD%9C%E4%B8%9A4%2F</url>
    <content type="text"><![CDATA[本文章涉嫌剧透，请紧张的往下看 说在前面，今天一位在腾讯搞开发工作的大佬给我指点了一下，”批评“了我printf(“\n”);的不良用法，然后还讲了一些其他的东西，在这里和大家先分享一下。 (仅供参考，请辩证的往下看）printf(“%s\n”,s)是一种很蠢的写法，某些实现会把printf(“%s\n”,s)自动优化为puts(s)。这说明连编译器都对printf(“%s\n”,s)看不下去了，原因是很多人上来学的就是printf()，有一种先入为主的惯性。加上对自己的代码质量没有太高的要求，所以只要输出就想到用printf()。类似的还有输出新行符写成printf(“\n”)（才写printf(“\n”)的我：汗。。。。。） 就K&amp;R而言，在讲hello,world时还介绍了\n，以及123printf(&quot;hello,&quot;);printf(&quot;world&quot;);printf(&quot;\n&quot;); 这种等价写法。这两个知识是用puts()不胜任的。比如，puts()本身，“不用加’\n’就自动换行”(实际是遇到\0输出\n)，这就很难引入对\n的介绍，因为不需要。如果硬要引入(比如在字符串中间加\n)则显得很不自然，而且很难解释\0转成\n的问题。用用puts()的另一个问题是没法把”hello,world“分成几段逐次输出。而把”hello,world“分成几段逐次输出对于学习者深入理解“程序”这个概念、学习美化C程序格式以及领略C语言灵活的特点的是很有意义的。So，如果教材介绍了相关的知识，那么使用printf()讲hello,world无可非议；如果没介绍相关知识，那就是东施效颦，还不如用puts()。 但是，puts()有一个很重要的问题就是缺少额外的格式检查和维护优势。使用printf()并不仅仅在于其带有返回值可以方便格式检查，同时还在于避免hardwriting完成代码开发维护和运营更新的分离。（我：看不懂= =）另外，scanf(“%s”,str)在遇到’\n’（回车）或’ ‘（空格）时输入结束，但’\n’（回车）或’ ‘（空格）停留在出入缓冲区，如处理不慎会影响下面的输入；gets(str)遇到’\n’（回车）时输入结束，但’\n’（回车）已被替换为’\0’，存储于字符串中，输入缓冲中没有遗留的’\n’（回车），不会影响后续的输入。 (仅供参考，请辩证的往上看）基础练习2.5（补充）突然想起这题还有另一种输出方式，推荐亲自运行一下，看看是什么结果～ 1234567891011121314151617181920#include &lt;stdio.h&gt;int main()&#123; int i,j,m; for(i=1;i&lt;=9;i++) &#123; for(j=1;j&lt;=i;j++) printf("%dx%d=%2d\t",j,i,j*i); printf("\n"); &#125; for(i=1;i&lt;=9;i++) &#123; for(m=1;m&lt;=9-i;m++) printf(" \t"); for(j=i;j&gt;=1;j--) printf("%dx%d=%2d\t",j,i,j*i); printf("\n"); &#125; return 0;&#125; 进阶练习3.3利用递归解决此类问题 123456789101112131415161718192021222324#include &lt;stdio.h&gt;#include &lt;math.h&gt;double Func(double x);//定义功能函数int main()&#123; double j,i=0,x=1; do&#123; i+=1.0/Func(x);//调用函数 j=1.0/Func(x); x++; &#125; while(j&gt;1e-6);//定义精度 printf("%f\n",i); return 0;&#125; double Func(double n)&#123; double f; if(n==0||n==1)//检测 f=1; else f=Func(n-1)*n;//反复调用自身达到阶乘的效果 return(f); //返回结果&#125; 进阶练习3.13（增加难度）若题目多一个非数字时停止，能否用一行代码实现判断和输入呢？ 12345678910111213#include &lt;stdio.h&gt;int main()&#123; float a,b; while (scanf("%f%f",&amp;a,&amp;b)==2&amp;&amp;a&gt;=0&amp;&amp;b&gt;=0)//一行解决输入和判断 &#123; printf("%f\n",a-b); &#125; return 0;&#125;/*continue:其实对于scanf这样的一些库函数其实对其来讲，他们使用起来并不是很友好，比如在不同的编译环境中，他们得到的结果数值是不一样的，这就需要如果我们需要在实际应用使用他们的话，就需要我们对他进行一些实际考证，这样才可以放心使用，可移植性并不优秀*/ 1.scanf（）函数返回成功读入的项目的个数。即在下面程序中scanf的返回值为1。如果没有读取任何项目（如它期望一个数字但是出入了一个非数字字符），它会返回值0。当它检测到“文件结尾”时，它返回EOF（EOF是文件stdio.h中定义的特殊值。一般，#define 指令把EOF 的值定义为 -1）。 1234int n;float p;n= scanf("%f",&amp;p);printf("%d,%f",n,p); 用%c读入空格和字符的问题。 如果在格式字符串中%c之前有一个空格，那么scanf()会跳到第一个非空白字符处。也就是说，命令scanf(“%c”,&amp;ch)读取在输入中遇到的第一个字符，而scanf(“ %c”,&amp;ch)（%c前有个空格）则读取遇到的第一个非空白字符。 对于同时输入几个字符，如果逗号（或任何非空格字符）和第一个%c之间没有间隔，则输入时，第一个字符与逗号之间也不能有间隔；如果有空格，则输入时，第一个字符和逗号之间可以有任意多个字符，也可以是0个。如果逗号和第二个%c之间没有间隔，则逗号和第二个输入字符间也不能有间隔。如果有空格，则输入时，第二个字符和逗号之间可以有任意多个字符，也可以是0个。 进阶练习3.16（补充）问题分析： 如果说n和m是一个亲密数对，那么它们必须满足以下条件\1. n的全部因子之和（不包括n）必须等于m\2. m的全部因子之和（不包括m）必须等于n 例如：220的全部因子之和为：1+2+4+5+10+11+20+22+44+55+110=284 284的全部因子之和为：1+2+4+71+142=220 所以220和284是一对个亲密数对，输出格式：220-&gt;284 1234567891011121314151617181920212223242526272829#include &lt;stdio.h&gt;#include &lt;math.h&gt;int GFS(int n)&#123; int i, sum = 0; for (i = 1; i * i &lt;= n; i++) &#123; if (n % i == 0) &#123; if (i == 1 || i * i == n) sum += i; else sum += i + n / i; &#125; &#125; return sum;&#125;int main()&#123; int i, num; for (i = 2; i &lt;= 2000; i++) &#123; num = GFS(i); if (GFS(num) == i &amp;&amp; i &lt; num) printf("%d-&gt;%d\n", i, num); &#125; return 0;&#125; 进阶练习3.17123456789101112131415161718#include&lt;stdio.h&gt;int main()&#123; int getsum(int n);//定义函数 int x,y; for(x=2;x&lt;1000;x++) for(y=2;y&lt;1000;y++)//循环开始 if((x==getsum(y))&amp;&amp;(y==getsum(x))&amp;&amp;x!=y)//条件判断 printf("%-5d%-5d%\n",x,y);&#125;int getsum(int n)&#123; int i,a=1; for(i=2;i&lt;=n/2;i++) if(!(n%i)) a=a+i; return a;//返回值&#125; 进阶练习3.26（拓展）用三种方法来解答次题 1234567891011121314151617181920//普通算法#include &lt;stdio.h&gt;int main()&#123; int p,i,n,m,temp; printf("输入两个正整数 n 和 m："); scanf("%d,%d",&amp;n,&amp;m); if(n&lt;m)&#123; temp=n; n=m; m=temp; &#125; /*把大数放在 n 中，小数放在 m 中*/ for (i=m;i&gt;=2;i--) /*求 n 和 m 的最大公约数*/ &#123; if (m%i==0 &amp;&amp; n%i==0) break ; &#125; printf("最大公约数%d\n",i); printf("最小公倍数%d\n",m*n/i); /*p 是原来两个整数的乘积*/&#125; 当然，也可以用递归的方法 123456789101112131415161718192021//递归求两个整数最大公约数 最小公倍数#include &lt;stdio.h&gt;int gbs(int x,int y);int main() &#123; int m,n,t1; printf("please input two integer number:"); scanf("%d%d",&amp;m,&amp;n); t1=gbs(m,n); printf("The highest common divisor is %d\n",t1); printf("The least common multiple is %d\n",m*n/t1); return 0;&#125;int gbs(int a,int b)&#123; if(a%b==0) return b; else return gbs(b,a%b); &#125; 重头戏来了：辗转相除法关于辗转相除法： 在我国古代的《九章算术》中就有记载，现摘录如下: 约分术曰：“可半者半之，不可半者，副置分母、子之数，以少减多，更相减损，求其等也。以等数约之。” 其中所说的“等数”，就是最大公约数。求 “等数”的办法是“更相减损”法，实际上就是辗转相除法。 辗转相除法求最大公约数，是一种比较好的方法，比较快。 对于 52317 和 75569 两个数。先用较大的 75569 除以 52317，得商 1，余数 23252，再以 52317 除以 23252，得商 2，余数是 5813，再用 23252 做被除数，5813 做除数，正好除尽得商数 4。这样 5813 就是 75569 和 52317 的最大公约数。 比如说有要求 a、b 两个整数的最大公约数，a＞b，那么我们先用 a 除以 b，得到商 8，余数 r1：a÷b ＝q1…r1 我们当然也可以把上面这个式子改写成乘法式：a＝bq1＋r1——l） 如果 r1＝0，那么 b 就是 a、b 的最大公约数 3。要是 r1≠0，就继续除，用 b 除以 r1，我们也可以有和上面一样的式子： b＝r1q2＋r2——-2） 如果余数 r2＝0，那么 r1 就是所求的最大公约数 3。为什么呢？因为如果 2）式变成了 b＝r1q2，那么 b1r1 的公约数就一定是 a1b 的公约数。这是因为一个数能同时除尽 b 和 r1，那么由 l）式，就一定能整除 a，从而也是 a1b 的公约数。 反过来，如果一个数 d，能同时整除 a1b，那么由 1）式，也一定能整除 r1，从而也有 d 是 b1r1 的公约数。 这样，a 和 b 的公约数与 b 和 r1 的公约数完全一样，那么这两对的最大公约数也一定相同。那 b1r1 的最大公约数，在 r1＝0 时，不就是 r1 吗？所以 a 和 b 的最大公约数也是 r1 了。 有人会说，那 r2 不等于 0 怎么办？那当然是继续往下做，用 r1 除以 r2，…… 直到余数为零为止。 在这种方法里，先做除数的，后一步就成了被除数，这就是辗转相除法名字的来历。 12345678910111213141516171819#include &lt;stdio.h&gt;int main()&#123; int p,r,n,m,temp; printf("输入两个正整数 n 和 m："); scanf("%d,%d",&amp;n,&amp;m); if(n&lt;m) &#123;temp=n;n=m;m=temp;&#125; /*把大数放在 n 中，小数放在 m 中*/ p=n*m; /*先将 n 和 m 的乘积保存在 p 中，以便求最小公倍数时用*/ r=n%m; while(r!=0) /*求 n 和 m 的最大公约数*/ &#123; n=m;m=r;r=n%m;&#125; printf("最大公约数%d\n",m); printf("最小公倍数%d\n",p/m); /*p 是原来两个整数的乘积*/ return 0;&#125; 看完了？厉害厉害～鼓掌鼓掌～]]></content>
      <tags>
        <tag>c语言</tag>
        <tag>c语言作业</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Swift 结构体]]></title>
    <url>%2F2017%2F11%2FSwift-%E7%BB%93%E6%9E%84%E4%BD%93%2F</url>
    <content type="text"><![CDATA[Swift 结构体是构建代码所用的一种通用且灵活的构造体 我们可以为结构体定义属性（常量、变量）和添加方法，从而扩展结构体的功能。 与 C 和 Objective C 不同的是： 结构体不需要包含实现文件和接口。 结构体允许我们创建一个单一文件，且系统会自动生成面向其它代码的外部接口。 结构体总是通过被复制的方式在代码中传递，因此它的值是不可修改的。 语法我们通过关键字 struct 来定义结构体： 123456struct nameStruct &#123; Definition 1 Definition 2 …… Definition N&#125; 实例我们定义一个名为 MarkStruct 的结构体 ，结构体的属性为学生三个科目的分数，数据类型为 Int： 12345struct MarkStruct&#123; var mark1: Int var mark2: Int var mark3: Int&#125; 我们可以通过结构体名来访问结构体成员。 结构体实例化使用 let 关键字： 1234567891011import Cocoastruct studentMarks &#123; var mark1 = 100 var mark2 = 78 var mark3 = 98&#125;let marks = studentMarks()print("Mark1 是 \(marks.mark1)")print("Mark2 是 \(marks.mark2)")print("Mark3 是 \(marks.mark3)") 以上程序执行输出结果为： 123Mark1 是 100Mark2 是 78Mark3 是 98 实例中，我们通过结构体名 ‘studentMarks’ 访问学生的成绩。结构体成员初始化为mark1, mark2, mark3，数据类型为整型。 然后我们通过使用 let 关键字将结构体 studentMarks() 实例化并传递给 marks。 最后我们就通过 . 号来访问结构体成员的值。 以下实例化通过结构体实例化时传值并克隆一个结构体： 1234567891011121314import Cocoastruct MarksStruct &#123; var mark: Int init(mark: Int) &#123; self.mark = mark &#125;&#125;var aStruct = MarksStruct(mark: 98)var bStruct = aStruct // aStruct 和 bStruct 是使用相同值的结构体！bStruct.mark = 97print(aStruct.mark) // 98print(bStruct.mark) // 97 以上程序执行输出结果为： 129897 结构体应用在你的代码中，你可以使用结构体来定义你的自定义数据类型。 结构体实例总是通过值传递来定义你的自定义数据类型。 按照通用的准则，当符合一条或多条以下条件时，请考虑构建结构体： 结构体的主要目的是用来封装少量相关简单数据值。 有理由预计一个结构体实例在赋值或传递时，封装的数据将会被拷贝而不是被引用。 任何在结构体中储存的值类型属性，也将会被拷贝，而不是被引用。 结构体不需要去继承另一个已存在类型的属性或者行为。 举例来说，以下情境中适合使用结构体： 几何形状的大小，封装一个width属性和height属性，两者均为Double类型。 一定范围内的路径，封装一个start属性和length属性，两者均为Int类型。 三维坐标系内一点，封装x，y和z属性，三者均为Double类型。 结构体实例是通过值传递而不是通过引用传递。 12345678910111213141516171819202122232425import Cocoastruct markStruct&#123; var mark1: Int var mark2: Int var mark3: Int init(mark1: Int, mark2: Int, mark3: Int)&#123; self.mark1 = mark1 self.mark2 = mark2 self.mark3 = mark3 &#125;&#125;print("优异成绩:")var marks = markStruct(mark1: 98, mark2: 96, mark3:100)print(marks.mark1)print(marks.mark2)print(marks.mark3)print("糟糕成绩:")var fail = markStruct(mark1: 34, mark2: 42, mark3: 13)print(fail.mark1)print(fail.mark2)print(fail.mark3) 以上程序执行输出结果为： 12345678优异成绩:9896100糟糕成绩:344213 以上实例中我们定义了结构体 markStruct，三个成员属性：mark1, mark2 和 mark3。结构体内使用成员属性使用 self 关键字。 从实例中我们可以很好的理解到结构体实例是通过值传递的。 更多信息查看The Swift Programming Language (Swift 4) 官方文档]]></content>
      <tags>
        <tag>Swift</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Swift iOS 菜单和圆形布局库 FanMenu]]></title>
    <url>%2F2017%2F11%2FSwift-iOS-%E8%8F%9C%E5%8D%95%E5%92%8C%E5%9C%86%E5%BD%A2%E5%B8%83%E5%B1%80%E5%BA%93-FanMenu%2F</url>
    <content type="text"><![CDATA[FanMenu 是一个菜单和 圆形布局类库，基于 Macaw，用Swift编写。介绍在我上一篇文章中有讲。 用法** 在您的故事板或程序中创建UIView。 将FanMenu设置为UIView类 设置按钮 12345fanMenu.button = FanMenuButton(id: "main",image: "plus",color: Color(val: 0x7C93FE)) 4. 设置菜单项 12345678910111213fanMenu.items = [FanMenuButton(id: "exchange_id",image: "exchange",color: Color(val: 0x9F85FF)), ...FanMenuButton(id: "visa_id",image: "visa",color: Color(val: 0xF55B58))] 5. 添加事件处理程序 123456789//call before animationfanMenu.onItemDidClick = &#123; button inprint("ItemDidClick: \(button.id)")&#125;// call after animationfanMenu.onItemWillClick = &#123; button inprint("ItemWillClick: \(button.id)")&#125;]]></content>
      <tags>
        <tag>Swift库</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Swift 强大且易用的矢量图形库 Macaw]]></title>
    <url>%2F2017%2F11%2FSwift-%E5%BC%BA%E5%A4%A7%E4%B8%94%E6%98%93%E7%94%A8%E7%9A%84%E7%9F%A2%E9%87%8F%E5%9B%BE%E5%BD%A2%E5%BA%93-Macaw%2F</url>
    <content type="text"><![CDATA[此文介绍了Macaw这一强大的矢量图形库……. Macaw是一个功能强大、易于使用的矢量图形库，支持 SVG图片， 用Swift编写。动机现代设计包含大量的插图和复杂的动画。 移动开发人员必须花费大量时间将设计转换为本机视图，这些视图可以针对不同的屏幕进行调整。 使用Macaw，您可以将开发时间缩短到最低限度，并描绘高级场景元素中的所有图形。 甚至可以使用Macaw中的事件和动画支持从设计工具中渲染SVG图形。示例Activity Monitor应用程序显示步数，跑步级别和每日摘要。 动画菜单 你喜欢化学吗？这个iPad应用程序显示了Macaw的全部功能：仿射变换，用户事件，动画和各种效果。 [点击查看更多示例] [开源代码主页]]]></content>
      <tags>
        <tag>Swift库</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Swift 元组(Tuples)介绍]]></title>
    <url>%2F2017%2F11%2Fswift%E5%AD%A6%E4%B9%A0%E4%B9%8B%E5%85%83%E7%BB%84%2F</url>
    <content type="text"><![CDATA[元组的定义元组是Objective-C中没有的数据类型，与数组类似，都是表示一组数据的集合，但与数组不同，它的特点是： 1&gt;元组的长度任意 2&gt;元组中的数据可以是不同的数据类型 元组的定义很简单，用小括号括起来，以逗号隔开就可以了，如： 1var userInfo = ("Tuski" ,true, 19) 元组内的值可以使任意类型,并不要求是相同类型。 12let http404Error = (404, "Not Found")// http404Error 的类型是 (Int, String),值是 (404, "Not Found") 另外，在创建元组时你还可以给元组中的元素命名： 1let secondHighScore = (name: "James", score: 4096) ###以上就是创建元组的方法 从元组中读元素 如果我们没有给元组的元素命名，我们可以用点语法，通过定义好的元组变量或常量获取它的第1个到第n个元素： 123let firstHighScore = ("Mary", 9001)println(firstHighScore.0) // Maryprintln(firstHighScore.1) // 9001 若你觉得上述这种方法会造成语义的不明确，我们还可以将元组赋值给一个带有元素名称的元组（元素名称个数要对应）: 123let (firstName, firstScore) = firstHighScoreprintln(firstName) // Maryprintln(firstScore) // 9001 如果你只需要一部分元组值，分解的时候可以把要忽略的部分用下划线（_）标记： 12let (_, firstScore) = firstHighScoreprintln(firstScore) // 9001 如果我们已经给元组中的元素命名了名称，那么我们可以这样写： 123let secondHighScore = (name: "James", score: 4096)println(secondHighScore.name) // Jamesprintln(secondHighScore.score) // 4096 将元组作为函数返回值 当你想让一个函数能够返回多种类型时，这是元组的最佳使用场景。 我们可以将元组作为函数的返回值，下面这个函数的返回值就是我们之前定义过的secondHighScore元组： 12345func getAHighScore() -&gt; (name: String, score: Int) &#123; let theName = "Patricia" let theScore = 3894 return (theName, theScore) &#125; 为什么说上述函数的返回值是secondHighScore元组呢？因为getAHighScore函数返回的元组元素个数、元素名称、元素类型均和secondHighScore相同。 其实将元组作为函数的返回值时也可以不必对元素进行命名，只要你明白每个元素代表的含义即可： 12345func getAHighScore() -&gt; (String, Int) &#123; let theName = "Patricia" let theScore = 3894 return (theName, theScore) &#125; 如果你不确定返回的元组一定不为nil，那么你可以返回一个可选的元组类型： 123func maybeGetHighScore() -&gt; (String, Int)? &#123; return nil&#125; 因为是可选的元组类型，所以当返回的元组不为nil时，你需要对元组进行解包： 123456if let possibleScore = maybeGetHighScore() &#123; possibleScore.0 possibleScore.1&#125; else &#123; println("Nothing Here")&#125; ###注意：当你定义了一个没有返回值的函数时，其实该函数是返回一个空的元组() 元组的访问级别 元组的访问级别取决于它包含的元素。比如元组里的元素都是private级别的，那么该元组也是private级别的。但这里有一个遵循最小的原则，也就是说如果一个元组中有两个元素，一个为private级别，另一个为public级别，那么该元组遵循最小原则，它的访问级别为private。 元组是值类型 关于值类型和引用类型的知识这里不再累赘，我们通过一个代码示例来看看元组是哪种类型： 12345var someScore = ("John", 55)var anotherScore = someScoreanotherScore.0 = "Robert"println(anotherScore.0) //Outputs: "Robert"println(someScore.0) //Outputs: "John" 通过上述的代码示例可以看出，我把someScore元组赋值给了anotherScore，然后修改了anotherScore的第1个元素的值，最后分别打印了someScore和anotherScore第1个元素的值。someScore元组第一个元素的值为Robert，而anotherScore元组第一个元素的值仍然为John。由此可见元组是值类型。 总结 元组（Tuple）的概念对于没有接触过脚本语言的同学来说，是比较新的概念。但是元组既不复杂也不神秘，很多时候用Struct结构体或者类都可以解决。可以把元组理解为一种只能存放数据，却没有定义方法的轻量级数据结构。]]></content>
      <tags>
        <tag>Swift</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[c语言课后作业实验3]]></title>
    <url>%2F2017%2F11%2Fc%E8%AF%AD%E8%A8%80%E8%AF%BE%E5%90%8E%E5%AE%9E%E9%AA%8C%E4%BD%9C%E4%B8%9A3%2F</url>
    <content type="text"><![CDATA[此处补充了一个冒泡算法，有兴趣可以点进来 基础练习2（补充）123456789101112131415161718192021222324252627//这是一个很简单的冒泡算法，利用循环解决问题字符串输出最小ascii码对应的字符#include &lt;stdio.h&gt;#include &lt;string.h&gt;int main()&#123; int a,temp; char c[50]; printf("请输入一串字符/n"); gets(c); a=strlen(c); printf("长度是：%d/n",a); for(int i=0;i&lt;a;i++) &#123; for(int j=i+1;j&lt;a;j++) //j&lt;a 如果等于a的话 数组就超过了，因为从0开始的，比如a[4] 就是a[0],a[1],a[2],a[3] 四个引用,不懂就去翻书 &#123; if(c[i]&gt;c[j]) &#123; temp=c[j];//temp提供一个交换作用 c[j]=c[i]; c[i]=temp; &#125; &#125; &#125; printf("排序后：%s/n",c); return 0;&#125; 进阶练习51234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859//解决此问题有更简单的办法，利用数组和循环，请自己思考#include &lt;stdio.h&gt;int main()&#123; int day,month,year,sum = 0,leap; printf("please input year,month,day\n"); scanf("%d%d%d",&amp;year,&amp;month,&amp;day); switch(month) /*先计算某月以前月份的总天数*/ &#123; case 1: sum=0; break; case 2: sum=31; break; case 3: sum=59; break; case 4: sum=90; break; case 5: sum=120; break; case 6: sum=151; break; case 7: sum=181; break; case 8: sum=212; break; case 9: sum=243; break; case 10: sum=273; break; case 11: sum=304; break; case 12: sum=334; break; default: printf("data error"); break; &#125; sum=sum+day; /*再加上某天的天数*/ if(year%400==0||(year%4==0&amp;&amp;year%100!=0)) /*判断是不是闰年*/ leap=1; else leap=0; if(leap==1&amp;&amp;month&gt;2) /*如果是闰年且月份大于2,总天数应该加一天*/ sum++; printf("It is the %dth day of %d year\n",sum,year); return 0;&#125;]]></content>
      <tags>
        <tag>c语言</tag>
        <tag>c语言作业</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[c语言课后作业实验2部分进阶练习]]></title>
    <url>%2F2017%2F11%2Fc%E8%AF%AD%E8%A8%80%E8%AF%BE%E5%90%8E%E5%AE%9E%E9%AA%8C%E4%BD%9C%E4%B8%9A2%2F</url>
    <content type="text"><![CDATA[实验1因为太简单所以懒得上传了（才不是我懒，逃）会发一些我觉得有必要发的代码，如果没有，就是真的太简单了。而且如果有所不一样，说明我完善了相关功能 = =！ 进阶练习3123456789#include &lt;stdio.h&gt;int main(int argc, const char * argv[]) &#123; char a, b, c; int sum; scanf("%c%c%c",&amp;a,&amp;b,&amp;c); sum = (a-'0')*100+(b-'0')*10+(c-'0'); printf("the number is %d\n",sum); return 0;&#125; 进阶练习41234567891011121314151617#include &lt;stdio.h&gt;int main(int argc, const char * argv[]) &#123; while(1)&#123; float x; printf("Please enter a number from[1.0 , 100.0]\n"); if (!scanf("%f", &amp;x))&#123; printf("Input error ,please enter again\n"); while(getchar()!='\n');&#125; else if (x&lt;1.0||x&gt;100.0)&#123; printf("The number is not correct\n");&#125; else&#123; printf("The number is %lf\n",(x*x*x*x*x)); break; &#125; &#125; return 0;&#125; 进阶练习11威力加强（偷懒）版1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include &lt;stdio.h&gt;int main(int argc, const char * argv[]) &#123; char a[1000]; int i; gets(a); puts(a); printf("\n"); for(i=0;a[i]!='\0';i++) &#123; if(a[i]&gt;='A'&amp;&amp;a[i]&lt;='V') a[i]+=4; else if(a[i]&gt;='a'&amp;&amp;a[i]&lt;='v') a[i]+=4; &#125; for (i=0;a[i]!='\0';i++) &#123; switch(a[i])&#123; case 'w': a[i] = 'a'; break; case 'x': a[i] = 'b'; break; case 'y': a[i] = 'c'; break; case 'z': a[i] = 'd'; break; case 'W': a[i] = 'A'; break; case 'X': a[i] = 'B'; break; case 'Y': a[i] = 'C'; break; case 'Z': a[i] = 'D'; break; &#125; &#125; for (i=0;a[i]!='\0';i++) &#123; printf("%c",a[i]); &#125; printf("\n"); return 0;&#125; 进阶练习12123456789101112#include &lt;stdio.h&gt;int main(int argc, const char * argv[]) &#123; int a,b,x,y,z; printf("Please input a number from (10~99):"); scanf("%d",&amp;a); b=a*a; x=b%10; y=b/10%10; z=10*y+x; printf("The number is:%d\n",z); return 0;&#125;]]></content>
      <tags>
        <tag>c语言</tag>
        <tag>c语言作业</tag>
      </tags>
  </entry>
</search>
