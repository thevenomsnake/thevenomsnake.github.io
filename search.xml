<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[SCP Permission denied ?]]></title>
    <url>%2F2018%2F04%2FSCP-Permission-denied%2F</url>
    <content type="text"><![CDATA[I bought a new server today and there is always an error when using SCP ErrorAs you can see ,Terminal throw a error :scp: /var/www/html/123321.zip: Permission denied So……how to fix that ? FixThe first problem that we should think of is the folder permissions issue. This folder is may created by the Root user. Normal users do not have that permission. Solve:These are the examples from the symbolic notationsection given in octal notation: Symbolic Notation Numeric Notation Means ---------- 0000 no permissions -rwx------ 0700 read, write, &amp; execute only for owner -rwxrwx--- 0770 read, write, &amp; execute for owner and group -rwxrwxrwx 0777 read, write, &amp; execute for owner, group and others ---x--x--x 0111 execute --w--w--w- 0222 write --wx-wx-wx 0333 write &amp; execute -r--r--r-- 0444 read -r-xr-xr-x 0555 read &amp; execute -rw-rw-rw- 0666 read &amp; write -rwxr----- 0740 owner can read, write, &amp; execute; group can only read; others have no permissions So , we need 777 1chmod 777 /your_folder So let’s try again: w..wait..what ? Why there is still error ? I am using QCloud. Emm…..Could it be that….? FindFolder permissions are resolved, is it the server’s security settings? So I decide to open all the ports…… let’s try again……. まさか ?Find the sshd_config use nano to open it ,find &amp;&amp;change PermitRootLogin yes exit and save Let’s try again Success !]]></content>
      <tags>
        <tag>SCP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Solutions for Java homework]]></title>
    <url>%2F2018%2F03%2FSolutions-for-Java-homework%2F</url>
    <content type="text"><![CDATA[I will update answers in this page. Exercise 13.11123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051/*(Find the number of days in a month) Write a program that prompts the userto enter the month and year and displays the number of days in the month. Forexample, if the user entered month 2 and year 2012, the program should displaythat February 2012 had 29 days. If the user entered month 3 and year 2015, theprogram should display that March 2015 had 31 days.*/import java.util.Scanner;public class Exercise_03_11 &#123; public static void main(String[] args) &#123; Scanner input = new Scanner(System.in); // Prompt user to enter the month an year System.out.print("Enter the month as integer: "); int month = input.nextInt(); System.out.print("Enter the year as integer: "); int year = input.nextInt(); boolean leapYear = (year % 4 == 0 &amp;&amp; year % 100 != 0) || (year % 400 == 0); // Display the number of days in the month switch (month) &#123; case 1: System.out.println( "January " + year + " had 31 days"); break; case 2: System.out.println("February " + year + " had" + ((leapYear) ? " 29 days" : " 28 days")); break; case 3: System.out.println( "March " + year + " had 31 days"); break; case 4: System.out.println( "April " + year + " had 30 days"); break; case 5: System.out.println( "May " + year + " had 31 days"); break; case 6: System.out.println( "June " + year + " had 30 days"); break; case 7: System.out.println( "July " + year + " had 31 days"); break; case 8: System.out.println( "August " + year + " had 31 days"); break; case 9: System.out.println( "September " + year + " had 30 days"); break; case 10: System.out.println( "October " + year + " had 31 days"); break; case 11: System.out.println( "November " + year + " had 30 days"); break; case 12: System.out.println( "December " + year + " had 31 days"); &#125; &#125;&#125; 4.612345678910111213141516171819202122232425262728293031323334353637383940414243/*(Random points on a circle) Write a program that generates three random pointson a circle centered at (0, 0) with radius 40 and display three angles in a triangleformed by these three points, as shown in Figure 4.7a. (Hint: Generate a randomangle a in radians between 0 and 2PI, as shown in Figure 4.7b and the point determinedby this angle is (r*cos(a), r*sin(a)).)*/public class Exercise_04_06 &#123; public static void main(String[] args) &#123; final double RADIUS = 40; // Generate random angle in radians between 0 and 2PI double angle1 = (Math.random() * (2 * Math.PI)); double angle2 = (Math.random() * (2 * Math.PI)); double angle3 = (Math.random() * (2 * Math.PI)); // Get x and y double x1 = RADIUS * Math.cos(angle1); double y1 = RADIUS * Math.sin(angle1); double x2 = RADIUS * Math.cos(angle2); double y2 = RADIUS * Math.sin(angle2); double x3 = RADIUS * Math.cos(angle3); double y3 = RADIUS * Math.sin(angle3); // Compute three sides double a = Math.sqrt(Math.pow(x2 - x3, 2) + Math.pow(y2 - y3, 2)); double b = Math.sqrt(Math.pow(x1 - x3, 2) + Math.pow(y1 - y3, 2)); double c = Math.sqrt(Math.pow(x1 - x2, 2) + Math.pow(y1 - y2, 2)); // Compute three angles double angleA = Math.toDegrees(Math.acos((a * a - b * b - c * c) / (-2 * b * c))); double angleB = Math.toDegrees(Math.acos((b * b - a * a - c * c) / (-2 * a * c))); double angleC = Math.toDegrees(Math.acos((c * c - b * b - a * a) / (-2 * a * b))); // Display results System.out.println("The three angles are " + Math.round(angleA * 100) / 100.0 + " " + Math.round(angleB * 100) / 100.0 + " " + Math.round(angleC * 100) / 100.0); &#125;&#125; 4.211234567891011121314151617181920212223242526272829303132333435/*(Check SSN) Write a program that prompts the user to enter a Social Securitynumber in the format DDD-DD-DDDD, where D is a digit. Your program shouldcheck whether the input is valid.*/import java.util.Scanner;public class Exercise_04_21 &#123; public static void main(String[] args) &#123; Scanner input = new Scanner(System.in); // Prompt the user to enter a Social Security number System.out.print("Enter a SSN: "); String ssn = input.nextLine(); // Check whether the input is valid boolean isValid = (ssn.length() == 11) &amp;&amp; (Character.isDigit(ssn.charAt(0))) &amp;&amp; (Character.isDigit(ssn.charAt(1))) &amp;&amp; (Character.isDigit(ssn.charAt(2))) &amp;&amp; (ssn.charAt(3) == '-') &amp;&amp; (Character.isDigit(ssn.charAt(4))) &amp;&amp; (Character.isDigit(ssn.charAt(5))) &amp;&amp; (Character.isDigit(ssn.charAt(7))) &amp;&amp; (ssn.charAt(6) == '-') &amp;&amp; (Character.isDigit(ssn.charAt(8))) &amp;&amp; (Character.isDigit(ssn.charAt(9))) &amp;&amp; (Character.isDigit(ssn.charAt(10))); // Display result System.out.println(ssn + " is " + ((isValid) ? "a valid " : "an invalid ") + "social security number"); &#125;&#125; 5.51123456789101112131415161718192021222324252627282930313233/*(Longest common prefix) Write a program that prompts the user to enter twostrings and displays the largest common prefix of the two strings.*/import java.util.Scanner;public class Exercise_05_51 &#123; public static void main(String[] args) &#123; Scanner input = new Scanner(System.in); // Prompt the user to enter two strings System.out.print("Enter the first string: "); String string1 = input.nextLine(); System.out.print("Enter the second string: "); String string2 = input.nextLine(); int index = 0; // Initialize index to 0 String prefix = ""; // Initialize prefix as empty string // Get the largest commmon prefix of the two strings while (string1.charAt(index) == string2.charAt(index)) &#123; prefix += string1.charAt(index); index++; &#125; // Display the result if (prefix.length() &gt; 0) System.out.println("The commmon prefix is " + prefix); else System.out.println(string1 + " and " + string2 + " have no commmon prefix"); &#125;&#125; Exercise 26.3123456789101112131415161718192021222324252627282930313233343536373839404142/*(Palindrome integer) Write the methods with the following headers// Return the reversal of an integer, i.e., reverse(456) returns 654public static int reverse(int number)// Return true if number is a palindromepublic static boolean isPalindrome(int number)Use the reverse method to implement isPalindrome. A number is a palindromeif its reversal is the same as itself. Write a test program that prompts theuser to enter an integer and reports whether the integer is a palindrome.*/import java.util.Scanner;public class Exercise_06_03 &#123; /** Main Method */ public static void main(String[] args) &#123; Scanner input = new Scanner(System.in); // Create a Scanner // Prompt the user to enter an integer System.out.print("Enter an integer: "); int number = input.nextInt(); // Report whether the integer is a palindrome. System.out.println(number + (isPalindrome(number) ? " is " : " is not ") + "a palindrome."); &#125; /** Method isPalindrome returns true if number is a palindrome */ public static boolean isPalindrome(int number) &#123; return number == reverse(number) ? true : false; &#125; /** Method reverse returns the reversal of an integer */ public static int reverse(int number) &#123; String reverse = ""; // Holds reversed number String n = number + ""; // Convert number to string // Reverse string for (int i = n.length() - 1; i &gt;= 0; i--) &#123; reverse += n.charAt(i); &#125; return Integer.parseInt(reverse); // Return reversed integer &#125;&#125; 7.3123456789101112131415161718192021222324252627282930313233343536373839/*(Count occurrence of numbers) Write a program that reads the integers between 1and 100 and counts the occurrences of each. Assume the input ends with 0.Note that if a number occurs more than one time, the plural word “times” is usedin the output.*/import java.util.Scanner;public class Exercise_07_03 &#123; /** Main Method */ public static void main(String[] args) &#123; int[] counts = new int[100]; // Counts the occurrences of numbers // Prompt the user to enter integers between 1 and 100 System.out.print("Enter the integers between 1 and 100: "); // Count occurrence of numbers count(counts); // Display results for (int i = 0; i &lt; counts.length; i++) &#123; if (counts[i] &gt; 0) System.out.println((i + 1) + " occurs " + counts[i] + " time" + (counts[i] &gt; 1 ? "s" : "")); &#125; &#125; /** Method count reads integers between 1 and 100 * and counts the occurrences of each */ public static void count(int[] counts)&#123; Scanner input = new Scanner(System.in); int num; // holds user input do &#123; num = input.nextInt(); if (num &gt;= 1 &amp;&amp; num &lt;= 100) counts[num - 1]++; &#125; while (num != 0); &#125;&#125; 7.30123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051/********************************************************************************** (Pattern recognition: consecutive four equal numbers) Write the following ** method that tests whether the array has four consecutive numbers with the same ** value. ** * * public static boolean isConsecutiveFour(int[] values) ** * * Write a test program that prompts the user to enter a series of integers and ** displays if the series contains four consecutive numbers with the same value. ** Your program should first prompt the user to enter the input size—i.e., the ** number of values in the series. **********************************************************************************/import java.util.Scanner;public class Exercise_07_30 &#123; /** Main method */ public static void main(String[] args) &#123; Scanner input = new Scanner(System.in); // Prompt the user to enter the input size System.out.print("Enter the number of values: "); int[] values = new int[input.nextInt()]; // Promt the user to enter the values System.out.print("Enter the values: "); for (int i = 0; i &lt; values.length; i++) values[i] = input.nextInt(); // Display if the series contains for consecutive numbers System.out.println("The list has" + (isConsecutiveFour(values) ? " " : " no ") + "consecutive fours"); &#125; /** isConsecutiveFour tests whether the array has * four consecutive numbers with the same value */ public static boolean isConsecutiveFour(int[] values) &#123; int count = 1; // number of consecutive numbers for (int i = 0; i &lt; values.length - 1; i++) &#123; if (values[i] == values[i + 1]) count++; if (count &gt;= 4) return true; if (values[i] != values[i + 1]) count = 1; &#125; return false; &#125;&#125; 8.71234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253/********************************************************************************** (Points nearest to each other) Listing 8.3 gives a program that finds two ** points in a two-dimensional space nearest to each other. Revise the program so ** that it finds two points in a three-dimensional space nearest to each other. ** Use a two-dimensional array to represent the points. Test the program using ** the following points: ** double[][] points = &#123;&#123;-1, 0, 3&#125;, &#123;-1, -1, -1&#125;, &#123;4, 1, 1&#125;, ** &#123;2, 0.5, 9&#125;, &#123;3.5, 2, -1&#125;, &#123;3, 1.5, 3&#125;, &#123;-1.5, 4, 2&#125;, ** &#123;5.5, 4, -0.5&#125;&#125;; ** The formula for computing the distance between two points (x1, y1, z1) and ** (x2, y2, z2) is √(x2 - x1)^2 + (y2 - y1)^2 + (z2 - z1)^2. **********************************************************************************/public class Exercise_08_07 &#123; /** Main method */ public static void main(String[] args) &#123; // Initialize array with points double[][] points = &#123;&#123;-1, 0, 3&#125;, &#123;-1, -1, -1&#125;, &#123;4, 1, 1&#125;, &#123;2, 0.5, 9&#125;, &#123;3.5, 2, -1&#125;, &#123;3, 1.5, 3&#125;, &#123;-1.5, 4, 2&#125;, &#123;5.5, 4, -0.5&#125;&#125;; // p1 and p2 are the indices in the points' array int p1 = 0, p2 = 1, p3 = 3; // Initial two points double shortestDistance = distance(points[p1][0], points[p1][1], points[p1][2], points[p2][0], points[p2][p1], points[p3][p2]); // Initialize shortest Distance // Compute distance for every two points for (int i = 0; i &lt; points.length; i++) &#123; for (int j = i + 1; j &lt; points.length; j++) &#123; double distance = distance(points[i][0], points[i][1], points[i][2], points[j][0], points[j][1], points[j][2]); // Find distance if (shortestDistance &gt; distance) &#123; p1 = i; // Update p1 p2 = j; // Update p2 shortestDistance = distance; // Update shortestDistance &#125; &#125; &#125; // Display result System.out.println("The closest two points are " + "(" + points[p1][0] + ", " + points[p1][1] + ") and (" + points[p2][0] + ", " + points[p2][1] + ")"); &#125; /** Compute the distance between two points (x1, y1) and (x2, y2)*/ public static double distance( double x1, double y1, double z1, double x2, double y2, double z2) &#123; return Math.sqrt(Math.pow(x2 - x1, 2) + Math.pow(y2 - y1, 2) + Math.pow(y2 - y1, 2)); &#125;&#125; 8.14123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176/********************************************************************************** (Explore matrix) Write a program that prompts the user to enter the length of ** a square matrix, randomly fills in 0s and 1s into the matrix, prints the ** matrix, and finds the rows, columns, and diagonals with all 0s or 1s. **********************************************************************************/import java.util.Scanner;public class Exercise_08_14 &#123; /** Main method */ public static void main(String[] args) &#123; // Create a square matrix int[][] matrix = getMatrix(); // Display matrix print(matrix); // Display results int[] rows = allRow(matrix); int count = 0; for (int i = 0; i &lt; rows.length; i++) &#123; if (rows[i] &gt;= 0) System.out.println("All " + rows[i] + "s on row " + (i + 1)); else count++; if (count == rows.length) System.out.println("No same numbers on a row"); &#125; int[] columns = allColumn(matrix); count = 0; for (int i = 0; i &lt; columns.length; i++) &#123; if (columns[i] &gt;= 0) System.out.println("All " + columns[i] + "s on column " + (i + 1)); else count++; if (count == columns.length) System.out.println("No same numbers on a column"); &#125; int n = allMajorDiagonal(matrix); switch (n) &#123; case 0: case 1: System.out.println("All " + n + "s on the major diagonal"); break; default: System.out.println("No same numbers on the major diagonal"); &#125; n = allSubDiagonal(matrix); switch (n) &#123; case 0: case 1: System.out.println("All " + n + "s on the sub-diagonal"); break; default: System.out.println("No same numbers on the sub-diagonal"); &#125; &#125; /** allSubDiagonal returns 0 or 1 if all 0s or 1s on the sub-diagonal, otherwise returns -1 */ public static int allSubDiagonal(int[][] m) &#123; int[] count = new int[2]; // Counts 0s and 1s // Initialize count array to 0; count[0] = 0; count[1] = 0; for (int i = 0, j = m.length - 1; i &lt; m.length; i++, j--) &#123; count[m[i][j]]++; if (count[0] == m.length) return 0; if (count[1] == m.length) return 1; &#125; return -1; &#125; /** allMajorDiagonal returns 0 or 1 if all 0s or 1s on the major diagonal, otherwise returns -1 */ public static int allMajorDiagonal(int[][] m) &#123; int[] count = new int[2]; // Counts 0s and 1s // Initialize count array to 0; count[0] = 0; count[1] = 0; for (int i = 0; i &lt; m.length; i++) &#123; count[m[i][i]]++; if (count[0] == m.length) return 0; if (count[1] == m.length) return 1; &#125; return -1; &#125; /** allColumn returns 0 or 1 if a column has all 0s or 1s, otherwise returns -1 */ public static int[] allColumn(int[][] m) &#123; // Initilize array to hold results with -1 int[] result = new int[m.length]; for (int i = 0; i &lt; result.length; i++) &#123; result[i] = -1; &#125; int[] count = new int[2]; // Counts 0s and 1s for (int i = 0; i &lt; m.length; i++) &#123; // Initialize count array to 0; count[0] = 0; count[1] = 0; for (int j = 0; j &lt; m[i].length; j++) &#123; count[m[j][i]]++; if (count[0] &lt; j + 1 &amp;&amp; count[1] &lt; j + 1) &#123; break; &#125; &#125; if (count[0] &gt;= m.length || count[1] &gt;= m.length) result[i] = count[0] &gt; count[1] ? 0 : 1; &#125; return result; &#125; /** allRow returns 0 or 1 if a row has all 0s or 1s, otherwise returns -1 */ public static int[] allRow(int[][] m) &#123; // Initilize array to hold results with -1 int[] result = new int[m.length]; for (int i = 0; i &lt; result.length; i++) &#123; result[i] = -1; &#125; int[] count = new int[2]; // Counts 0s and 1s for (int i = 0; i &lt; m.length; i++) &#123; // Initialize count array to 0; count[0] = 0; count[1] = 0; for (int j = 0; j &lt; m[i].length; j++) &#123; count[m[i][j]]++; if (count[0] &lt; j + 1 &amp;&amp; count[1] &lt; j + 1) &#123; break; &#125; &#125; if (count[0] &gt;= m.length || count[1] &gt;= m.length) result[i] = count[0] &gt; count[1] ? 0 : 1; &#125; return result; &#125; /** getMatrix prompts the user to enter the length of a square matrix and randomly fills in 0s and 1s into the matrix, then returns it */ public static int[][] getMatrix() &#123; Scanner input = new Scanner(System.in); System.out.print("Enter the size for the matrix: "); int size = input.nextInt(); int[][] m = new int[size][size]; for (int i = 0; i &lt; m.length; i++) &#123; for (int j = 0; j &lt; m[i].length; j++) &#123; m[i][j] = (int)(Math.random() * 2); &#125; &#125; return m; &#125; /** print displays all elements in a matrix */ public static void print(int[][] m) &#123; for (int i = 0; i &lt; m.length; i++) &#123; for (int j = 0; j &lt; m[i].length; j++) &#123; System.out.print(m[i][j]); &#125; System.out.println(); &#125; &#125;&#125; Exercise 39.1Test1234567891011121314151617181920212223242526272829303132333435363738394041424344/********************************************************************************** (The Rectangle class) Following the example of the Circle class in Section 9.2,** design a class named Rectangle to represent a rectangle. The class contains: ** ** ■ Two double data fields named width and height that specify the width and ** height of the rectangle. The default values are 1 for both width and height. ** ■ A no-arg constructor that creates a default rectangle. ** ■ A constructor that creates a rectangle with the specified width and height. ** ■ A method named getArea() that returns the area of this rectangle. ** ■ A method named getPerimeter() that returns the perimeter. ** ** Draw the UML diagram for the class and then implement the class. Write a test ** program that creates two Rectangle objects—one with width 4 and height 40 ** and the other with width 3.5 and height 35.9. Display the width, height, area, ** and perimeter of each rectangle in this order. **********************************************************************************/public class Exercise_09_01 &#123; /** Main method */ public static void main(String[] args) &#123; // Create a Rectangle with width 4 and height 40 Rectangle rectangle1 = new Rectangle(4, 40); // Create a Rectangle with width 3.5 and height 35.9 Rectangle rectangle2 = new Rectangle(3.5, 35.9); // Display the width, height, area, and perimeter of rectangle1 System.out.println("\n Rectangle 1"); System.out.println("-------------"); System.out.println("Width: " + rectangle1.width); System.out.println("Height: " + rectangle1.height); System.out.println("Area: " + rectangle1.getArea()); System.out.println("Perimeter: " + rectangle1.getPerimeter()); // Display the width, height, area, and perimeter of rectangle2 System.out.println("\n Rectangle 2"); System.out.println("-------------"); System.out.println("Width: " + rectangle2.width); System.out.println("Height: " + rectangle2.height); System.out.println("Area: " + rectangle2.getArea()); System.out.println("Perimeter: " + rectangle2.getPerimeter()); &#125;&#125; Rectangle12345678910111213141516171819202122232425262728293031323334353637383940//UML Class Diagram /*************************************************** Rectangle * * ------------------------------------------------* * width: double ** height: double * * Rectangle() * * Rectangle(newWidth: double, newHeight: double) ** getArea(): double ** getPerimeter(): double ****************************************************/// Define the Rectangle classpublic class Rectangle &#123; double width; // Width of rectangle double height; // Height of rectangle /** A no-arg constructor that creates a default rectangle */ Rectangle() &#123; width = 1; height = 1; &#125; /** A constructor that creates a rectangle with the specified width and height */ Rectangle(double newWidth, double newHeight) &#123; width = newWidth; height = newHeight; &#125; /** Return the area of this rectangle */ double getArea() &#123; return width * height; &#125; /** Return the perimeter of this rectangle */ double getPerimeter() &#123; return 2 * (width + height); &#125;&#125; 9.2Test123456789101112131415161718192021222324252627282930313233343536/********************************************************************************** (The Stock class) Following the example of the Circle class in Section 9.2, ** design a class named Stock that contains: ** ** ■ A string data field named symbol for the stock’s symbol. ** ■ A string data field named name for the stock’s name. ** ■ A double data field named previousClosingPrice that stores the stock ** price for the previous day. ** ■ A double data field named currentPrice that stores the stock price for the ** current time. ** ■ A constructor that creates a stock with the specified symbol and name. ** ■ A method named getChangePercent() that returns the percentage changed from ** previousClosingPrice to currentPrice. ** ** Draw the UML diagram for the class and then implement the class. Write a test ** program that creates a Stock object with the stock symbol ORCL, the name ** Oracle Corporation, and the previous closing price of 34.5. Set a new current ** price to 34.35 and display the price-change percentage. **********************************************************************************/public class Exercise_09_02 &#123; /** Main method */ public static void main(String[] args) &#123; // Create a Stock object with the stock // symbol ORCL, the name Oracle Corporation Stock stock = new Stock("ORCL", "Oracle Corporation"); stock.previousClosingPrice = 34.5; stock.currentPrice = 34.35; // Display the price-change percentage System.out.println("\nStock name: " + stock.name); System.out.println("Stock symbol: " + stock.symbol); System.out.printf("Price-change percentage: %.2f%%\n", stock.getChangePercent()); &#125;&#125; Stock12345678910111213141516171819202122232425262728293031//UML diagram /********************************************* Stock **-------------------------------------------** symbol: String ** name: String ** previousClosingPrice: double ** currentPrice: double ** Stock(newSymbol: String, newName: String) ** getChangePercent(): double *********************************************/// Define the stock classpublic class Stock &#123; String symbol; // The stock's symbol String name; // The stock's name double previousClosingPrice; // The stock price for the previous day double currentPrice; // The stock price for the current time // Construct a stock with a specified symbol and name Stock(String newSymbol, String newName) &#123; symbol = newSymbol; name = newName; &#125; // Return the percentage changed from previousClosingPrice to currentPrice double getChangePercent() &#123; return ((currentPrice - previousClosingPrice) / previousClosingPrice) * 100; &#125;&#125; 9.6Test123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869/********************************************************************************** (Stopwatch) Design a class named StopWatch. The class contains: ** ** ■ Private data fields startTime and endTime with getter methods. ** ■ A no-arg constructor that initializes startTime with the current time. ** ■ A method named start() that resets the startTime to the current time. ** ■ A method named stop() that sets the endTime to the current time. ** ■ A method named getElapsedTime() that returns the elapsed time for the ** stopwatch in milliseconds. ** ** Draw the UML diagram for the class and then implement the class. Write a test ** program that measures the execution time of sorting 100,000 numbers using ** selection sort. **********************************************************************************/public class Exercise_09_06 &#123; /** Main method */ public static void main(String[] args) &#123; // Create a StopWatch object StopWatch stopWatch = new StopWatch(); // create array of 100,000 random numbers int[] randomArray = getArray(); // Invoke the start method in StopWatch class stopWatch.start(); // Sort array selectionSort(randomArray); // Invoke the stop method in StopWatch class stopWatch.stop(); // Display the execution time System.out.println("The execution time of sorting 100,000 " + "numbers using selection sort: " + stopWatch.getElapsedTime() + " milliseconds"); &#125; /** getArray creates and returns an array of 100,000 random numbers */ public static int[] getArray() &#123; // Create an array of length 100,000 int[] array = new int[100000]; for (int i = 0; i &lt; array.length; i++) &#123; array[i] = (int)(Math.random() * 100000); &#125; return array; &#125; /** selectionSort performs a selection sort on an array */ public static void selectionSort(int[] array) &#123; for (int i = 0; i &lt; array.length - 1; i++) &#123; int min = array[i]; int minIndex = i; for (int j = i + 1; j &lt; array.length; j++) &#123; if (array[j] &lt; min) &#123; min = array[j]; minIndex = j; &#125; &#125; if (i != minIndex) &#123; array[minIndex] = array[i]; array[i] = min; &#125; &#125; &#125; &#125; StopWatch1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950/***************************** StopWatch **---------------------------** -startTime: long ** -endTime: long ** +StopWatch() ** +start() ** +stop() ** +getElapsedTime(): long ** +getStratTime(): long ** +getEndTime(): long *****************************/// Implement StopWatch classpublic class StopWatch &#123; private long startTime; // Start time private long endTime; // End time // no-arg constructor that initializes // startTime with the current time StopWatch() &#123; startTime = System.currentTimeMillis(); &#125; // Resets the startTime to the current time public void start() &#123; startTime = System.currentTimeMillis(); &#125; // Sets the endTime to the current time public void stop() &#123; endTime = System.currentTimeMillis(); &#125; // Returns the elapsed time for // the stopwatch in milliseconds public long getElapsedTime() &#123; return getEndTime() - getStratTime(); &#125; // Return start time public long getStratTime() &#123; return startTime; &#125; // Return end time public long getEndTime() &#123; return endTime; &#125;&#125; 9.9Test123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051/********************************************************************************** (Geometry: n-sided regular polygon) In an n-sided regular polygon, all sides ** have the same length and all angles have the same degree (i.e., the polygon is ** both equilateral and equiangular). Design a class named RegularPolygon that ** contains: ** ** ■ A private int data field named n that defines the number of sides in the ** polygon with default value 3. ** ■ A private double data field named side that stores the length of the side ** with default value 1. ** ■ A private double data field named x that defines the x-coordinate of the ** polygon’s center with default value 0. ** ■ A private double data field named y that defines the y-coordinate of the ** polygon’s center with default value 0. ** ■ A no-arg constructor that creates a regular polygon with default values. ** ■ A constructor that creates a regular polygon with the specified number of ** sides and length of side, centered at (0, 0). ** ■ A constructor that creates a regular polygon with the specified number of ** sides, length of side, and x- and y-coordinates. ** ■ The accessor and mutator methods for all data fields. ** ■ The method getPerimeter() that returns the perimeter of the polygon. ** ■ The method getArea() that returns the area of the polygon. The formula for ** computing the area of a regular polygon is Area = (n x s^2) / (4 x tan(π / n)** ** Draw the UML diagram for the class and then implement the class. Write a test ** program that creates three RegularPolygon objects, created using the no-arg ** constructor, using RegularPolygon(6, 4), and using RegularPolygon(10, 4, 5.6, ** 7.8). For each object, display its perimeter and area. **********************************************************************************/public class Exercise_09_09 &#123; /** Main method */ public static void main(String[] args) &#123; // Create three RegularPolygon objects RegularPolygon regularPolygon1 = new RegularPolygon(); RegularPolygon regularPolygon2 = new RegularPolygon(6, 4); RegularPolygon regularPolygon3 = new RegularPolygon(10, 4, 5.6, 7.8); // Display perimeter and area of each object System.out.println("\n--------------------------------------------------"); System.out.println("| Regular Polygon Objects | Perimeter | Area |"); System.out.println("--------------------------------------------------"); System.out.printf( "| Object# 1 |%8.2f |%6.2f |\n", regularPolygon1.getPerimeter(), regularPolygon1.getArea()); System.out.printf( "| Object# 2 |%8.2f |%6.2f |\n", regularPolygon2.getPerimeter(), regularPolygon2.getArea()); System.out.printf( "| Object# 3 |%8.2f |%6.2f |\n", regularPolygon3.getPerimeter(), regularPolygon3.getArea()); System.out.println("--------------------------------------------------"); &#125;&#125; RegularPolygon123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107// UML diagram/*************************************************************** RegularPolygon ***************************************************************** -n: int ** -side: double ** -x: double ** -y: double ** +RegularPolygon() ** +RegularPolygon(n: int, side: double) ** +RegularPolygon(n: int, side: double, x: double, y: double) ** +setN(newN: int) ** +setSide(newSide: double) ** +setX(newX: double) * * +setY(newY: double) * * +getN(): int ** +getSide(): double ** +getX(): double * * +getY(): double * * +getPerimeter(): double ** +getArea(): doulbe * **************************************************************/// Implement RegularPolygon classpublic class RegularPolygon &#123; /** Data fields */ private int n; private double side; private double x; private double y; /** Constructors */ /** Creates a regular polygon with default values */ RegularPolygon() &#123; n = 3; side = 1; x = y = 0; &#125; /** Creates a regular polygon with the specified number /* of sides and length of side, centered at (0, 0) */ RegularPolygon(int newN, double newSide) &#123; n = newN; side = newSide; x = y = 0; &#125; /** creates a regular polygon with the specified number /* of sides, length of side, and x- and y-coordinates */ RegularPolygon(int newN, double newSide, double newX, double newY) &#123; n = newN; side = newSide; x = newX; y = newY; &#125; /** Methods */ /** Sets new n */ public void setN(int newN) &#123; n = newN; &#125; /** Sets new length of the side */ public void setSide(double newSide) &#123; side = newSide; &#125; /** Sets new x-coordinate */ public void setX(double newX) &#123; x = newX; &#125; /** Sets new y-coordinate */ public void setY(double newY) &#123; y = newY; &#125; /** Returns n */ public int getN() &#123; return n; &#125; /** Returns the length of the side */ public double getSide() &#123; return side; &#125; /** Returns x-coordinate */ public double getX() &#123; return x; &#125; /** Returns y-coordinate */ public double getY() &#123; return y; &#125; /** Returns the perimeter of the polygon */ public double getPerimeter() &#123; return side * n; &#125; /** Returns the area of the polygon */ public double getArea() &#123; return (n * Math.pow(side, 2)) / (4 * Math.tan(Math.PI / n)); &#125;&#125; 9.13Test12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152/********************************************************************************** (The Location class) Design a class named Location for locating a maximal ** value and its location in a two-dimensional array. The class contains public ** data fields row, column, and maxValue that store the maximal value and its ** indices in a two-dimensional array with row and column as int types and ** maxValue as a double type. ** ** Write the following method that returns the location of the largest element in ** a two-dimensional array: ** ** public static Location locateLargest(double[][] a) ** ** The return value is an instance of Location. Write a test program that prompts ** the user to enter a two-dimensional array and displays the location of the ** largest element in the array. **********************************************************************************/import java.util.Scanner;public class Exercise_09_13 &#123; /** Main method */ public static void main(String[] args) &#123; // Create a Scanner object Scanner input = new Scanner(System.in); // Prompt the user to enter a two-dimensional array System.out.print("Enter the number of rows and columns in the array: "); int rows = input.nextInt(); int columns = input.nextInt(); // Create a matrix double[][] array = new double[rows][columns]; System.out.println("Enter the array: "); for (int i = 0; i &lt; array.length; i++) &#123; for (int j = 0; j &lt; array[i].length; j++) &#123; array[i][j] = input.nextDouble(); &#125; &#125; // Get and instance of Loacation Location max = locateLargest(array); // Display the location of the largest element in the array System.out.println("The location of the largest element is " + max.maxValue + " at (" + max.row + ", " + max.column + ")"); &#125; /** locateLargest returns an instance of Location */ public static Location locateLargest(double[][] a) &#123; return new Location(a); &#125;&#125; Location123456789101112131415161718192021222324252627282930313233// UML Diagram/******************************** Location **------------------------------** +row: int ** +column: int ** +maxValue: double ** +Location(array: double[][]) ********************************/// Implement Location classpublic class Location &#123; // Data fields int row; // Row index of maximal value int column; // Column index of maximal value double maxValue; // Maximal value /** Constructs a default Loction object */ Location(double[][] a) &#123; maxValue = a[0][0]; row = 0; column = 0; for (int i = 0; i &lt; a.length; i++) &#123; for (int j = 0; j &lt; a[i].length; j++) &#123; if (a[i][j] &gt; maxValue) &#123; maxValue = a[i][j]; row = i; column = j; &#125; &#125; &#125; &#125;&#125; Exercise 410.28 (book inside)12345public static String reverseStr(String orignalString)&#123; StringBuilder newString = new StringBuilder(orignalString); newString.reverse(); return newString.toString(); &#125; 10.29 (book inside)12345public static String deleteStr(String orignalString)&#123; StringBuilder newString = new StringBuilder(orignalString); newString.delete(4,10); return newString.toString();&#125; 10.1Test1234567891011121314151617181920212223242526272829303132333435363738394041/********************************************************************************** (The Time class) Design a class named Time. The class contains: ** ■ The data fields hour, minute, and second that represent a time. ** ■ A no-arg constructor that creates a Time object for the current time. (The ** values of the data fields will represent the current time.) ** ■ A constructor that constructs a Time object with a specified elapsed time ** since midnight, January 1, 1970, in milliseconds. (The values of the data ** fields will represent this time.) ** ■ A constructor that constructs a Time object with the specified hour, minute, ** and second. ** ■ Three getter methods for the data fields hour, minute, and second, ** respectively. ** ■ A method named setTime(long elapseTime) that sets a new time ** for the object using the elapsed time. For example, if the elapsed time is ** 555550000 milliseconds, the hour is 10, the minute is 19, and the second is ** 10. ** ** Draw the UML diagram for the class and then implement the class. Write ** a test program that creates two Time objects (using new Time() and new ** Time(555550000)) and displays their hour, minute, and second in the format ** hour:minute:second. ** (Hint: The first two constructors will extract the hour, minute, and second ** from the elapsed time. For the no-arg constructor, the current time can be ** obtained using System.currentTimeMillis(), as shown in Listing 2.7, ** ShowCurrentTime.java.) **********************************************************************************/public class Exercise_10_01 &#123; /** Main method */ public static void main(String[] args) &#123; // Create two Time objects Time time1 = new Time(); Time time2 = new Time(555550000); // Display Time objects hour, minute, and // second in the format hour:minute:second System.out.println(time1.getHour() + ":" + time1.getMinute() + ":" + time1. getSecond()); System.out.println(time2.getHour() + ":" + time2.getMinute() + ":" + time2. getSecond()); &#125;&#125; Time12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576 //UML diagram/************************************************* Time **-----------------------------------------------** -hour: long ** -minute: long ** -second: long ** Time() ** Time(elapseTime: long) ** Time(hour: long, minute: long, second: long) ** getHour(): long ** getMinute(): long ** getSecond(): long ** setTime(elapseTime: long) *************************************************/// Implement Time classpublic class Time &#123; // Data fields private long hour; private long minute; private long second; // Creates a Time object for the current time Time() &#123; this(0); &#125; // Constructs a Time object with a specified elapsed // time since midnight, January 1, 1970, in milliseconds. Time(long elapseTime) &#123; setTime(elapseTime); &#125; // Constructs a Time object with the specified hour, minute, and second Time(long hour, long minute, long second) &#123; this.hour = hour; this.minute = minute; this.second = second; &#125; // Return hour public long getHour() &#123; return hour; &#125; // Return minute public long getMinute() &#123; return minute; &#125; // Return second public long getSecond() &#123; return second; &#125; // Sets a new time for the object using the elapsed time public void setTime(long elapseTime) &#123; long totalMilliseconds = System.currentTimeMillis(); long totalSeconds = totalMilliseconds / 1000; second = totalSeconds % 60; long totalMinutes = totalSeconds / 60; minute = totalMinutes % 60; long totalHours = totalMinutes / 60; hour = totalHours % 24; if (elapseTime &gt; 0) &#123; totalSeconds = elapseTime / 1000; second += totalSeconds % 60; totalMinutes = totalSeconds / 60; minute += totalMinutes % 60; totalHours = totalMinutes / 60; hour += totalHours % 24; &#125; &#125;&#125; 10.4Test12345678910111213141516171819202122232425262728293031/********************************************************************************** (The MyPoint class) Design a class named MyPoint to represent a point with ** x- and y-coordinates. The class contains: ** ** ■ The data fields x and y that represent the coordinates with getter ** methods. ** ■ A no-arg constructor that creates a point (0, 0). ** ■ A constructor that constructs a point with specified coordinates. ** ■ A method named distance that returns the distance from this point to a ** specified point of the MyPoint type. ** ■ A method named distance that returns the distance from this point to ** another point with specified x- and y-coordinates. ** ** Draw the UML diagram for the class and then implement the class. Write a test ** program that creates the two points (0, 0) and (10, 30.5) and displays the ** distance between them. **********************************************************************************/public class Exercise_10_04 &#123; /** Main method */ public static void main(String[] args) &#123; // Create two points MyPoint point1 = new MyPoint(); MyPoint point2 = new MyPoint(10, 30.5); // Display the distance between point1 and point2 System.out.println("The distance between (" + point1.getX() + ", " + point1.getY() + ") and (" + point2.getX() + ", " + point2.getY() + ") is: " + point1.distance(point2)); &#125;&#125; MyPoint1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253/*********************************** MyPoint **---------------------------------** -x: double ** -y: double ** +MyPoint() ** +MyPoint(x: double, y: double) ** +getX(): double ** +getY(): double ** +distance(myPoint: MyPoint) ** +distance(x: double, y: double) ***********************************/// Implement MyPoint classpublic class MyPoint &#123; // Data fields private double x; private double y; /** Constructor that creates a point (0, 0) */ MyPoint() &#123; this(0, 0); &#125; /** Constructs a point with specified coordinates */ MyPoint(double x, double y) &#123; this.x = x; this.y = y; &#125; /** Return x */ public double getX() &#123; return x; &#125; /** Return y */ public double getY() &#123; return y; &#125; /** Returns the distance from this point to * a specified point of the MyPoint type */ public double distance(MyPoint myPoint) &#123; return Math.sqrt(Math.pow(myPoint.getX() - x, 2) + Math.pow(myPoint.getY() - y, 2)); &#125; /** Returns the distance from this point to another * point with specified x- and y-coordinates. */ public double distance(double x, double y) &#123; return distance(new MyPoint(x, y)); &#125;&#125; 10.7Test1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192/********************************************************************************** (Game: ATM machine) Use the Account class created in Programming Exercise ** 9.7 to simulate an ATM machine. Create ten accounts in an array with id ** 0, 1, . . . , 9, and initial balance $100. The system prompts the user to ** enter an id. If the id is entered incorrectly, ask the user to enter a correct ** id. Once an id is accepted, the main menu is displayed as shown in the sample ** run. You can enter a choice 1 for viewing the current balance, 2 for ** withdrawing money, 3 for depositing money, and 4 for exiting the main menu. ** Once you exit, the system will prompt for an id again. Thus, once the system ** starts, it will not stop. **********************************************************************************/import java.util.Scanner;public class Exercise_10_07 &#123; /** Main method */ public static void main(String[] args) &#123; // Create a Scanner Scanner input = new Scanner(System.in); // Create ten accounts in an array Account[] accounts = new Account[10]; // Initialize accounts with balance initialBalance(accounts); // Once the system starts, it will not stop do &#123; // Prompt user to enter an id System.out.print("Enter an id: "); int id = input.nextInt(); if (isValidID(id, accounts)) &#123; int choice; do &#123; // Get user choice choice = displayMainMenu(input); if (isTransaction(choice)) &#123; executeTransaction(choice, accounts, id, input); &#125; &#125; while (choice != 4); // If 4 exit main menu &#125; // Once you exit, the system will prompt for an id again &#125; while (true); &#125; /** Initialize accounts with balance of 100 */ public static void initialBalance(Account[] a) &#123; int initialBalance = 100; for (int i = 0; i &lt; a.length; i++) &#123; a[i] = new Account(i, initialBalance); &#125; &#125; /** Return true if choice is a transaction */ public static boolean isTransaction(int choice) &#123; return choice &gt; 0 &amp;&amp; choice &lt; 4; &#125; /** Return true if ID is valid */ public static boolean isValidID(int id, Account[] a) &#123; for (int i = 0; i &lt; a.length; i++) &#123; if (id == a[i].getId()) return true; &#125; return false; &#125; /** Display main menu */ public static int displayMainMenu(Scanner input) &#123; System.out.print( "\nMain menu\n1: check balance\n2: withdraw" + "\n3: deposit\n4: exit\nEnter a choice: "); return input.nextInt(); &#125; /** Execute a Transaction */ public static void executeTransaction( int c, Account[] a, int id, Scanner input) &#123; switch (c) &#123; case 1: // Viewing the current balance System.out.println("The balance is " + a[id].getBalance()); break; case 2: // Withdraw money System.out.print("Enter an amount to withdraw: "); a[id].withdraw(input.nextDouble()); break; case 3: // Deposit money System.out.print("Enter an amount to deposit: "); a[id].deposit(input.nextDouble()); &#125; &#125;&#125; Acount123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107/********************************************************* Account **-------------------------------------------------------** -id: int ** -balance: double ** -annualInterestRate: double ** --------------------------- ** -dateCreated: String ** +Account() ** +Account(newid: int, newBalance: double) ** +setId(newId: int) ** +setBalance(newBalance: double) ** +setAnnualInterestRate(newAnnualInterestRate: double) ** +getId(): int ** +getBalance(): double ** +getAnnualInterestRate(): double ** +getDateCreated(): String ** +getMonthlyInterestRate(): double ** +getMonthlyInterest(): double ** +withdraw(amount: double) ** +deposit(amount: double) *********************************************************/// Implement the Account classimport java.util.Date;public class Account &#123; // Data fields private int id; private double balance; private static double annualInterestRate; private Date dateCreated; // Constructors /** Creates a default account */ Account() &#123; id = 0; balance = 0; annualInterestRate = 0; dateCreated = new Date(); &#125; /** Creates an account with the specified id and initial balance */ Account(int newId, double newBalance) &#123; id = newId; balance = newBalance; dateCreated = new Date(); &#125; // Mutator methods /** Set id */ public void setId(int newId) &#123; id = newId; &#125; /** Set balance */ public void setBalance(double newBalance) &#123; balance = newBalance; &#125; /** Set annualInterestRate */ public void setAnnualInterestRate(double newAnnualInterestRate) &#123; annualInterestRate = newAnnualInterestRate; &#125; // Accessor methods /** Return id */ public int getId() &#123; return id; &#125; /** Return balance */ public double getBalance() &#123; return balance; &#125; /** Return annualInterestRate */ public double getAnnualInterestRate() &#123; return annualInterestRate; &#125; /** Return dateCreated */ public String getDateCreated() &#123; return dateCreated.toString(); &#125; /** Return monthly interest rate */ public double getMonthlyInterestRate() &#123; return annualInterestRate / 12; &#125; // Methods /** Return monthly interest */ public double getMonthlyInterest() &#123; return balance * (getMonthlyInterestRate() / 100); &#125; /** Decrease balance by amount */ public void withdraw(double amount) &#123; balance -= amount; &#125; /** Increase balance by amount */ public void deposit(double amount) &#123; balance += amount; &#125;&#125; 10.9Test12345678910111213141516171819202122232425262728293031323334353637/********************************************************************************** (The Course class) Revise the Course class as follows: ** ** ■ The array size is fixed in Listing 10.6. Improve it to automatically ** increase the array size by creating a new larger array and copying the ** contents of the current array to it. ** ■ Implement the dropStudent method. ** ■ Add a new method named clear() that removes all students from the ** course. ** ** Write a test program that creates a course, adds three students, removes one, ** and displays the students in the course. **********************************************************************************/public class Exercise_10_09 &#123; /** Main method */ public static void main(String[] args) &#123; // Create a course Course math101 = new Course("math101"); // Add three students math101.addStudent("Mark"); math101.addStudent("Tom"); math101.addStudent("Joan"); // remove one student math101.dropStudent("Tom"); // Displays the students in the course System.out.println("\nThe students in the course " + math101.getCourseName() + ":"); String[] students = math101.getStudents(); for (int i = 0; i &lt; math101.getNumberOfStudents(); i++) &#123; System.out.print(students[i] + " "); &#125; System.out.println(); &#125;&#125; Course1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374public class Course &#123; private String courseName; private String[] students = new String[1]; private int numberOfStudents; public Course(String courseName) &#123; this.courseName = courseName; &#125; public void addStudent(String student) &#123; // Automatically increases the array size if (numberOfStudents == students.length) &#123; String[] a = new String[students.length + 1]; for (int i = 0; i &lt; numberOfStudents; i++) &#123; a[i] = students[i]; &#125; students = a; &#125; students[numberOfStudents] = student; numberOfStudents++; &#125; public String[] getStudents() &#123; return students; &#125; public int getNumberOfStudents() &#123; return numberOfStudents; &#125; public String getCourseName() &#123; return courseName; &#125; /** Remove a student from a course */ public void dropStudent(String student) &#123; int index = findStudent(student); if (index &gt;= 0) &#123; dropStudent(index); &#125; else &#123; System.out.println(student + " is not in the course: " + courseName); &#125; &#125; /** deletes a Student */ private void dropStudent(int index) &#123; String[] s = new String[students.length - 1]; for (int i = 0, j = 0; i &lt; s.length; i++, j++) &#123; if (i == index) &#123; j++; &#125; s[i] = students[j]; &#125; this.students = s; numberOfStudents--; &#125; /** removes all students from the course */ public void clear() &#123; students = new String[1]; numberOfStudents = 0; &#125; /** Returns the index if student is found. Otherwise returns -1 */ private int findStudent(String student) &#123; for (int i = 0; i &lt; numberOfStudents; i++) &#123; if (students[i].equals(student)) &#123; return i; &#125; &#125; return -1; &#125;&#125; Exercise 511.11 (book inside)12345678910111213141516171819202122232425262728293031public class Circle &#123; private double radius; public Circle (double radius) &#123; //radius = radius;👇 this.radius = radius; &#125; public double getRadius() &#123; return radius; &#125; public double getArea() &#123; return radius * radius * Math.PI; &#125; class B extends Circle &#123; private double length; B(double radius, double length) &#123; //Circle(radius)👇 super(radius); length = length; &#125; @Override public double getArea() &#123; return getArea() * length; &#125; &#125;&#125; 11.20 (book inside)123456789101112131415161718public class Test&#123; public static void main(String[] args) &#123; Integer[] list1 = &#123;12, 24,55, 1&#125;; Double[] list2 = &#123;12.4, 24.0, 55.2, 1.0&#125;; //int[] list3 = &#123;1, 2, 3&#125;;👇 Object[] list3 = &#123;1, 2, 3&#125;; printArray(list1); printArray(list2); printArray(list3); &#125; public static void printArray(Object[] list) &#123; for (Object o: list) &#123; System.out.print(o + " "); &#125; System.out.println(); &#125;&#125; 11.2Test1234567891011121314151617181920212223242526272829303132333435363738394041/********************************************************************************** (The Person, Student, Employee, Faculty, and Staff classes) Design a ** class named Person and its two subclasses named Student and Employee. ** Make Faculty and Staff subclasses of Employee. A person has a name, ** address, phone number, and email address. A student has a class status ** (freshman, sophomore, junior, or senior). Define the status as a constant. An ** employee has an office, salary, and date hired. Use the MyDate class defined ** in Programming Exercise 10.14 to create an object for date hired. A faculty ** member has office hours and a rank. A staff member has a title. Override the ** toString method in each class to display the class name and the person’s name. ** Draw the UML diagram for the classes and implement them. Write a test program ** that creates a Person, Student, Employee, Faculty, and Staff, and invokes ** their toString() methods. **********************************************************************************/public class Exercise_11_02 &#123; // Main method public static void main(String[] args) &#123; // Create a Person, Student, Employee, Faculty, and Staff objects Person person = new Person("name", "adress", "123123123", "anymouse@any.com"); Student student = new Student("name2", "adress2", "1112333321", "anyone@qvq.com", Student.FRESHMAN); Employee employee = new Employee("name3", "Rift", "1008611", "nmsl@nm.com", 910, 60000); Faculty faculty = new Faculty("name4", "Loksas", "123123132", "xxxx@xx.com", 101, 50000, "4pm to 6pm", "Professor"); Staff staff = new Staff("Tom", "90 Country road", "2030000000", "tomcat@aol.com", 12, 65000, "Executive Assistant"); // Invoke toString of Person, Student, Employee, Faculty and Staff System.out.println(person.toString()); System.out.println(student.toString()); System.out.println(employee.toString()); System.out.println(faculty.toString()); System.out.println(staff.toString()); &#125;&#125; Employee1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162/******************************************************************** Employee **------------------------------------------------------------------** -office: int ** -salary: double ** -dateHired: MyDate ** +Employee(name: String, address: String, phone: String, ** email: String, office: int, salary: double, dateHired: MyDate); ** +getOffice(): int ** +getSalary(): double ** +getDateHired(): MyDate ** +setOffice(office: int): void ** +setSalary(salary: double): void ** +setDateHired(dateHired: MyDate): void ** +toString():String ********************************************************************/// Implement Employee classpublic class Employee extends Person &#123; private int office; private double salary; private MyDate dateHired; /** Construct Employee object */ public Employee(String name, String address, String phone, String email, int office, double salary) &#123; super(name, address, phone, email); this.office = office; this.salary = salary; this.dateHired = new MyDate(); &#125; /** Return office */ public int getOffice() &#123; return office; &#125; /** Return salaray */ public String getSalary() &#123; return String.format("%.2f", salary); &#125; /** Return date hired */ public String getDateHired() &#123; return dateHired.getMonth() + "/" + dateHired.getDay() + "/" + dateHired.getYear(); &#125; /** Set new office */ public void setOffice(int office) &#123; this.office = office; &#125; /** Set new salary */ public void setSalary(double salary) &#123; this.salary = salary; &#125; /** Set new dateHired */ public void setDateHired() &#123; dateHired = new MyDate(); &#125; /** Return a string discription of the class */ public String toString() &#123; return super.toString() + "\nOffice: " + office + "\nSalary: $" + getSalary() + "\nDate hired: " + getDateHired(); &#125;&#125; Faculty12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758/*********************************************************** Faculty **---------------------------------------------------------** -officeHours: int ** -rank: String ** +Faculty(name: String, address: String, phone: String, ** email: String, office: int, salary: double, ** officeHours: int, rank: String) ** +getOfficeHours(): int ** +setOfficeHours(officeHours: int): void ** +getRank(): String ** +setRank(rank: String): void ** +toString(): String ***********************************************************/// Implement Faculty classpublic class Faculty extends Employee &#123; // Data fields private String officeHours; private String rank; // Constructors /** Construct a Faculty object with specified name, address, phone number, * email address, office, salary, office hours and rank */ public Faculty(String name, String address, String phone, String email, int office, double salary, String officeHours, String rank) &#123; super(name, address, phone, email, office, salary); this.officeHours = officeHours; this.rank = rank; &#125; /** Return officeHours */ public String getOfficeHours() &#123; return officeHours; &#125; /** Set new officeHours */ public void setOfficeHours(String officeHours) &#123; this.officeHours = officeHours; &#125; /** Return rank */ public String getRank() &#123; return rank; &#125; /** Set new rank */ public void setRank(String rank) &#123; this.rank = rank; &#125; /** Return a string discription of the class */ public String toString() &#123; return super.toString() + "\nOffice hours: " + officeHours + "\nRank: " + rank; &#125;&#125; MyDate123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172/******************************************** MyDate **------------------------------------------** -year: int ** -month: int ** -day: int ** +MyDate() ** +MyDate(elapsedTime: long) ** +MyDate(year: int, month: int, day: int) ** +getYear(): int ** +getMonth(): int ** +getDay(): int ** +setDate(elapsedTime: long) ********************************************/import java.util.GregorianCalendar;// Implement MyDate classpublic class MyDate &#123; // Data Fields private int year; private int month; private int day; /** Creates a MyDate object for the current date */ MyDate() &#123; GregorianCalendar calander = new GregorianCalendar(); year = calander.get(GregorianCalendar.YEAR); month = calander.get(GregorianCalendar.MONTH); day = calander.get(GregorianCalendar.DAY_OF_MONTH); &#125; /** Creates a MyDate object with a specified elapsed time * since midnight, January 1, 1970, in milliseconds */ MyDate(long elapsedTime) &#123; setDate(elapsedTime); &#125; /** Creates a MyDate object with the * specified year, month, and day */ MyDate(int year, int month, int day) &#123; this.year = year; this.month = month; this.day = day; &#125; /** Return year */ public int getYear() &#123; return year; &#125; /** Return month */ public String getMonth() &#123; String m = String.valueOf(month + 1); return (month &lt; 10 ? "0" + m : m); &#125; /** Return day */ public String getDay() &#123; String d = String.valueOf(day); return (day &lt; 10 ? "0" + d : d); &#125; /** Sets a new date for the object using the elapsed time */ public void setDate(long elapsedTime) &#123; GregorianCalendar calander = new GregorianCalendar(); calander.setTimeInMillis(elapsedTime); year = calander.get(GregorianCalendar.YEAR); month = calander.get(GregorianCalendar.MONTH); day = calander.get(GregorianCalendar.DAY_OF_MONTH); &#125; &#125; Person1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586/****************************************** Person **----------------------------------------** -name: String ** -address: String ** -phone: String ** -email: String ** +Person() ** +Person(name: String, address: String, ** phone: String, email: String) ** +getName(): String ** +getAddress(): String ** +getPhone(): String ** +getEmail(): String ** +setName(name: String): void ** +setAddress(address: String): void ** +setPhone(phone: String): void ** +setEmail(email: String): void ** +toString(): String ******************************************/// Implement Person classpublic class Person &#123; private String name; private String address; private String phone; private String email; /** Construct default Person object */ public Person() &#123; this("Unknown","Unknown","Unknown","Unknown"); &#125; /** Construct Person object with specified name, address, phone and email */ public Person(String name, String address, String phone, String email) &#123; this.name = name; this.address = address; this.phone = phone; this.email = email; &#125; /** Return name */ public String getName() &#123; return name; &#125; /** Return address */ public String getAddress() &#123; return address; &#125; /** Return phone */ public String getPhone() &#123; return phone; &#125; /** Return email */ public String getEmail() &#123; return email; &#125; /** Set new name */ public void setName(String name) &#123; this.name = name; &#125; /** Set new address */ public void setAddress(String address) &#123; this.address = address; &#125; /** Set new phone number */ public void setPhone(String phone) &#123; this.phone = phone; &#125; /** Set new email */ public void setEmail(String email) &#123; this.email = email; &#125; /** Return a string discription of the class */ public String toString() &#123; return "\nName: " + name + "\nAddress: " + address + "\nPhone number: " + phone + "\nEmail address: " + email; &#125;&#125; Staff123456789101112131415161718192021222324252627282930313233343536373839/*********************************************************************** Staff **---------------------------------------------------------------------** -title: String ** +Staff(name: String, address: String, phone: String, email: String, ** office: int, salary: double, dateHired: MyDate, title: String) ** +getTitle(): String ** +setTitle(title: String): void ** +toString(): String ***********************************************************************/// Implement Staff classpublic class Staff extends Employee &#123; // Data Fields private String title; // Constructors /** Construct a Staff object */ public Staff(String name, String address, String phone, String email, int office, double salary, String title) &#123; super(name, address, phone, email, office, salary); this.title = title; &#125; /** Return title */ public String getTitle() &#123; return title; &#125; /** Set new title */ public void setTitle(String title) &#123; this.title = title; &#125; /** Return a string discription of the class */ public String toString() &#123; return super.toString() + "\nTitle: " + title; &#125;&#125; Student12345678910111213141516171819202122232425262728293031323334353637383940414243444546/************************************************** Student **------------------------------------------------** -status: String ** --------------- ** +Student(name: String, address: String, ** phone: String, email: String, status: String) ** +getStatus(): String ** +setStatus(status: String): void ** +toString(): String **************************************************/// Implement Student classpublic class Student extends Person &#123; private int status; public final static int FRESHMAN = 1; public final static int SOPHOMORE = 3; public final static int JUNIOR = 2; public final static int SENIOR = 4; public Student(String name, String address, String phone, String email, int status) &#123; super(name, address, phone, email); this.status = status; &#125; /** Set new status */ public void setStatus(int status) &#123; this.status = status; &#125; /** Return status */ public String getStatus() &#123; switch (status) &#123; case 1 : return "freshman"; case 2 : return "sophomore"; case 3 : return "junior"; case 4 : return "senior"; default : return "Unknown"; &#125; &#125; /** Return a string discription of the class */ public String toString() &#123; return super.toString() + "\nStatus: " + getStatus(); &#125;&#125; 11.3Test12345678910111213141516171819202122232425262728293031323334353637383940/********************************************************************************** (Subclasses of Account) In Programming Exercise 9.7, the Account class was ** defined to model a bank account. An account has the properties account number, ** balance, annual interest rate, and date created, and methods to deposit and ** withdraw funds. Create two subclasses for checking and saving accounts. A ** checking account has an overdraft limit, but a savings account cannot be ** overdrawn. ** ** Draw the UML diagram for the classes and then implement them. Write ** a test program that creates objects of Account, SavingsAccount, and ** CheckingAccount and invokes their toString() methods. **********************************************************************************/public class Exercise_11_03 &#123; // Main method public static void main(String[] args) &#123; // Create Account, SavingsAccount and Checking Account objects Account account = new Account(1122, 20000); SavingsAccount savings = new SavingsAccount(1001, 20000); CheckingAccount checking = new CheckingAccount(1004, 20000, -20); // Set annual interest rate of 4.5% account.setAnnualInterestRate(4.5); savings.setAnnualInterestRate(4.5); checking.setAnnualInterestRate(4.5); // Withdraw $2,500 account.withdraw(2500); savings.withdraw(2500); checking.withdraw(2500); // Deposit $3,000 account.deposit(3000); savings.deposit(3000); checking.deposit(3000); // Invoke toString methods System.out.println(account.toString()); System.out.println(savings.toString()); System.out.println(checking.toString()); &#125;&#125; Account123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112/********************************************************* Account **-------------------------------------------------------** -id: int ** -balance: double ** -annualInterestRate: double ** --------------------------- ** -dateCreated: String ** +Account() ** +Account(newid: int, newBalance: double) ** +setId(newId: int) ** +setBalance(newBalance: double) ** +setAnnualInterestRate(newAnnualInterestRate: double) ** +getId(): int ** +getBalance(): double ** +getAnnualInterestRate(): double ** +getDateCreated(): String ** +getMonthlyInterestRate(): double ** +getMonthlyInterest(): double ** +withdraw(amount: double) ** +deposit(amount: double) *********************************************************/// Implement the Account classimport java.util.Date;public class Account &#123; // Data fields private int id; private double balance; private static double annualInterestRate; private Date dateCreated; // Constructors /** Creates a default account */ Account() &#123; this(0, 0); &#125; /** Creates an account with the specified id and initial balance */ Account(int id, double balance) &#123; this.id = id; this.balance = balance; annualInterestRate = 0; dateCreated = new Date(); &#125; // Mutator methods /** Set id */ public void setId(int id) &#123; this.id = id; &#125; /** Set balance */ public void setBalance(double balance) &#123; this.balance = balance; &#125; /** Set annualInterestRate */ public void setAnnualInterestRate(double annualInterestRate) &#123; this.annualInterestRate = annualInterestRate; &#125; // Accessor methods /** Return id */ public int getId() &#123; return id; &#125; /** Return balance */ public double getBalance() &#123; return balance; &#125; /** Return annualInterestRate */ public double getAnnualInterestRate() &#123; return annualInterestRate; &#125; /** Return dateCreated */ public String getDateCreated() &#123; return dateCreated.toString(); &#125; /** Return monthly interest rate */ public double getMonthlyInterestRate() &#123; return annualInterestRate / 12; &#125; // Methods /** Return monthly interest */ public double getMonthlyInterest() &#123; return balance * (getMonthlyInterestRate() / 100); &#125; /** Decrease balance by amount */ public void withdraw(double amount) &#123; balance -= amount; &#125; /** Increase balance by amount */ public void deposit(double amount) &#123; balance += amount; &#125; /** Return a String decription of Account class */ public String toString() &#123; return "\nAccount ID: " + id + "\nDate created: " + getDateCreated() + "\nBalance: $" + String.format("%.2f", balance) + "\nMonthly interest: $" + String.format("%.2f", getMonthlyInterest()); &#125;&#125; CheckingAccount123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354/**************************************************************************** CheckingAccount **--------------------------------------------------------------------------** -overdraftLimit: double ** +CheckingAccount() ** +CheckingAccount(newId: int, newBalance: double, overdraftLimit: double) ** +setOverdraftLimit(overdraftLimit: double): void ** +getOverdraftLimit(): double ** +withdraw(amount: double): boolean ** +toString(): String *****************************************************************************/// Implement Checking classpublic class CheckingAccount extends Account &#123; // Data fields private double overdraftLimit; /** Construct a default CheckingAccount object */ public CheckingAccount() &#123; super(); overdraftLimit = -20; &#125; /** Construct a CheckingAccout with specified id, balance and overdraftLimit */ public CheckingAccount(int id, double balance, double overdraftLimit) &#123; super(id, balance); this.overdraftLimit = overdraftLimit; &#125; /** Set a new overdraft limit */ public void setOverdraftLimit(double overdraftLimit) &#123; this.overdraftLimit = overdraftLimit; &#125; /** Return overdraft limit */ public double getOverdraftLimit() &#123; return overdraftLimit; &#125; /** Decrease balance by amount */ public void withdraw(double amount) &#123; if (getBalance() - amount &gt; overdraftLimit) &#123; setBalance(getBalance() - amount); &#125; else System.out.println("Error! Amount exceeds overdraft limit."); &#125; /** Return a String decription of CheckingAccount class */ public String toString() &#123; return super.toString() + "\nOverdraft limit: $" + String.format("%.2f", overdraftLimit); &#125;&#125; SavingsAccount1234567891011121314151617181920212223242526272829/************************************** SavingsAccount **------------------------------------** +SavingsAccount() ** +withdraw(amount: double): boolean ***************************************/// Implement SavingsAccount classpublic class SavingsAccount extends Account &#123; /** Construct a default CheckingAccount object */ public SavingsAccount() &#123; super(); &#125; /** Construct a SavingsAccount with specified id, balance */ public SavingsAccount(int id, double balance) &#123; super(id, balance); &#125; /** Decrease balance by amount */ public void withdraw(double amount) &#123; if (amount &lt; getBalance()) &#123; setBalance(getBalance() - amount); &#125; else System.out.println( "Error! Savings account overdrawn transtaction rejected"); &#125;&#125; 11.13123456789101112131415161718192021222324252627282930313233343536373839404142434445464748/********************************************************************************** (Remove duplicates) Write a method that removes the duplicate elements from ** an array list of integers using the following header: ** ** public static void removeDuplicate(ArrayList&lt;Integer&gt; list) ** ** Write a test program that prompts the user to enter 10 integers to a list and ** displays the distinct integers separated by exactly one space. **********************************************************************************/import java.util.Scanner;import java.util.ArrayList;public class Exercise_11_13 &#123; /** Main method */ public static void main(String[] args) &#123; // Create a scanner Scanner input = new Scanner(System.in); // Create an ArrayList ArrayList&lt;Integer&gt; list = new ArrayList&lt;Integer&gt;(); // Prompt ther user to enter 10 integers System.out.print("Enter 10 integers: "); for (int i = 0; i &lt; 10; i++) &#123; list.add(input.nextInt()); &#125; // Invoke removeDuplicate method removeDuplicate(list); // Display the distinct integers System.out.print("The distinct integers are "); for (int i = 0; i &lt; list.size(); i++) &#123; System.out.print(list.get(i) + " "); &#125; System.out.println(); &#125; /** Removes the duplicate elements from an array list of integers */ public static void removeDuplicate(ArrayList&lt;Integer&gt; list) &#123; for (int i = 0; i &lt; list.size() - 1; i++) &#123; for (int j = i + 1; j &lt; list.size(); j++) &#123; if (list.get(i) == list.get(j)) list.remove(j); &#125; &#125; &#125;&#125; Exercise 613.1Test12345678910111213141516171819202122232425262728293031323334353637/********************************************************************************** (Triangle class) Design a new Triangle class that extends the abstract ** GeometricObject class. Draw the UML diagram for the classes Triangle and ** GeometricObject and then implement the Triangle class. Write a test program ** that prompts the user to enter three sides of the triangle, a color, and a ** Boolean value to indicate whether the triangle is filled. The program should ** create a Triangle object with these sides and set the color and filled ** properties using the input. The program should display the area, perimeter, ** color, and true or false to indicate whether it is filled or not. **********************************************************************************/import java.util.Scanner;public class Exercise_13_01 &#123; /** Main method */ public static void main(String[] args) &#123; // Create a Scanner Scanner input = new Scanner(System.in); // Prompt the user to enter three sides of a triangle a color // and a Boolean value to indicate whether the triangle is filled System.out.print("Enter three sides of the triangle: "); double side1 = input.nextDouble(); double side2 = input.nextDouble(); double side3 = input.nextDouble(); System.out.print("Enter a color: "); String color = input.next(); System.out.print("Is the triangle filled (true / false)? "); boolean filled = input.nextBoolean(); // Create a Triangle Triangle triangle = new Triangle(side1, side2, side3, color, filled); System.out.println(triangle); &#125;&#125; GeometricObject12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455public abstract class GeometricObject &#123; private String color = "white"; private boolean filled; private java.util.Date dateCreated; /** Construct a default geometric object */ protected GeometricObject() &#123; dateCreated = new java.util.Date(); &#125; /** Construct a geometric object with color and filled value */ protected GeometricObject(String color, boolean filled) &#123; dateCreated = new java.util.Date(); this.color = color; this.filled = filled; &#125; /** Return color */ public String getColor() &#123; return color; &#125; /** Set a new color */ public void setColor(String color) &#123; this.color = color; &#125; /** Return filled. Since filled is boolean, * the get method is named isFilled */ public boolean isFilled() &#123; return filled; &#125; /** Set a new filled */ public void setFilled(boolean filled) &#123; this.filled = filled; &#125; /** Get dateCreated */ public java.util.Date getDateCreated() &#123; return dateCreated; &#125; @Override public String toString() &#123; return "created on " + dateCreated + "\ncolor: " + color + " and filled: " + filled; &#125; /** Abstract method getArea */ public abstract double getArea(); /** Abstract method getPerimeter */ public abstract double getPerimeter();&#125; Triangle1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586/********************************************************** Triangle **--------------------------------------------------------** -side1: double ** -side2: double ** -side3: double **--------------------------------------------------------** +Triangle() ** +Triangle(side1: double, side2: double, side3: double) ** +Triangle(side1: double, side2: double, side3: double, ** color: string, filled: boolean) ** +getSide1(): double ** +getSide2(): double ** +getSide3(): double ** +setSide1(side1: double): void ** +setSide2(side2: double): void ** +setSide3(side3: double): void **********************************************************/public class Triangle extends GeometricObject &#123; private double side1; private double side2; private double side3; public Triangle()&#123; &#125; public Triangle(double side1, double side2, double side3) &#123; this.side1 = side1; this.side2 = side2; this.side3 = side3; &#125; public Triangle(double side1, double side2, double side3, String color, boolean filled) &#123; this(side1, side2, side3); setColor(color); setFilled(filled); &#125; /** Return side1 */ public double getSide1() &#123; return side1; &#125; /** Set side1 to a new lentgh */ public void setSide1(double side1) &#123; this.side1 = side1; &#125; /** Return side2 */ public double getSide2() &#123; return side2; &#125; /** Set side2 to a new lentgh */ public void setSide2(double side2) &#123; this.side2 = side2; &#125; /** Return side3 */ public double getSide3() &#123; return side3; &#125; /** Set side3 to a new lentgh */ public void setSide3(double side3) &#123; this.side3 = side3; &#125; @Override /** Return area of this Triangle */ public double getArea() &#123; double s = (side1 + side2 + side3) / 2; return Math.sqrt(s * (s - side1) * (s - side2) * (s - side3)); &#125; @Override /** Return perimeter of this triangle */ public double getPerimeter() &#123; return side1 + side2 + side3; &#125; @Override /** Return a string discription of the object */ public String toString() &#123; return super.toString() + "\nArea: " + getArea() + "\nPerimeter: " + getPerimeter(); &#125;&#125; 13.5Test123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354/********************************************************************************** (Enable GeometricObject comparable) Modify the GeometricObject class to ** implement the Comparable interface, and define a static max method in the ** GeometricObject class for finding the larger of two GeometricObject objects. ** Draw the UML diagram and implement the new GeometricObject class. Write a test ** program that uses the max method to find the larger of two circles and the ** larger of two rectangles. **********************************************************************************/public class Exercise_13_05 &#123; /** Main method */ public static void main(String[] args) &#123; // Create two Circle objects Circle circle1 = new Circle(15, "red", true); Circle circle2 = new Circle(10, "blue", false); // Display circle1 System.out.println("\nCircle 1: "); print(circle1); // Display circle2 System.out.println("\nCircle 2: "); print(circle2); // Display larger circle print("\nThe larger of the two circles was "); print(Circle.max(circle1, circle2)); // Create two Rectangle objects Rectangle rectangle1 = new Rectangle(4, 5, "green", true); Rectangle rectangle2 = new Rectangle(4.2, 5, "orange", true); // Display circle1 System.out.println("\nRectangle 1: "); print(circle1); // Display circle2 System.out.println("\nRectangle 2: "); print(circle2); // Display larger circle print("\nThe larger of the two rectangles was "); print(Rectangle.max(rectangle1, rectangle2)); &#125; // Displays a string public static void print(String s) &#123; System.out.println(s); &#125; // Displays a GeometricObject public static void print(GeometricObject o) &#123; System.out.println(o); &#125;&#125; Circle12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849public class Circle extends GeometricObject &#123; private double radius; public Circle() &#123; &#125; public Circle(double radius) &#123; this.radius = radius; &#125; public Circle(double radius, String color, boolean filled) &#123; this.radius = radius; setColor(color); setFilled(filled); &#125; /** Return radius */ public double getRadius() &#123; return radius; &#125; /** Set a new radius */ public void setRadius(double radius) &#123; this.radius = radius; &#125; @Override /** Return area */ public double getArea() &#123; return radius * radius * Math.PI; &#125; /** Return diameter */ public double getDiameter() &#123; return 2 * radius; &#125; @Override /** Return perimeter */ public double getPerimeter() &#123; return 2 * radius * Math.PI; &#125; @Override /** Return String discription of Circle object */ public String toString() &#123; return super.toString() + "\nRadius: " + radius + "\nArea: " + getArea() + "\nDiameter: " + getDiameter() + "\nPerimeter: " + getPerimeter(); &#125;&#125; GeometricObject1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192/*************************************************** GeometricObject **-------------------------------------------------** -color: String ** -filled: boolean ** -dateCreated: java.util.Date **-------------------------------------------------** GeometricObject() ** GeometricObject(color: String, filled: boolean) ** +getColor(): String ** +setColor(color: String): void ** +isFilled(): boolean ** +setFilled(filled: boolean): void * * +getDateCreated(): java.util.Date ** +getMax(GeometricObject: o1, ** --------------------------- ** GeometricObject: o2): GeometricObject ** -------------------- ** +getArea(): double ** +getPerimeter(): double ***************************************************/public abstract class GeometricObject implements Comparable&lt;GeometricObject&gt; &#123; private String color = "while"; private boolean filled; private java.util.Date dateCreated; /** Construct a default geometric object */ protected GeometricObject() &#123; dateCreated = new java.util.Date(); &#125; /** Construct a geometric object with color and filled value */ protected GeometricObject(String color, boolean filled) &#123; dateCreated = new java.util.Date(); this.color = color; this.filled = filled; &#125; /** Return color */ public String getColor() &#123; return color; &#125; /** Set a new color */ public void setColor(String color) &#123; this.color = color; &#125; /** Return filled. Since filled is boolean, * the get method is named isFilled */ public boolean isFilled() &#123; return filled; &#125; /** Set a new filled */ public void setFilled(boolean filled) &#123; this.filled = filled; &#125; /** Get dateCreated */ public java.util.Date getDateCreated() &#123; return dateCreated; &#125; @Override public String toString() &#123; return "created on " + dateCreated + "\ncolor: " + color + " and filled: " + filled; &#125; @Override // Implement the compareTo method defined in Comparable public int compareTo(GeometricObject o) &#123; if (this.getArea() &gt; o.getArea()) return 1; else if (this.getArea() &lt; o.getArea()) return -1; else return 0; &#125; /** Abstract method getMax */ public static GeometricObject max(GeometricObject o1, GeometricObject o2) &#123; return o1.compareTo(o2) == 1 ? o1 : o2; &#125; /** Abstract method getArea */ public abstract double getArea(); /** Abstract method getPerimeter */ public abstract double getPerimeter();&#125; Rectangle12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758public class Rectangle extends GeometricObject &#123; private double width; private double height; public Rectangle() &#123; &#125; public Rectangle( double width, double height) &#123; this.width = width; this.height = height; &#125; public Rectangle( double width, double height, String color, boolean filled) &#123; this.width = width; this.height = height; setColor(color); setFilled(filled); &#125; /** Return width */ public double getWidth() &#123; return width; &#125; /** Set a new width */ public void setWidth(double width) &#123; this. width = width; &#125; /** Return height */ public double getheight() &#123; return height; &#125; /** Set a new height */ public void setheight(double height) &#123; this.height = height; &#125; @Override /** Return area */ public double getArea() &#123; return width * height; &#125; @Override /** Return perimeter */ public double getPerimeter() &#123; return 2 * (width * height); &#125; @Override /** Return String discription of this rectangle */ public String toString() &#123; return super.toString() + "\nWidth: " + width + "\nHeight: " + height + "\nArea: " + getArea() + "\nPerimeter: " + getPerimeter(); &#125;&#125; 13.10Test1234567891011121314151617181920212223242526/********************************************************************************** (Enable Rectangle comparable) Rewrite the Rectangle class in Listing 13.3 to ** extend GeometricObject and implement the Comparable interface. Override the ** equals method in the Object class. Two Rectangle objects are equal if their ** areas are the same. Draw the UML diagram that involves Rectangle, ** GeometricObject, and Comparable. **********************************************************************************/public class Exercise_13_10 &#123; /** Main method */ public static void main(String[] args) &#123; // Create three Rectangle objects Rectangle r1 = new Rectangle(3, 5, "blue", true); Rectangle r2 = new Rectangle(5, 3, "gray", false); Rectangle r3 = new Rectangle(3.1, 5, "blue", true); System.out.println("Rectangle1 Area :" + r1.getArea()); System.out.println("Rectangle2 Area :" + r2.getArea()); System.out.println("Rectangle3 Area :" + r3.getArea()); System.out.println("Rectangle1 is " + (r1.equals(r2) ? "" : "not ") + "equal to Rectangle2"); System.out.println("Rectangle1 is " + (r1.equals(r3) ? "" : "not ") + "equal to Rectangle3"); &#125;&#125; GeometricObject1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556public abstract class GeometricObject &#123; private String color = "while"; private boolean filled; private java.util.Date dateCreated; /** Construct a default geometric object */ protected GeometricObject() &#123; dateCreated = new java.util.Date(); &#125; /** Construct a geometric object with color and filled value */ protected GeometricObject(String color, boolean filled) &#123; dateCreated = new java.util.Date(); this.color = color; this.filled = filled; &#125; /** Return color */ public String getColor() &#123; return color; &#125; /** Set a new color */ public void setColor(String color) &#123; this.color = color; &#125; /** Return filled. Since filled is boolean, * the get method is named isFilled */ public boolean isFilled() &#123; return filled; &#125; /** Set a new filled */ public void setFilled(boolean filled) &#123; this.filled = filled; &#125; /** Get dateCreated */ public java.util.Date getDateCreated() &#123; return dateCreated; &#125; @Override public String toString() &#123; return "created on " + dateCreated + "\ncolor: " + color + " and filled: " + filled; &#125; /** Abstract method getArea */ public abstract double getArea(); /** Abstract method getPerimeter */ public abstract double getPerimeter();&#125; Rectangle12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273public class Rectangle extends GeometricObject implements Comparable&lt;Rectangle&gt; &#123; private double width; private double height; public Rectangle() &#123; &#125; public Rectangle( double width, double height) &#123; this.width = width; this.height = height; &#125; public Rectangle( double width, double height, String color, boolean filled) &#123; this.width = width; this.height = height; setColor(color); setFilled(filled); &#125; /** Return width */ public double getWidth() &#123; return width; &#125; /** Set a new width */ public void setWidth(double width) &#123; this. width = width; &#125; /** Return height */ public double getheight() &#123; return height; &#125; /** Set a new height */ public void setheight(double height) &#123; this.height = height; &#125; @Override /** Return area */ public double getArea() &#123; return width * height; &#125; @Override /** Return perimeter */ public double getPerimeter() &#123; return 2 * (width * height); &#125; @Override /** Implement compareTo method */ public int compareTo(Rectangle o) &#123; if (getArea() &gt; o.getArea()) return 1; else if (getArea() &lt; o.getArea()) return -1; else return 0; &#125; @Override /** Return true if both objects are equal */ public boolean equals(Object o) &#123; return this.compareTo((Rectangle)o) == 0; &#125; @Override /** Return String discription of this rectangle */ public String toString() &#123; return super.toString() + "\nWidth: " + width + "\nHeight: " + height + "\nArea: " + getArea() + "\nPerimeter: " + getPerimeter(); &#125;&#125; 13.13Test123456789101112131415161718192021222324252627282930313233343536373839/********************************************************************************** (Enable the Course class cloneable) Rewrite the Course class in Listing 10.6 ** to add a clone method to perform a deep copy on the students field. **********************************************************************************/public class Exercise_13_13 &#123; public static void main(String[] args) throws CloneNotSupportedException &#123; // Create a course object Course course1 = new Course("Data Structures"); // Add three students to course1 course1.addStudent("Peter Jones"); course1.addStudent("Kim Smith"); course1.addStudent("Anne kennedy"); // Clone course1 Course course2 = course1.clone(); // Add three students to course2 course2.addStudent("Jamal Jones"); course2.addStudent("Steve Smith"); // Display students in course1 System.out.println("\nNumber of students in course1: " + course1.getNumberOfStudents()); String[] students = course1.getStudents(); for (int i = 0; i &lt; course1.getNumberOfStudents(); i++) System.out.print(students[i] + ", "); System.out.println(); // Display students in course2 System.out.println("\nNumber of students in course2: " + course2.getNumberOfStudents()); String[] students2 = course2.getStudents(); for (int i = 0; i &lt; course2.getNumberOfStudents(); i++) System.out.print(students2[i] + ", "); System.out.println(); &#125;&#125; Course12345678910111213141516171819202122232425262728293031323334353637383940public class Course implements Cloneable &#123; private String courseName; private String[] students = new String[100]; private int numberOfStudents; public Course(String courseName) &#123; this.courseName = courseName; &#125; public void addStudent(String student) &#123; students[numberOfStudents] = student; numberOfStudents++; &#125; public String[] getStudents() &#123; return students; &#125; public int getNumberOfStudents() &#123; return numberOfStudents; &#125; public String getCourseName() &#123; return courseName; &#125; @Override /** Override the proceted clone method defined in the Object class, and strengthen its accessibility */ public Course clone() throws CloneNotSupportedException &#123; // Perform a shallow copy Course courseClone = (Course)super.clone(); // Deep copy on students courseClone.students = students.clone(); return courseClone; &#125; public void dropStudent(String student) &#123; // Left as an exercise in Programming Exercise 10.9 &#125;&#125; 13.17Test123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687/********************************************************************************** (Math: The Complex class) A complex number is a number in the form a + bi, ** where a and b are real numbers and i is 2-1. The numbers a and b are known as ** the real part and imaginary part of the complex number, respectively. You can ** perform addition, subtraction, multiplication, and division for complex ** numbers using the following formulas: ** ** a + bi + c + di = (a + c) + (b + d)i ** a + bi - (c + di) = (a - c) + (b - d)i ** (a + bi)*(c + di) = (ac - bd) + (bc + ad)i ** (a + bi)/(c + di) = (ac + bd)/(c2 + d2) + (bc - ad)i/(c2 + d2) ** ** You can also obtain the absolute value for a complex number using the ** following formula: ** ** |a + bi| = √(a^2 + b^2) ** ** (A complex number can be interpreted as a point on a plane by identifying the ** (a,b) values as the coordinates of the point. The absolute value of the ** complex number corresponds to the distance of the point to the origin, as ** shown in Figure 13.10b.) ** ** Design a class named Complex for representing complex numbers and the methods ** add, subtract, multiply, divide, and abs for performing complexnumber ** operations, and override toString method for returning a string representation ** for a complex number. The toString method returns (a + bi) as a string. If b ** is 0, it simply returns a. Your Complex class should also implement the ** Cloneable interface. ** ** Provide three constructors Complex(a, b), Complex(a), and Complex(). Complex() ** creates a Complex object for number 0 and Complex(a) creates a Complex object ** with 0 for b. Also provide the getRealPart() and getImaginaryPart() methods ** for returning the real and imaginary part of the complex number, respectively. ** ** Write a test program that prompts the user to enter two complex numbers and ** displays the result of their addition, subtraction, multiplication, division, ** and absolute value. **********************************************************************************/import java.util.Scanner;public class Exercise_13_17 &#123; /** Main method */ public static void main(String[] args) throws CloneNotSupportedException &#123; // Prompt the user to enter two complex numbers System.out.print(&quot;Enter the first complex number: &quot;); Complex complexNumber1 = getComplex(); System.out.print(&quot;Enter the second complex number: &quot;); Complex complexNumber2 = getComplex(); // displays the result of their addition, subtraction, // multiplication, division, and absolute value System.out.print(complexNumber1 + &quot; + &quot; + complexNumber2 + &quot; = &quot;); print(complexNumber1.add(complexNumber2)); System.out.print(complexNumber1 + &quot; - &quot; + complexNumber2 + &quot; = &quot;); print(complexNumber1.subtract(complexNumber2)); System.out.print(complexNumber1 + &quot; * &quot; + complexNumber2 + &quot; = &quot;); print(complexNumber1.multiply(complexNumber2)); System.out.print(complexNumber1 + &quot; / &quot; + complexNumber2 + &quot; = &quot;); print(complexNumber1.divide(complexNumber2)); System.out.println(&quot;|&quot; + complexNumber1 + &quot;| = &quot; + complexNumber1.abs()); &#125; /** Display result */ public static void print(Complex n) &#123; if (n.getImaginaryPart() == 0) System.out.println(n.getRealPart()); else System.out.println(n.getRealPart() + &quot; + &quot; + n.getImaginaryPart() + &quot;i&quot;); &#125; /** Return user input as a complex number */ public static Complex getComplex() &#123; // Create a Scanner object Scanner input = new Scanner(System.in); double[] c = new double[2]; for (int i = 0; i &lt; c.length; i++) c[i] = input.nextDouble(); return new Complex(c[0], c[1]); &#125;&#125; Complex123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475public class Complex implements Cloneable &#123; private double a; private double b; // Constructors /** Creates a complex object for number 0 */ public Complex() &#123; this(0, 0); &#125; /** Create a complex object with 0 for b */ public Complex(double a) &#123; this(a, 0); &#125; /** Creates a complex object with specified a and b */ public Complex(double a, double b) &#123; this.a = a; this.b = b; &#125; // Methods /** Return real part of complex number */ public double getRealPart() &#123; return a; &#125; /** Return imaginary part of complex number */ public double getImaginaryPart() &#123; return b; &#125; /** Add a complex number to this complex number */ public Complex add(Complex secondComplex) &#123; return new Complex(a + secondComplex.a, b + secondComplex.b); &#125; /** Subtract a complex number from this complex number */ public Complex subtract(Complex secondComplex) &#123; return new Complex(a - secondComplex.a, b - secondComplex.b); &#125; /** Multiply a complex number by this complex number */ public Complex multiply(Complex secondComplex) &#123; return new Complex(a * secondComplex.a - b * secondComplex.b, b * secondComplex.a + a * secondComplex.b); &#125; /** Divide a complex number by this complex number */ public Complex divide(Complex secondComplex) &#123; return new Complex((a * secondComplex.a + b * secondComplex.b) / (Math.pow(secondComplex.a, 2) + Math.pow(secondComplex.b, 2)), (b * secondComplex.a - a * secondComplex.b) / (Math.pow(secondComplex.a, 2) + Math.pow(secondComplex.b, 2))); &#125; /** Returns the absolute value of this complex number */ public double abs() &#123; return Math.sqrt(Math.pow(a, 2) + Math.pow(b, 2)); &#125; @Override /** Override the protectec clone method defined in the Object class, and strengthen its accexxibility */ public Complex clone() throws CloneNotSupportedException &#123; return (Complex)super.clone(); &#125; @Override /** Retrun a string description of this complex number */ public String toString() &#123; return b == 0 ? a + "" : "(" + a + " + " + b + "i)"; &#125;&#125;]]></content>
      <tags>
        <tag>Java Homework</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[How to Convert a Caffe Model to a .mlmodel File]]></title>
    <url>%2F2018%2F03%2FHow-to-Convert-a-Caffe-Model-to-a-mlmodel-File%2F</url>
    <content type="text"><![CDATA[Recommend reading on the computer Before StartThe purpose of this article is to introduce how to use Apple’s Core ML Tools (hereafter referred to as CMT) to convert Caffe’s model to a .mlmodel file. Caffe is a framework for deep learning. If you want to know more about it, you can go to Caffe’s official website and you won’t see any details here. Install PythonAs a Python tool, CMT first has to have a Python environment. If you have already installed Python 2.7, this step can be skipped; Python environment can be Download Here Here you will find that Python has two versions, one is 2.7 and another is 3.6. In general, I would suggest that you should go straight to install the 3.6 version, but this time it is different because CMT this weird thing can only supports Python 2.7, so you must download the 2.7 version Install VirtualenvVirtualenv is a tool for creating isolated Python environments. All of our subsequent operations need to be done in the virtual environment which is created by this stuff. This step is not an optional step. Without this step,your Python environments will crash. (The word “virtual environment” is not as nice as it sounds. It’s better to change the name. I called this Reality Marble. Now open Terminal Pip install virtualenv Since everything was installed before, it would be normal if your output was different from mine, as long as a “successful installation” can be achieved. Create a Reality MarbleEnter the following two lines of command: virtualenv -p /usr/bin/python2.7 source env/bin/activate The first line creates an Reality Marble named “env” with a Python version of 2.7. The name of the Reality Marble is set by yourself, and you can change the name as your wish. The second line enters the Reality Marble. After entering the Reality Marble, you can see that there is more (env) in the front line. This is the sign that enters Reality Marble. Install CoremltoolsEnter the following line of command: Pip install coremltools Waiting for installationWaiting for the installation time is relatively boring, this time you can go to Caffe’s model .There is a list of ready-to-use models. I used Oxford102 in this article here. This is a model for identifying flower species. Here I will introduce this Caffe model. class_labels.txt: It contains all the forecast results Deploy.prototxt: This document describes the neural network structure of this model Oxford102.caffemodel: This is a data training model in Caffe format Why should I say this first? This is because you can only find the download address of .caffemodel directly on this page. You cannot find two other files. If you want a .prototxt file, you need to go to AlexNet . What about class_labels.txt? This is not readily available. There is only one class_labels.py in the root directory. You need to change the contents of this file to the following, and then change the suffix name to txt. Conversion CodeAfter you get these three files and finish installing coremltools, you can write the conversion code. import coremltools The first line refers to the coremltools you just installed. coreml_model = coremltools.converters.caffe.convert((‘oxford102.caffemodel’, ‘deploy.prototxt’), image_input_names=’data’, class_labels=’class_labels.txt’) The second line is to convert the Caffe model ,image_input names=’data’ means to set the input data type to image. coreml_model.save(‘Flowers.mlmodel’) The third line names the file Flowers.mlmodel and saves RunNow put the written Python file in the same folder as the three files. Then cd to this folder in Terminal. Then use python converter.py Although there are only three lines of code, but the conversion time is very long. You will get this after the conversion: Then you just throw it into the project and use it. Close Reality Marbleinput the command: deactivate This article does not introduce but is also worth learning about CMT convertible model type Other framework conversion methods Perfection of the basic information of the converted model …… Referencehttps://goo.gl/YYH8Yh]]></content>
      <tags>
        <tag>Python</tag>
        <tag>Deep Learning</tag>
        <tag>CMT</tag>
        <tag>Virtualenv</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Guide on Packaging and Import 3rd party plugins to Chrome]]></title>
    <url>%2F2018%2F03%2FGuide-on-Packaging-and-Import-3rd-party-plugins-to-Chrome%2F</url>
    <content type="text"><![CDATA[It’s been a loooooong time since the last update. Just cause I’m too lazy. XP.And now,I will use English as much as I can. TL;DRChrome removed many 3rd party plugins from Chrome App Store due to some unknown Python transaction recently. Due to security reason Chrome will disable extensions import locally with unknown source. You will get annoying popups every time launching Chrome if unpacked extensions are loaded. So in this thread I’ll provide a better solution to load 3rd party plugins with the latest build using Windows Group Policy or using configuration profiles for macOS. Package the extension This step is unnecessary if you have the complied version. Launch Chrome, open chrome://extensions, click Pack extension on top-left. Browse the code you just downloaded, click Pack Extension. The newly built extension will be found in the source folder with a *.pem file, keep them all, you will need that .pem file if you want to update the extension in the furture. Drag the *.crx file to the chrome://extension page to install it. Select the Developer Modecheckbox to show the hidden extension ID, save it somewhere. Apply Chrome policy using Group Policy EditorSee For MacOS Users if you are using MacOS. Download the zip file of Chrome templates from here. Extract the following files or folders into %SystemRoot%\PolicyDefinitions: ./Windows/admx/chrome.admx; ./Windows/admx/google.admx; ./Windows/admx/en-US/; ./Windows/admx/zh-CN. Press Win+R and run: gpedit.msc. A sub-folder named Google / Google Chrome can be found under Local Computer Policy &gt; Computer Configuration &gt; Administrative Templates. (Ps. The group policy editor is not embeded with starter and home editions. Follow this guide to install it first. (Thanks @metafaniel for refering this issue.)) Add the extension ID to whitelistAdd the extension ID by the following steps: Navigate to Administrative Templates / Google / Google Chrome / Extensions section. Double click to open Configure extension installation whitelist on the right side. Enable the policy and click Show... to add the extension ID. The extension will be enabled by default after Chrome relaunched. For MacOS UsersThis solution inspired by free1x, thanks. Download the following policy template. Download configuration profiles Now OR copy this 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd"&gt;&lt;plist version="1.0"&gt;&lt;dict&gt; &lt;key&gt;PayloadContent&lt;/key&gt; &lt;array&gt; &lt;dict&gt; &lt;key&gt;PayloadContent&lt;/key&gt; &lt;dict&gt; &lt;key&gt;com.google.Chrome&lt;/key&gt; &lt;dict&gt; &lt;key&gt;Forced&lt;/key&gt; &lt;array&gt; &lt;dict&gt; &lt;key&gt;mcx_preference_settings&lt;/key&gt; &lt;dict&gt; &lt;key&gt;ExtensionInstallWhitelist&lt;/key&gt; &lt;array&gt; &lt;string&gt;value01&lt;/string&gt; &lt;string&gt;value02&lt;/string&gt; &lt;string&gt;value03&lt;/string&gt; &lt;/array&gt; &lt;/dict&gt; &lt;/dict&gt; &lt;/array&gt; &lt;/dict&gt; &lt;/dict&gt; &lt;key&gt;PayloadEnabled&lt;/key&gt; &lt;true/&gt; &lt;key&gt;PayloadIdentifier&lt;/key&gt; &lt;string&gt;MCXToProfile.7e2bec75-299e-44ff-b405-628007abffff.alacarte.customsettings.bdac4880-d25f-4cdd-8472-05473f005e7e&lt;/string&gt; &lt;key&gt;PayloadType&lt;/key&gt; &lt;string&gt;com.apple.ManagedClient.preferences&lt;/string&gt; &lt;key&gt;PayloadUUID&lt;/key&gt; &lt;string&gt;bdac4880-d25f-4cdd-8472-05473f005e7e&lt;/string&gt; &lt;key&gt;PayloadVersion&lt;/key&gt; &lt;integer&gt;1&lt;/integer&gt; &lt;/dict&gt; &lt;/array&gt; &lt;key&gt;PayloadDescription&lt;/key&gt; &lt;string&gt;Included custom settings:com.google.Chrome&lt;/string&gt; &lt;key&gt;PayloadDisplayName&lt;/key&gt; &lt;string&gt;MCXToProfile: com.google.Chrome&lt;/string&gt; &lt;key&gt;PayloadIdentifier&lt;/key&gt; &lt;string&gt;com.google.Chrome&lt;/string&gt; &lt;key&gt;PayloadOrganization&lt;/key&gt; &lt;string&gt;&lt;/string&gt; &lt;key&gt;PayloadRemovalDisallowed&lt;/key&gt; &lt;true/&gt; &lt;key&gt;PayloadScope&lt;/key&gt; &lt;string&gt;System&lt;/string&gt; &lt;key&gt;PayloadType&lt;/key&gt; &lt;string&gt;Configuration&lt;/string&gt; &lt;key&gt;PayloadUUID&lt;/key&gt; &lt;string&gt;7e2bec75-299e-44ff-b405-628007abffff&lt;/string&gt; &lt;key&gt;PayloadVersion&lt;/key&gt; &lt;integer&gt;1&lt;/integer&gt;&lt;/dict&gt;&lt;/plist&gt;view rawcom.google.Chrome.mobileconfig hosted with ❤ by GitHub Add the extension ID to line 19, delete line 20 and 21 if you don’t need it. Save. Double click to import this policy. REBOOT Referenceshttps://steemit.com/chrome/@free1x/chrome http://xclient.info/a/1ddd2a3a-d34b-b568-c0d0-c31a95f0b309.html?_=c15d0db4b6cd8c32262ffbacc7695d50 https://gist.github.com/Explorare/be3dd598289252698cd37bca04abd0fe#file-com-google-chrome-mobileconfig]]></content>
      <tags>
        <tag>Browser</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[An intersting problem with Swift]]></title>
    <url>%2F2018%2F01%2FAn-intersting-problem-with-Swift%2F</url>
    <content type="text"><![CDATA[Paul Hudson‏ He recently posted a question about Swift Language on twitter,quite interesting Q1: All three match - how many ways can you think of to make this true in Swift? You’ll learn by trying 👍 PS:Code or it didn’t happen 😘 My idea is to change the way “get” works A1:Several methods have been collected so far Rewrite ‘==’Joe Groff‏ 1234func == (a: inout Int, b: Int) -&gt; Bool &#123; defer &#123; a += 1 &#125; return ! (a != b)&#125; Andy Lee‏ 1234567var a = 1extension Int &#123; static func == (left: Int, right: Int) -&gt; Bool &#123; a += 1 return !(left != right) &#125;&#125; Marius Fanu 12345extension Int &#123; static func == (lhs: Int, rhs: Int) -&gt; Bool &#123; return true &#125;&#125; Nate Cook 1234567891011var fakedOut = falsefunc == (lhs: Double, rhs: Int) -&gt; Bool &#123; if !fakedOut &#123; print("All three match!") fakedOut = true &#125; return Int(lhs) == rhs&#125;let a = 0.0let b = 0.0 Using UnicodeToni Suter 123let a = 1 // 'a'let a = 2 // 'a' + ZERO WIDTH SPACElet a = 3 // 'a' + ZERO_WIDTH_SPACE + ZERO_WIDTH_SPACE Other waysToni Suter 12345678enum Foo: ExpressibleByIntergerLiteral &#123; case bar init (integerLiteral value: Int) &#123; self = .bar &#125;&#125;let a = Foo.bar Toni Suter 12345var _a = 0var a:Int &#123; _a += 1 return _a&#125; Q2: Lots of folks are using operator overloading, so for them here’s hard mode !😈 A2:Rewrite ‘&amp;&amp;’John Payne 1234567extension Bool &#123; static func &amp;&amp;(lhs: Bool, rhs: Bool) -&gt; Bool &#123; return lhs || rhs ? true : false &#125;&#125;let a = 2let b = 5 BoolApollo Zhu‏ 123456extension Bool: ExpressibleByInterLiteral &#123; public init (integerLiteral value: Int) &#123; srlf = value != 0 &#125;&#125;let a: Bool = 1, b = 1 If you know more ways, please let me know in the comments below～]]></content>
      <tags>
        <tag>Swift</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Collection of answers for C Language homework]]></title>
    <url>%2F2018%2F01%2FCollection-of-answers-for-C-Language-homework%2F</url>
    <content type="text"><![CDATA[Summarize the previous homework answers,perhaps loading will be slow,I guess XD Experiment 2Because The Experiment 1 is too easy so there is no upload (not my lazy) If the code is somewhere different, it should be that I increased the difficulty of the question. Advanced3.2123456789#include &lt;stdio.h&gt;int main(int argc, const char * argv[]) &#123; char a, b, c; int sum; scanf("%c%c%c",&amp;a,&amp;b,&amp;c); sum = (a-'0')*100+(b-'0')*10+(c-'0'); printf("the number is %d\n",sum); return 0;&#125; 3.41234567891011121314151617#include &lt;stdio.h&gt;int main(int argc, const char * argv[]) &#123; while(1)&#123; float x; printf("Please enter a number from[1.0 , 100.0]\n"); if (!scanf("%f", &amp;x))&#123; printf("Input error ,please enter again\n"); while(getchar()!='\n');&#125; else if (x&lt;1.0||x&gt;100.0)&#123; printf("The number is not correct\n");&#125; else&#123; printf("The number is %lf\n",(x*x*x*x*x)); break; &#125; &#125; return 0;&#125; 3.11 Super Power Plus1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include &lt;stdio.h&gt;int main(int argc, const char * argv[]) &#123; char a[1000]; int i; gets(a); puts(a); printf("\n"); for(i=0;a[i]!='\0';i++) &#123; if(a[i]&gt;='A'&amp;&amp;a[i]&lt;='V') a[i]+=4; else if(a[i]&gt;='a'&amp;&amp;a[i]&lt;='v') a[i]+=4; &#125; for (i=0;a[i]!='\0';i++) &#123; switch(a[i])&#123; case 'w': a[i] = 'a'; break; case 'x': a[i] = 'b'; break; case 'y': a[i] = 'c'; break; case 'z': a[i] = 'd'; break; case 'W': a[i] = 'A'; break; case 'X': a[i] = 'B'; break; case 'Y': a[i] = 'C'; break; case 'Z': a[i] = 'D'; break; &#125; &#125; for (i=0;a[i]!='\0';i++) &#123; printf("%c",a[i]); &#125; printf("\n"); return 0;&#125; 3.12123456789101112#include &lt;stdio.h&gt;int main(int argc, const char * argv[]) &#123; int a,b,x,y,z; printf("Please input a number from (10~99):"); scanf("%d",&amp;a); b=a*a; x=b%10; y=b/10%10; z=10*y+x; printf("The number is:%d\n",z); return 0;&#125; Experiment 3Here added A bubbling algorithm Basis2.2（Plus）123456789101112131415161718192021222324252627//这是一个很简单的冒泡算法，利用循环解决问题字符串输出最小ascii码对应的字符#include &lt;stdio.h&gt;#include &lt;string.h&gt;int main()&#123; int a,temp; char c[50]; printf("请输入一串字符/n"); gets(c); a=strlen(c); printf("长度是：%d/n",a); for(int i=0;i&lt;a;i++) &#123; for(int j=i+1;j&lt;a;j++) //j&lt;a 如果等于a的话 数组就超过了，因为从0开始的，比如a[4] 就是a[0],a[1],a[2],a[3] 四个引用,不懂就去翻书 &#123; if(c[i]&gt;c[j]) &#123; temp=c[j];//temp提供一个交换作用 c[j]=c[i]; c[i]=temp; &#125; &#125; &#125; printf("排序后：%s/n",c); return 0;&#125; Advanced3.51234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859//解决此问题有更简单的办法，利用数组和循环，请自己思考#include &lt;stdio.h&gt;int main()&#123; int day,month,year,sum = 0,leap; printf("please input year,month,day\n"); scanf("%d%d%d",&amp;year,&amp;month,&amp;day); switch(month) /*先计算某月以前月份的总天数*/ &#123; case 1: sum=0; break; case 2: sum=31; break; case 3: sum=59; break; case 4: sum=90; break; case 5: sum=120; break; case 6: sum=151; break; case 7: sum=181; break; case 8: sum=212; break; case 9: sum=243; break; case 10: sum=273; break; case 11: sum=304; break; case 12: sum=334; break; default: printf("data error"); break; &#125; sum=sum+day; /*再加上某天的天数*/ if(year%400==0||(year%4==0&amp;&amp;year%100!=0)) /*判断是不是闰年*/ leap=1; else leap=0; if(leap==1&amp;&amp;month&gt;2) /*如果是闰年且月份大于2,总天数应该加一天*/ sum++; printf("It is the %dth day of %d year\n",sum,year); return 0;&#125; Experiment 4本文章涉嫌剧透，请紧张的往下看 说在前面，今天一位在腾讯搞开发工作的大佬给我指点了一下，”批评“了我printf(“\n”);的不良用法，然后还讲了一些其他的东西，在这里和大家先分享一下。 (仅供参考，请辩证的往下看） printf(“%s\n”,s)是一种很蠢的写法，某些实现会把printf(“%s\n”,s)自动优化为puts(s)。这说明连编译器都对printf(“%s\n”,s)看不下去了，原因是很多人上来学的就是printf()，有一种先入为主的惯性。加上对自己的代码质量没有太高的要求，所以只要输出就想到用printf()。类似的还有输出新行符写成printf(“\n”) （才写printf(“\n”)的我：汗。。。。。） 就K&amp;R而言，在讲hello,world时还介绍了\n，以及 123printf(&quot;hello,&quot;);printf(&quot;world&quot;);printf(&quot;\n&quot;); 这种等价写法。 这两个知识是用puts()不胜任的。 比如，puts()本身，“不用加’\n’就自动换行”(实际是遇到\0输出\n)，这就很难引入对\n的介绍，因为不需要。如果硬要引入(比如在字符串中间加\n)则显得很不自然，而且很难解释\0转成\n的问题。用用puts()的另一个问题是没法把”hello,world“分成几段逐次输出。而把”hello,world“分成几段逐次输出对于学习者深入理解“程序”这个概念、学习美化C程序格式以及领略C语言灵活的特点的是很有意义的。So，如果教材介绍了相关的知识，那么使用printf()讲hello,world无可非议；如果没介绍相关知识，那就是东施效颦，还不如用puts()。 但是，puts()有一个很重要的问题就是缺少额外的格式检查和维护优势。使用printf()并不仅仅在于其带有返回值可以方便格式检查，同时还在于避免hardwriting完成代码开发维护和运营更新的分离。（我：看不懂= =） 另外，scanf(“%s”,str)在遇到’\n’（回车）或’ ‘（空格）时输入结束，但’\n’（回车）或’ ‘（空格）停留在出入缓冲区，如处理不慎会影响下面的输入；gets(str)遇到’\n’（回车）时输入结束，但’\n’（回车）已被替换为’\0’，存储于字符串中，输入缓冲中没有遗留的’\n’（回车），不会影响后续的输入。 (仅供参考，请辩证的往上看） Basis2.5（Plus）突然想起这题还有另一种输出方式，推荐亲自运行一下，看看是什么结果～ 1234567891011121314151617181920#include &lt;stdio.h&gt;int main()&#123; int i,j,m; for(i=1;i&lt;=9;i++) &#123; for(j=1;j&lt;=i;j++) printf("%dx%d=%2d\t",j,i,j*i); printf("\n"); &#125; for(i=1;i&lt;=9;i++) &#123; for(m=1;m&lt;=9-i;m++) printf(" \t"); for(j=i;j&gt;=1;j--) printf("%dx%d=%2d\t",j,i,j*i); printf("\n"); &#125; return 0;&#125; Advanced3.3利用递归解决此类问题 123456789101112131415161718192021222324#include &lt;stdio.h&gt;#include &lt;math.h&gt;double Func(double x);//定义功能函数int main()&#123; double j,i=0,x=1; do&#123; i+=1.0/Func(x);//调用函数 j=1.0/Func(x); x++; &#125; while(j&gt;1e-6);//定义精度 printf("%f\n",i); return 0;&#125; double Func(double n)&#123; double f; if(n==0||n==1)//检测 f=1; else f=Func(n-1)*n;//反复调用自身达到阶乘的效果 return(f); //返回结果&#125; 3.13（Plus）若题目多一个非数字时停止，能否用一行代码实现判断和输入呢？ 12345678910111213#include &lt;stdio.h&gt;int main()&#123; float a,b; while (scanf("%f%f",&amp;a,&amp;b)==2&amp;&amp;a&gt;=0&amp;&amp;b&gt;=0)//一行解决输入和判断 &#123; printf("%f\n",a-b); &#125; return 0;&#125;/*continue:其实对于scanf这样的一些库函数其实对其来讲，他们使用起来并不是很友好，比如在不同的编译环境中，他们得到的结果数值是不一样的，这就需要如果我们需要在实际应用使用他们的话，就需要我们对他进行一些实际考证，这样才可以放心使用，可移植性并不优秀*/ 1.scanf（）函数返回成功读入的项目的个数。即在下面程序中scanf的返回值为1。如果没有读取任何项目（如它期望一个数字但是出入了一个非数字字符），它会返回值0。当它检测到“文件结尾”时，它返回EOF（EOF是文件stdio.h中定义的特殊值。一般，#define 指令把EOF 的值定义为 -1）。 1234int n;float p;n= scanf("%f",&amp;p);printf("%d,%f",n,p); 用%c读入空格和字符的问题。 如果在格式字符串中%c之前有一个空格，那么scanf()会跳到第一个非空白字符处。也就是说，命令scanf(“%c”,&amp;ch)读取在输入中遇到的第一个字符，而scanf(“ %c”,&amp;ch)（%c前有个空格）则读取遇到的第一个非空白字符。 对于同时输入几个字符，如果逗号（或任何非空格字符）和第一个%c之间没有间隔，则输入时，第一个字符与逗号之间也不能有间隔；如果有空格，则输入时，第一个字符和逗号之间可以有任意多个字符，也可以是0个。如果逗号和第二个%c之间没有间隔，则逗号和第二个输入字符间也不能有间隔。如果有空格，则输入时，第二个字符和逗号之间可以有任意多个字符，也可以是0个。 3.16（补充）问题分析： 如果说n和m是一个亲密数对，那么它们必须满足以下条件\1. n的全部因子之和（不包括n）必须等于m\2. m的全部因子之和（不包括m）必须等于n 例如：220的全部因子之和为：1+2+4+5+10+11+20+22+44+55+110=284 284的全部因子之和为：1+2+4+71+142=220 所以220和284是一对个亲密数对，输出格式：220-&gt;284 1234567891011121314151617181920212223242526272829#include &lt;stdio.h&gt;#include &lt;math.h&gt;int GFS(int n)&#123; int i, sum = 0; for (i = 1; i * i &lt;= n; i++) &#123; if (n % i == 0) &#123; if (i == 1 || i * i == n) sum += i; else sum += i + n / i; &#125; &#125; return sum;&#125;int main()&#123; int i, num; for (i = 2; i &lt;= 2000; i++) &#123; num = GFS(i); if (GFS(num) == i &amp;&amp; i &lt; num) printf("%d-&gt;%d\n", i, num); &#125; return 0;&#125; 3.17123456789101112131415161718#include&lt;stdio.h&gt;int main()&#123; int getsum(int n);//定义函数 int x,y; for(x=2;x&lt;1000;x++) for(y=2;y&lt;1000;y++)//循环开始 if((x==getsum(y))&amp;&amp;(y==getsum(x))&amp;&amp;x!=y)//条件判断 printf("%-5d%-5d%\n",x,y);&#125;int getsum(int n)&#123; int i,a=1; for(i=2;i&lt;=n/2;i++) if(!(n%i)) a=a+i; return a;//返回值&#125; 3.26（拓展）用三种方法来解答次题 1234567891011121314151617181920//普通算法#include &lt;stdio.h&gt;int main()&#123; int p,i,n,m,temp; printf("输入两个正整数 n 和 m："); scanf("%d,%d",&amp;n,&amp;m); if(n&lt;m)&#123; temp=n; n=m; m=temp; &#125; /*把大数放在 n 中，小数放在 m 中*/ for (i=m;i&gt;=2;i--) /*求 n 和 m 的最大公约数*/ &#123; if (m%i==0 &amp;&amp; n%i==0) break ; &#125; printf("最大公约数%d\n",i); printf("最小公倍数%d\n",m*n/i); /*p 是原来两个整数的乘积*/&#125; 当然，也可以用递归的方法 123456789101112131415161718192021//递归求两个整数最大公约数 最小公倍数#include &lt;stdio.h&gt;int gbs(int x,int y);int main() &#123; int m,n,t1; printf("please input two integer number:"); scanf("%d%d",&amp;m,&amp;n); t1=gbs(m,n); printf("The highest common divisor is %d\n",t1); printf("The least common multiple is %d\n",m*n/t1); return 0;&#125;int gbs(int a,int b)&#123; if(a%b==0) return b; else return gbs(b,a%b); &#125; 重头戏来了：辗转相除法关于辗转相除法： 在我国古代的《九章算术》中就有记载，现摘录如下: 约分术曰：“可半者半之，不可半者，副置分母、子之数，以少减多，更相减损，求其等也。以等数约之。” 其中所说的“等数”，就是最大公约数。求 “等数”的办法是“更相减损”法，实际上就是辗转相除法。 辗转相除法求最大公约数，是一种比较好的方法，比较快。 对于 52317 和 75569 两个数。先用较大的 75569 除以 52317，得商 1，余数 23252，再以 52317 除以 23252，得商 2，余数是 5813，再用 23252 做被除数，5813 做除数，正好除尽得商数 4。这样 5813 就是 75569 和 52317 的最大公约数。 比如说有要求 a、b 两个整数的最大公约数，a＞b，那么我们先用 a 除以 b，得到商 8，余数 r1：a÷b ＝q1…r1 我们当然也可以把上面这个式子改写成乘法式：a＝bq1＋r1——l） 如果 r1＝0，那么 b 就是 a、b 的最大公约数 3。要是 r1≠0，就继续除，用 b 除以 r1，我们也可以有和上面一样的式子： b＝r1q2＋r2——-2） 如果余数 r2＝0，那么 r1 就是所求的最大公约数 3。为什么呢？因为如果 2）式变成了 b＝r1q2，那么 b1r1 的公约数就一定是 a1b 的公约数。这是因为一个数能同时除尽 b 和 r1，那么由 l）式，就一定能整除 a，从而也是 a1b 的公约数。 反过来，如果一个数 d，能同时整除 a1b，那么由 1）式，也一定能整除 r1，从而也有 d 是 b1r1 的公约数。 这样，a 和 b 的公约数与 b 和 r1 的公约数完全一样，那么这两对的最大公约数也一定相同。那 b1r1 的最大公约数，在 r1＝0 时，不就是 r1 吗？所以 a 和 b 的最大公约数也是 r1 了。 有人会说，那 r2 不等于 0 怎么办？那当然是继续往下做，用 r1 除以 r2，…… 直到余数为零为止。 在这种方法里，先做除数的，后一步就成了被除数，这就是辗转相除法名字的来历。 12345678910111213141516171819#include &lt;stdio.h&gt;int main()&#123; int p,r,n,m,temp; printf("输入两个正整数 n 和 m："); scanf("%d,%d",&amp;n,&amp;m); if(n&lt;m) &#123;temp=n;n=m;m=temp;&#125; /*把大数放在 n 中，小数放在 m 中*/ p=n*m; /*先将 n 和 m 的乘积保存在 p 中，以便求最小公倍数时用*/ r=n%m; while(r!=0) /*求 n 和 m 的最大公约数*/ &#123; n=m;m=r;r=n%m;&#125; printf("最大公约数%d\n",m); printf("最小公倍数%d\n",p/m); /*p 是原来两个整数的乘积*/ return 0;&#125; Experiment 5Ps：之前群里有人问一道oj题，然而本人基本没做过oj，就点简单的写了些（在底部），其中我用了struct，会单独放一篇文章讲解。 感觉实验5没啥需要po出来的=。= Basis2.7只是添加了一个自己输入行数的功能而已= 。= 123456789101112131415161718192021222324252627282930#include &lt;stdio.h&gt;int main(int argc, const char * argv[])&#123; int arr[30][30]= &#123;0&#125;; int n; printf("input n:"); scanf("%d",&amp;n); for(int i=1; i&lt;=n; i++) &#123; arr[i][1]=1; arr[i][i]=1; if(i&gt;=2) &#123; for(int j=1; j&lt;=i; j++) &#123; arr[i][j]=arr[i-1][j-1]+arr[i-1][j]; &#125; &#125; &#125; for(int i=1; i&lt;=n; i++) &#123; for(int j=1; j&lt;=i; j++) &#123; printf("%3d ",arr[i][j]); &#125; putchar('\n'); &#125; return 0; &#125; Advanced3.2既然是要同时输出之前的顺序，不如设定两个数组。(坐下！基本操作而已。) 1234567891011121314151617181920212223242526272829303132333435363738#include &lt;stdio.h&gt;int main(int argc, const char * argv[])&#123; int i, j,k,l,t1,t2; int a[20], b[20]; printf("please enter 20 numbers:"); for( i=0, j=1; i&lt;20; i++, j++) &#123; scanf("%d", &amp;a[i]); b[i] = j; &#125; for( k = 0; k&lt;20; k++)&#123; for( l =k+1; l&lt;=19; l++) &#123; if(a[k]&gt;a[l]) &#123; t1 = a[l];a[l] = a[k];a[k] = t1; t2 = b[l];b[l] = b[k];b[k] = t2; &#125; &#125; &#125; for( i=0; i&lt;20; i++) &#123; printf("%d", a[i]); if(i&lt;19) printf(" "); &#125; printf("\n"); for(i=0; i&lt;20; i++) &#123; printf("%d", b[i]); if(i&lt;19) printf(" "); &#125; printf("\n"); return 0;&#125; 3.81234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768//代码写得很不规范，不过我懒得改了=。=#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;//改进版冒泡排序void bubbleSortPlus(int a[10]) &#123; int i,j,flag; for(i = 0;i &lt; 9; i++) &#123; flag = 1; for(j = 0;j &lt; 9-i; j++) &#123; if(a[j] &lt; a[j+1]) &#123; int tmp = a[j]; a[j] = a[j+1]; a[j+1] = tmp; flag = 0; &#125; &#125; if(flag == 1) break; &#125; for(i = 10;i &gt; 0; i--)&#123; printf("%d ",a[i]); &#125; putchar('\n');&#125;//快速排序void quikSort(int a[],int low,int high) &#123; int i = low; int j = high; int temp = a[i]; if( low &lt; high) &#123; while(i &lt; j) &#123; while((a[j] &gt;= temp) &amp;&amp; (i &lt; j)) &#123; j--; &#125; a[i] = a[j]; while((a[i] &lt;= temp) &amp;&amp; (i &lt; j)) &#123; i++; &#125; a[j]= a[i]; &#125; a[i] = temp; quikSort(a,low,i-1); quikSort(a,j+1,high); &#125; else &#123; return; &#125; for(i=0;i&lt;10;i++)&#123; printf("%d ",a[i]); &#125; putchar('\n');&#125;int main(void) &#123; int i = 0, a[10]; printf("Please enter 10 numbers:"); for (i = 0; i &lt; 10; i++) &#123; scanf("%d", &amp;a[i]); &#125; bubbleSortPlus(a);//调用冒泡 quikSort(a,0,4);//调用快速排序 return 0;&#125; 杭电（hdu）2085 核反应堆题Time Limit: 1000/1000 MS (Java/Others) Memory Limit: 32768/32768 K (Java/Others)Total Submission(s): 12219 Accepted Submission(s): 5547 Problem Description 某核反应堆有两类事件发生：高能质点碰击核子时，质点被吸收，放出3个高能质点和1个低能质点；低能质点碰击核子时，质点被吸收，放出2个高能质点和1个低能质点。假定开始的时候（0微秒）只有一个高能质点射入核反应堆，每一微秒引起一个事件发生(对于一个事件，当前存在的所有质点都会撞击核子)，试确定n微秒时高能质点和低能质点的数目。 Input 输入含有一些整数n(0≤n≤33)，以微秒为单位，若n为-1表示处理结束。 Output 分别输出n微秒时刻高能质点和低能质点的数量，高能质点与低能质点数量之间以逗号空格分隔。每个输出占一行。 Sample Input 125 2-1 Sample Output 12571, 20911, 4 简单分析分析题目得到，某秒的高能质点数是它的前一秒乘3再加上前一秒的低能质点数乘2。 所以不难写出 12345678910111213141516171819202122#include &lt;stdio.h&gt;struct nuclearReactor&#123; long long high,low;&#125;;int main(void)&#123; int i,n; struct nuclearReactor narr[35]; narr[0].high=1; narr[0].low=0; for(i=1; i&lt;=33; i++) &#123; narr[i].high=narr[i-1].high*3+narr[i-1].low*2; narr[i].low=narr[i-1].high+narr[i-1].low; &#125; while((void)(scanf("%d",&amp;n)!=EOF),n!=-1) &#123; printf("%lld, %lld\n",narr[n].high,narr[n].low); &#125; return 0;&#125; Experiment 6Advanced3.1没啥好说的，老师上课也讲了。 123456789101112131415161718192021222324252627282930313233343536373839404142434445#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;#define N 1024int main()&#123; char str[N]; int num[26][2]; int i,j,t; for (i =0 ; i&lt;26; i++) &#123; num[i][0] = 'a'+i; num[i][1] = 0; &#125; gets(str); for ( i = 0; i&lt;strlen(str); i++) &#123; if (str[i]&gt;='a' &amp;&amp; str[i]&lt;='z') &#123; num[str[i]-'a'][1]++; &#125; &#125; for ( i = 0; i&lt;26-1; i++) &#123; for ( j = 0; j&lt;26-1; j++) &#123; if (num[j][1]&lt;num[j+1][1]) &#123; t = num[j+1][1]; num[j+1][1] = num[j][1]; num[j][1] = t; &#125; &#125; &#125; for (i = 0; i&lt;26; i++) &#123; if (num[i][1]&gt;0) &#123; printf("%c\t%d\n",num[i][0],num[i][1]); &#125; &#125; return 0;&#125; 3.212345678910111213141516171819202122232425262728293031323334353637383940414243#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;int main()&#123; char str[3][81]; int upper = 0,lower = 0,digit = 0,space = 0,other = 0; int i,j; printf ("请输入三行字符：\n"); for (i=0;i&lt;3;i++) gets(str[i]); for (i=0;i&lt;3;i++) &#123; for (j=0;j&lt;strlen(str[i]);j++)//注意这里要用strlen来计算长度作为循环的标准 &#123; if (str[i][j]&gt;='A' &amp;&amp; str[i][j]&lt;='Z')&#123; upper++; &#125; else if (str[i][j]&gt;='a' &amp;&amp; str[i][j]&lt;='z')&#123; lower++; &#125; else if (str[i][j]&gt;='0' &amp;&amp; str[i][j]&lt;='9')&#123; digit++; &#125; else if ((str[i][j]=' '))&#123; space++; &#125; else&#123; other++; &#125; &#125; &#125; printf("大写字母：%d 个\n",upper); printf("小写字母：%d 个\n",lower); printf("数 字：%d 个\n",digit); printf("空 格：%d 个\n",space); printf("其 它：%d 个\n",other); return 0;&#125; 3.312345678910111213141516171819#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;int main()&#123; char str[1024]; gets(str); for (int i =0; i&lt;strlen(str);i++) &#123; if (str[i]==',') &#123; str[i]='\n';//直接检测到逗号就替换为换行，这是最简单办法 &#125; else ; &#125; puts(str); return 0;&#125; 3.412FIB WARRING:practice is missing，the police is searching..... &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;/// OOO ///警方突袭进行中/// OOO ///&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt; 我也不知哪里去了，或许3.4逃走了吧。。。 3.512345678910111213141516171819202122232425262728293031323334353637383940//貌似有点不美观，不过再次懒得改了- -！#include&lt;stdio.h&gt;#include&lt;string.h&gt;int main()&#123; int i,flag,top=0; unsigned long len;//编译器提示：Implicit conversion loses integer precision: 'unsigned long' to 'int'，说明推荐我们使用unsigned long，因为len可能会超出限制长度 char str1[1024],str2[1024];//st2存放的只有字母 gets(str1); len=strlen(str1); for(i=0;i&lt;len;i++)//用来判断字符，如果是字母就移动位置到前一个地方 &#123; if((str1[i]&gt;='a'&amp;&amp;str1[i]&lt;='z')||(str1[i]&gt;='A'&amp;&amp;str1[i]&lt;='Z')) str2[top++]=str1[i]; &#125; flag = 1; len = strlen(str2); for(i = 0; i &lt; len/2; i ++)//此时开始从两头往中间开始判断 &#123; if(str2[i] != str2[len - 1 -i]) &#123; flag = 0; break; &#125; &#125; if(flag)&#123; printf("Yes!\n"); &#125; else&#123; printf("No!\n"); &#125; return 0;&#125; Experiment 7ps：实验3.1和实验3.3实际是一样的，顺序有点乱（其实我懒得重新写了，逃 Advanced3.3程序中指定个数，再进行分配的办法12345678910111213141516171819202122232425262728#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;int main()&#123; int n,i,sum = 0; double avg; printf("先输入个数："); scanf("%d",&amp;n); int *in = (int *)malloc(sizeof(int) * n); printf("输入数："); for(i = 0;i &lt; n;i++) &#123; scanf("%d",in+i); &#125; for(i = 0;i &lt; n;i++) &#123; sum += *(in + i); &#125; avg = (double)sum / n printf("和为：%d，平均值为:%.2lf\n",sum,avg); &#125; for(i = 0;i &lt; n;i++) &#123; printf("%d 对应的差值是 %.2lf \n",in+i,avg-*(in+i); &#125; free(in); return 0;&#125; 但实际上，题目要求的是“键盘输入若干个整数”，而没有提到要预先输入个数，严格来说，这样是错误的，没有达到题目要求。 123456789101112131415161718192021222324252627282930313233//于是 ”一个惊叹号“ 同学在我的提醒下开始看书，查找方法解决这个问题，终于。。。#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;int main ()&#123; int *p = NULL; float ave; int sum = 0, count = 0;//count用来计数 int room = 5, temp;//保证第一次输入有空间 int i; p = (int*)malloc(room*sizeof(int));//分配第一次输入的内存 printf("输入整数 一个整数输入后按下回车进行下一次输入\n"); printf("输入-1，结束输入，开始运行程序\n"); for(i = 0; ; i++) &#123; scanf("%d",&amp;temp); if(temp == -1) break; p[count] = temp; sum+=p[count]; count++; if(count == room)//判断内存是否已满 room+=5;//待申请内存新的大小 p = realloc(p,room*sizeof(int));//realloc 拓展内存 &#125; ave = (float)sum/count; printf("平均数为%f\n",ave); for(i = 0; i&lt;count; i++)&#123; printf("第%d个数与平均数的差值为%f\n", i+1, p[i]-ave); &#125; free(p); return 0;&#125; 不过还有些小东西没有完善。。具体是什么，请看实验3.1 3.2常规操作1234567891011121314151617#include &lt;stdio.h&gt;#include &lt;ctype.h&gt;int main() &#123; char s[1024]; int i,j; printf("输入字符串:\n"); while(fgets(s,1024,stdin)) &#123; for(i = 0,j = 0;s[i];++i)&#123; if(isalpha(s[i]))&#123; s[j++] = s[i]; &#125; &#125; s[j] = '\0'; printf("%s\n",s); &#125; return 0;&#125; 只有常规操作，坐下 3.1好好体会（逃 12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;ctype.h&gt;#define ROOM 5int main()&#123; double *values = NULL; int capacity = 0; double *temp = NULL; double sum = 0.0; int count = 0; char answer = 'n'; do &#123; if(count == capacity) &#123; capacity += ROOM; temp = realloc(values, capacity*sizeof(double)); if(!temp) &#123; printf("Memory allocation failed.Bye"); exit(1); &#125; values = temp; temp = NULL; &#125; printf("Enter a value: "); scanf("%lf", values+count++); printf("Do you want to enter another(y/Y or n/N)? "); scanf(" %c", &amp;answer); &#125;while(tolower(answer) == 'y'); for(size_t i = 0 ; i &lt; count ; ++i) sum += *(values + i); printf("The average is %f.\n", sum/count); for(size_t i = 0 ; i &lt; count ; ++i)&#123; printf("%f -&gt; %f\n",(*(values + i)),((*(values + i))-(sum/count))); &#125; printf("\n"); free(values); return 0;&#125; Experiment 8考完四级，心态如下 答案只有函数，在一个文件里面 Basis123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150//就只写了函数/*2.1*/double carea(double r)&#123; return r*r*3.1415926;&#125;/*2.2*/int gcd(int numa, int numb)&#123; int i; for(i=numa;i&gt;=1;i--)&#123; if(numa%i==0&amp;&amp;numb%i==0) break; &#125; return i; &#125;/*2.3*/double distance(int x1, int y1, int x2, int y2)&#123; double resul; resul=sqrt((double)pow(x1-x2,2)+pow(y1-y2,2)); return resul;&#125;/*2.4*/double tempt(double temp,char ctype)&#123; if (islower(ctype)=='C') &#123; temp = (temp-32)/1.8; return temp; &#125; if (islower(ctype)=='F') &#123; temp = (32+temp)*1.8; return temp; &#125; else return 0;&#125;/*2.5*/int isOE(int number)&#123; if( (number%2)==0 )&#123; return -1; &#125; else return 1;&#125;/*2.6*/int answer()&#123; printf("答案是：2 3 \n 3 4"); return 0;&#125;/*2.7*/void sa(int x1,int x2,int *sum,int *mul)&#123; *sum=(x1+x2); *mul=(x1*x2);&#125;/*2.8*/void exchange(int *n1,int *n2)&#123; int x; x=*n1; *n1=*n2; *n2=x;&#125;/*2.9*/int isprime(int *data,int *primes,int len)&#123; int i,j,number=0; for (i = 0,j=0; i&lt;=len; i++) &#123; int t=1; for (j = 2;j&lt;i ; j++) &#123; if (*(data+i)%j==0) &#123; t=0; break; &#125; &#125; if (t==1) &#123; primes[j++]=*(data+i); number++; &#125; &#125; return number;&#125;/*2.10*/void MatrixSearch(double matrix[][], double *pMax, double *pMin, int n)&#123; *pMax=*pMin=matrix[0][0]; for(i=0;i&lt;(*matrix);i++)&#123; for(j=0;j&lt;(**matrix);j++)&#123; if(matrix[i][j]&gt;*pMax) *pMax=matrix[i][j]; if(matrix[i][j]&lt;*pMin) *pMin=matrix[i][j]; &#125; &#125;&#125;/*2.11*/void sort(int *arry,int len)&#123; int i,j; int flag = 1; for (i = 0; i &lt; len &amp;&amp; flag; i++) &#123; flag = 0; //只要flag在下一次外循环条件检测的时候值为0，就说明已经排好序，不用继续循环 for (j = len-1; j &gt; i; j--) &#123; if (array[j] &lt; array[j-1]) &#123; temp = array[j]; array[j] = array[j-1]; array[j-1] = temp; lag = 1; //如果有交换，就将标记变量赋1 &#125; &#125; &#125; for (i = 0; i &lt; len; i++) &#123; printf("%d\n", array[i]); &#125; return 0;&#125;/*2.12*/int search(char *list,char c,int len)&#123; int low=0,high=len-1,k; while (low=high) &#123; k=(low+high)/2; if (list[k]==c) &#123; high=k-1; &#125; else if(list[k]&gt;c) high=k-1; &#125; return -1;&#125;//importFucint main()&#123; return 0;&#125; Advanced123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156#include "stdio.h"#include "stdlib.h"#include &lt;stdbool.h&gt;#include "math.h"/*3.2*/int findmax(int n1,int n2,int n3)&#123; return ((((n1&gt;n2)?n1:n2)&gt;n3)?((n1&gt;n2)?n1:n2):n3);&#125;/*3.3*/double cvolume(double r,double h)&#123; return (3.1415926*r*r*h);&#125;/*3.4*/int lcm(int x1,int x2)&#123; int x, y, temp; if(x1 &lt; x2)&#123; temp = x1; x1 = x2; x2 = temp; &#125; x = x1; y = x2; while(y != 0)&#123; temp = x%y; x = y; y = temp; &#125; return x1*x2/x; //return x1;//the max&#125;/*3.5*/long fact(int n)&#123; if (n&gt;0) &#123; return n*fact(n-1); &#125; else if (n==0) return 1; else return 0;&#125;/*3.6*/double power(double n,int p)&#123; return pow(n,p);&#125;/*3.7*/int cday(int year,int month,int day)&#123; int i, num,d[12]; d[0] = 31; d[1] = 28; d[2] = 31; d[3] = 30; d[4] = 31; d[5] = 30; d[6] = 31; d[7] = 31; d[8] = 30; d[9] = 31; d[10] = 30; d[11] = 31; num = 0; if (year % 4 == 0)&#123; d[1] = 29; &#125; for (i = 0; i &lt; month - 1; i++)&#123; num += d[i]; &#125; num += day; printf("是%d年第%d天",year,num); return 0;&#125;/*3.8*/void data(int num,int *month,int *day,int *year)&#123; /*int main()&#123; int num=20170412,m=0,d=0,y=0; int *month=&amp;m; int *day=&amp;d; int *year=&amp;y; data(num, month, day, year); return 0; &#125;*/ *day = num % 100; num /= 100; *month = num % 100; *year = num / 100; printf("%4d-%02d-%02d\n",*year,*month,*day);&#125;/*3.9*/long fun(int k)&#123; if (k&gt;0) &#123; return k*fun(k-1); &#125; else if (k==0)&#123; return 1; &#125; else return 0;&#125;/*3.10*/int fibonacci(int n)&#123; if (n &lt;= 2)&#123; return 1 ; &#125; else&#123; return fibonacci(n-1) + fibonacci(n-2) ; &#125;&#125;/*3.11*/void hanoi(int n, char x, char y, char z)&#123; if(n == 1) printf("%d. %c -&gt; %c\n",n,x,z); else &#123; hanoi(n-1,x,y,z); printf("%d. %c -&gt; %c\n",n,x,z); hanoi(n-1,y,x,z); &#125; &#125;/*int main()&#123; //A,B,C分别代表三个柱子 char ch1 = 'A'; char ch2 = 'B'; char ch3 = 'C'; int n; //n代表圆盘的个数 printf("请输入圆盘的个数："); scanf("%d",&amp;n); move(n,ch1,ch2,ch3); return 0; */ int main()&#123; return 0;&#125; 话说，最近好累啊，马上实验室招新活动= = Experiment 9今天算是见识到了某人的恶心之处 Basis以后基本上都只会放源码了，因为我想把这个博客做得更具有偏向性，可能以后会全部单独在一篇文章中更新 甚至未来有可能会删除作业内容 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;#include &lt;ctype.h&gt;/*2.1*/void maxmin(int *data, int *max, int *min, int len)&#123; int i; *max=data[0]; *min=data[0]; for(i=0;i&lt;len;i++) &#123; if(data[i]&gt;*max) *max=data[i]; if(data[i]&lt;*min) *min=data[i]; &#125;&#125;/*2.2*/int count(char* string)&#123; int i; int c=0; for(i=0;string[i]!=0;i++) if((string[i]&gt;='a'&amp;&amp;string[i]&lt;='z')||(string[i]&gt;='A'&amp;&amp;string[i]&lt;='Z')) c++; return c;&#125;/*2.3*/int del(int *data,int n,int en)&#123; int i,j; int m=0; for(i=0;i&lt;en;i++) if(data[i]==n) &#123; for (j=i; j&lt;en-i; j++) &#123; data[j]=data[j+1]; &#125; m++; &#125; return en-m;&#125;/*2.4*/int search(int *data, int n, int len)&#123; int i; for(i=0;i&lt;len;i++) &#123; if(n==data[i]) return i; &#125; return -1;&#125;/*2.5*/void delch1(char* string)&#123; int i,j; char ch; fflush(stdin); printf("输入要删除的字符"); scanf("%c",&amp;ch); fflush(stdin); for(i=0;i&lt;strlen(string);i++) &#123; if(string[i]==ch) &#123; j=i; break; &#125; &#125; for(i=j;i&lt;strlen(string)-1;i++) string[i]=string[i+1]; string[strlen(string)-1]=0;&#125;/*2.6*/int searchch(char* string, char ch)&#123; int i; for (i = 0; string[i]; i++) &#123; if (string[i] == ch) return i; &#125; return -1;&#125;/*2.7*/void reverse(int *data, int len)&#123; int i; int a; for(i=0;i&lt;len/2;i++) &#123; a=data[i]; data[i]=data[len-i-1]; data[len-i-1]=a; &#125;&#125;/*2.8*/int changeS(char *string)&#123; unsigned int i; int j=0; int num=0; int a[1024]; for(i=0;string[i];i++) if(string[i]&gt;='0'&amp;&amp;string[i]&lt;='9') a[j++]=string[i]-48; if(string[0]=='-') &#123; for(i=0;i&lt;strlen(string)-1;i++) num+=a[i]*(int)pow(10,strlen(string)-i-2); num=num*-1; &#125; else &#123; for(i=0;i&lt;strlen(string);i++) num+=a[i]*(int)pow(10,strlen(string)-i-1); &#125; return num; &#125;/*2.9*/void swap(int *data,int len)&#123; int n; int i; int j=0,k=0; for(i=0;i&lt;len;i++) &#123; if(data[k]&gt;data[i]) k=i; if(data[j]&lt;data[i]) j=i; &#125; n=data[0]; data[0]=data[k]; data[k]=n; n=data[len-1]; data[len-1]=data[j]; data[j]=n; &#125;/*2.10*//*#include &lt;stdio.h&gt; #include &lt;string.h&gt; #include &lt;stdlib.h&gt; #define N 10 void strsort(char* s[],int n) &#123; int i,j,k; char* temp=NULL; for(i=0;i&lt;n-1;i++) &#123; k=i; for(j=i+1;j&lt;n;j++) if(strcmp(s[j],s[k])&lt;0) k=j; if(k!=i) &#123; temp=s[i]; s[i]=s[k]; s[k]=temp; &#125; &#125; &#125; void main() &#123; char *s[N],**p=NULL; int i; for(i=0; i&lt;N; i++) &#123; s[i]=(char*)malloc(sizeof(char)*20); gets(s[i]); &#125; strsort(s,N); p=s; for(i=0; i&lt;N; i++) &#123; printf("%s\n",*p++); free(s[i]); &#125; &#125;*//*2.11*/char *strin(char* s1,char* s2)&#123; int i,j; int k; for(i=0;s1[i];i++) &#123; j=1; if(s2[0]==s1[i]) &#123; for(k=0;s2[k];k++) if(s2[k]!=s1[i+k]) j=0; if(j!=0) return &amp;s1[i]; &#125; &#125; return 0;&#125;/*2.12*/void change(char *string)&#123; int i; for(i=0;string[i];i++) string[i]=isupper(string[i]);&#125;/*2.13*/int stringlen(char* string)&#123; int i; for(i=0;string[i];i++); return i; &#125;int main()&#123; return 0;&#125; 提醒大家一句，老师只是一个职业 Advanced123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480//Xcode自动添加的时候就是双引号，懒得改，反正都一样#include "stdio.h"#include "stdlib.h"#include "string.h"#include "ctype.h"/*3.1*/void stringcpy(char *to, char *from)&#123; while((*(to++)=*(from++))!=0);&#125;/*3.2*/void merge(int *a,int n,int *b,int m,int *c)&#123; int i,j; for(i=j=0; i&lt;n&amp;&amp;j&lt;m; ) *c++=a[i]&lt;b[j]?a[i++]:b[j++]; while(i&lt;n) *c++=a[i++]; while(j&lt;m) *c++=b[j++]; &#125;/*3.3*/void mstrcpy(char *src,char *des,int m)&#123; int i,j; for(i=0, j=m; src[j-1]; i++, j++) des[i]=src[j];&#125;/*3.4（1）*/int FindMax1(int (*data)[4])&#123; int i,j; int m=0,n=0; for(i=0;i&lt;3;i++) for(j=0;j&lt;4-1;j++) if(*(*(data+m)+n)&lt;*(*(data+i)+j)) &#123; n=j; m=i; &#125; return data[m][n];&#125;/*3.4（2）*/int FindMax2(int *data)&#123; int i; int n=0; for(i=0;i&lt;12;i++) if(*(data+n)&lt;*(data+i)) n=i; return data[n];&#125;/*3.5*/void minvert(int (*maxtrix)[5])&#123; int i,j; int t; for(i=0;i&lt;5;i++) for(j=i;j&lt;5;j++) &#123; t=maxtrix[i][j]; maxtrix[i][j]=maxtrix[j][i]; maxtrix[j][i]=t; &#125;&#125;/*3.6*/void dresort(int *data, int len)&#123; int i,j=0,k=0; int m[4]; int n[5]; for(i=0;i&lt;len-1;i+=2) &#123; n[j++]=data[i]; m[k++]=data[i+1]; &#125; if(len%2==1) &#123; n[j]=data[len-1]; for(i=0;i&lt;len/2;i++) &#123; data[i]=n[i]; data[len/2+i+1]=m[i]; &#125; data[len/2]=n[len/2]; &#125; else &#123; for(i=0;i&lt;len/2;i++) &#123; data[i]=n[i]; data[len/2+i]=m[i]; &#125; &#125;&#125;/*3.7*/void change(int (*m)[5])&#123; int t; int a=0,b=0; int i,j; for(i=0;i&lt;5;i++) for(j=0;j&lt;5;j++) if(m[a][b]&gt;m[i][j]) &#123; a=i; b=j; &#125; if(a!=0||b!=0) &#123; t=m[a][b]; m[a][b]=m[0][0]; m[0][0]=t; &#125; a=0,b=4; for(i=0;i&lt;5;i++) for(j=0;j&lt;5;j++) if(m[a][b]&gt;m[i][j]&amp;&amp;(i!=0||j!=0)) &#123; a=i; b=j; &#125; if(a!=0||b!=4) &#123; t=m[a][b]; m[a][b]=m[0][4]; m[0][4]=t; &#125; a=4,b=0; for(i=0;i&lt;5;i++) for(j=0;j&lt;5;j++) if(m[a][b]&gt;m[i][j]&amp;&amp;(i!=0||j!=0)&amp;&amp;(i!=0||j!=4)) &#123; a=i; b=j; &#125; if(a!=4||b!=0) &#123; t=m[a][b]; m[a][b]=m[4][0]; m[4][0]=t; &#125; a=4,b=4; for(i=0;i&lt;5;i++) for(j=0;j&lt;5;j++) if(m[a][b]&gt;m[i][j]&amp;&amp;(i!=0||j!=0)&amp;&amp;(i!=0||j!=4)&amp;&amp;(i!=4||j!=0)) &#123; a=i; b=j; &#125; if(a!=0||b!=0) &#123; t=m[a][b]; m[a][b]=m[4][4]; m[4][4]=t; &#125; a=2,b=2; for(i=0;i&lt;5;i++) for(j=0;j&lt;5;j++) if(m[a][b]&lt;m[i][j]) &#123; a=i; b=j; &#125; if(a!=0||b!=0) &#123; t=m[a][b]; m[a][b]=m[2][2]; m[2][2]=t; &#125; &#125;/*3.8(1)*/void stuave(float (*score)[5],float ave[10],int n)&#123; int i,j; float sum=0.0; for(i=0;i&lt;n;i++) &#123; sum=0; for(j=0;j&lt;5;j++) sum+=score[i][j]; ave[i]=sum/5; &#125;&#125;/*3.8(2)*/void mscore(float(*score)[5],int *s, int *c)&#123; int i,j; float m=score[0][0]; for(i=0;i&lt;5;i++) for(j=0;j&lt;5;j++) if(m&lt;score[i][j]) &#123; m=score[i][j]; *s=i; *c=j; &#125;&#125;/*3.9*/void sorts(char *(string[1024]),int n)&#123; int i,j; char *t; for(i=0;i&lt;n-1;i++) for(j=0;j&lt;n-1-i;j++) if(strcmp(string[j],string[j+1])&gt;0) &#123; t=string[j]; string[j]=string[j+1]; string[j+1]=t; &#125;&#125;/*3.10*/int fnums(char *str, int *num)&#123; int i,m; int j=0; int k=0; char n[10]=&#123;0&#125;; for(i=0;i&lt;30;i++) num[i]=0; for(i=0;str[i];i++) &#123; for(k=0;str[i]&gt;='0'&amp;&amp;str[i]&lt;='9';i++,k++) &#123; n[k]=str[i]; &#125; if(k!=0) &#123; for(m=k-1;m&gt;=0;m--) num[j]+=(n[m]-'0')*(int)pow(10,k-1-m); j++; &#125; for(;k&gt;=0;k--) n[k]=0; &#125; return j;&#125;/*3.11*/int scmp(char *p1,char *p2)&#123; int i; for(i=0;p1[i]&amp;&amp;p2[i];i++) if(p1[i]-p2[i]!=0) return p1[i]-p2[i]; if(strlen(p1)&gt;strlen(p2)) return p1[i]; else return p2[i]; return 0;&#125;/*3.12*//*#include &lt;stdio.h&gt;char* pMonth[12]=&#123;&#123;"January"&#125;,&#123;"February"&#125;,&#123;"March"&#125;,&#123;"April"&#125;,&#123;"May"&#125;,&#123;"Jule"&#125;,&#123;"July"&#125;,&#123;"August"&#125;,&#123;"September"&#125;,&#123;"October"&#125;,&#123;"November"&#125;,&#123;"December"&#125;&#125;;int main()&#123; while(1) &#123; int nMonth; scanf("%d",&amp;nMonth); if(nMonth&gt;12||nMonth&lt;1) &#123; printf("not found"); break; &#125; printf("\t%s\n",pMonth[nMonth-1]); &#125;&#125;*//*3.13*/void josephu(int *people)&#123; int n=0; int j=0; int m=0; for(;;j++) &#123; if(j&gt;29) j=0; if(people[j]!=0) m++; else continue; if(m==9) &#123; people[j]=0; m=0; n++; &#125; if(n&gt;=15) break; &#125;&#125;/*3.14*/int fact(int x,int *f)&#123; int i; int n=0; for(i=2;i&lt;x;i++) &#123; if(i%2==0) if(x%i==0) f[n++]=i; &#125; f[n]=0; return n;&#125;/*3.15*/void zprocess(int *data,int len)&#123; int i,j; int t; for(i=0;i&lt;len;i++) if(data[i]==0) for(j=i;j&lt;len-1;j++) &#123; t=data[j]; data[j]=data[j+1]; data[j+1]=t; &#125;&#125;/*3.16*/int fwords(char *string,char (*words)[1024])&#123; int i,j; int count=0; for(i=0;string[i];i++) if(string[i]&gt;='a'&amp;&amp;string[i]&lt;='z'||string[i]&gt;='A'&amp;&amp;string[i]&lt;='Z') &#123; for(j=0;string[i]&gt;='a'&amp;&amp;string[i]&lt;='z'||string[i]&gt;='A'&amp;&amp;string[i]&lt;='Z';i++,j++) words[count][j]=string[i]; words[count][j]=0; count++; &#125; return count;&#125;/*3.17*/void stringcat(char *str1,char *str2)&#123; int i; int n; for(n=0;str1[n];n++); for(i=0;str2[i];i++) str1[n-1+i]=str2[i]; str1[n-1+i]=0;&#125;/*3.18*/void stringvert(char *str)&#123; int i,j; char t; for(i=0;str[i];i++); for(j=0;j&lt;i/2;j++) &#123; t=str[j]; str[j]=str[i-1-j]; str[i-j-1]=t; &#125; str[i]=0; &#125;/*3.19*/void svowel(char *s1,char *s2)&#123; int i,j=0; for(i=0;s1[i];i++) if(s1[i]=='a'||s1[i]=='e'||s1[i]=='i'||s1[i]=='o'||s1[i]=='u') s2[j++]=s1[i]; s2[j]=0;&#125;/*3.20*/void strsta(char* string,int* num)&#123; int i; for(i=0;string[i];i++) &#123; if((string[i]&gt;='a'&amp;&amp;string[i]&lt;='z')||string[i]&gt;='A'&amp;&amp;string[i]&lt;='Z') num[0]++; else if(string[i]&gt;='0'&amp;&amp;string[i]&lt;='9') num[1]++; else if(string[i]==' ') num[2]++; else num[3]++; &#125;&#125;/*3.21*/void wpos(char *string, int *begin, int *end)&#123; int i,j; int m=0; for(i=0;string[i];i++) &#123; for(j=0;string[i]&gt;='a'&amp;&amp;string[i]&lt;='z'||string[i]&gt;='A'&amp;&amp;string[i]&lt;='Z';j++,i++); if(j&gt;m) &#123; m=j; *begin=i-j; *end=i-1; &#125; &#125;&#125;/*3.22*/void sortno(char (*stuno)[11],int n)&#123; int i,j; char num[11]; for(i=0;i&lt;n-1;i++) for(j=0;j&lt;n-1-i;j++) if(strcmp(stuno[j],stuno[j+1])&gt;0) &#123; strcpy(num,stuno[j]); strcpy(stuno[j],stuno[j+1]); strcpy(stuno[j+1],num); &#125;&#125;/*3.23*/int searchno(char (*stuno)[11],char *no,int n)&#123; int i,j; int m; for(i=0;i&lt;n;i++) &#123; m=0; for(j=0;j&lt;11;j++) if(stuno[i][j]!=no[j]) &#123; m=1; break; &#125; if(m==0) return i; &#125; return -1;&#125;int main()&#123; return 0;&#125; Experiment 10这可能是最近最简单的作业如对结构体抱有疑问，请看往期介绍（逃 随便挑几个溜了 Basis2.112345678910111213141516171819#include &lt;stdio.h&gt;struct people&#123; char name[10]; int age; int money;&#125;;int main(void)&#123; int i; struct people per[3]=&#123; &#123;"李明",25,2500&#125;, &#123;"王利",22,2300&#125;, &#123;"赵勇",30,3000&#125; &#125;; printf("姓名 年龄 月薪\n"); for(i=0;i&lt;3;i++)&#123; printf(" %s %d %d\n",per[i].name,per[i].age,per[i].money); &#125; return 0;&#125; 2.4123456789101112#include &lt;stdio.h&gt;typedef struct tada&#123; int year; int month; int day;&#125;;int main(void)&#123; struct tada a; printf("输入年、月、日："); scanf("%d%d%d",&amp;a.year,&amp;a.month,&amp;a.day); printf(" %d年 %d月 %d日\n",a.year,a.month,a.day);&#125; Advanced3.112345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758#include &lt;stdio.h&gt;struct studentInformationOne&#123; char studentID[11]; int credit; int score; float average;&#125;;struct studentInformationTwo&#123; char name[10]; char data[15]; int credit; int score; float average;&#125;;struct list&#123; char name[10]; char address[100];&#125;;struct stock&#123; char name[10]; int value; char data[15];&#125;;struct inventory&#123; char number[10]; char name[10]; int itemIn; int theID;&#125;;int main()&#123; struct studentInformationOne a; struct studentInformationTwo b; struct list c; struct stock d; struct inventory e; printf("输入学生学号、完成的学分、累积成绩分数、平均值组。"); scanf("%s%d%d%f",a.studentID,&amp;a.credit,&amp;a.score,&amp;a.average); printf("输入学生姓名、出生日期、完成的学分数、累积成绩分数、平均值。"); scanf("%s%s%d%d%f",b.name,b.data,&amp;b.credit,&amp;b.score,&amp;b.average); printf("输入人名、地址。"); scanf("%s%s",c.name,c.address); printf("输入股票名称、股票价格、购买日期"); scanf("%s%d%s",d.name,&amp;d.value,d.data); printf("输入零件号码、零件名称、库存量、记录员编号"); scanf("%s%s%d%d",e.number,e.name,&amp;e.itemIn,&amp;e.theID); printf("学生学号%s 完成的学分%d 累积成绩分数%d 平均值组%f。\n",a.studentID,a.credit,a.score,a.average); printf("学生姓名%s 出生日期%s 完成的学分数%d 累积成绩分数%d 平均值%f.\n",b.name,b.data,b.credit,b.score,b.average); printf("人名%s 地址%s。\n",c.name,c.address); printf("输入股票名称%s 股票价格%d 购买日期%s.\n",d.name,d.value,d.data); printf("输入零件号码%s 零件名称%s 库存量%d 记录员编号%d.\n",e.number,e.name,e.itemIn,e.theID); return 0;&#125; 3.21234567891011121314151617#include &lt;stdio.h&gt;struct data&#123; int house; int fen;&#125;;int main(void)&#123; struct data a; scanf("%d %d",&amp;a.house,&amp;a.fen); if(a.fen==59)&#123; if(a.house==12)&#123; printf("1 00"); &#125; else &#123; printf("%d 00",a.house+1); &#125; &#125; else printf("%d %d",a.house,a.fen+1);&#125; 3.10123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110#include &lt;stdio.h&gt;struct Data&#123; int year; int month; int day;&#125;;typedef struct Data DATA;DATA larger(DATA d1,DATA d2);int days(DATA data);int main(void)&#123; DATA m; DATA data1,data2; scanf("%d%d%d",&amp;data1.year,&amp;data1.month,&amp;data1.day); scanf("%d%d%d",&amp;data2.year,&amp;data2.month,&amp;data2.day); m=larger(data1,data2); printf("%d %d %d \n",m.year,m.month,m.day);&#125;DATA larger(DATA d1,DATA d2)&#123; if(days(d1)-days(d2)&gt;0) return d1; else return d2;&#125;int days(DATA data)&#123; int m; if(data.year%4==0)&#123; m=(data.year-1900)/4*1461; switch (data.month)&#123; case 1: m+=0; break; case 2: m+=31; break; case 3: m+=60; break; case 4: m+=91; break; case 5: m+=121; break; case 6: m+=152; break; case 7: m+=182; break; case 8: m+=213; break; case 9: m+=244; break; case 10: m+=274; break; case 11: m+=305; break; default : m+=335; &#125; return (m+data.day); &#125; else&#123; m=(data.year-1900)/4*1461+(data.year-1900)%4*365; switch (data.month)&#123; case 1: m+=0; break; case 2: m+=31; break; case 3: m+=61; break; case 4: m+=92; break; case 5: m+=122; break; case 6: m+=153; break; case 7: m+=183; break; case 8: m+=214; break; case 9: m+=245; break; case 10: m+=275; break; case 11: m+=306; break; default : m+=336; &#125; return (m+data.day); &#125;&#125; Experiment 11文件总是问题最多的是不是觉得每次都要手动排序很麻烦？qsort()函数可以帮你解决这个问题～ qsort()标准库函数的使用qsort函数包含在&lt;stdlib.h&gt;中 qsort函数声明如下： void qsort(void * base,size_t nmemb,size_t size ,int(*compar)(const void *,const void *)); 参数说明： base,要排序的数组 nmemb,数组中元素的数目 size,每个数组元素占用的内存空间，可使用sizeof函数获得 compar,指向函数的指针也即函数指针。这个函数用来比较两个数组元素，第一个参数大于，等于，小于第二个参数时，分别显示正值，零，负值。 下面看几个例子： 123456789101112131415161718192021222324252627282930313233343536#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;math.h&gt;#include &lt;string.h&gt;int main(void)&#123; int i; int a[10]=&#123;0,1,2,3,4,5,6,7,8,9&#125;; char b[10]=&#123;'a','b','c','d','e','f','g','h','i','j'&#125;; double c[10]=&#123;0.1,0.2,0.9,0.5,0.3,0.6,0.7,0.8,1.1,1.2&#125;; int cmp1(const void * a,const void * b)&#123; return (*(int*)a-*(int*)b);//a&gt;b 返回正值 &#125; int cmp2(const void * a,const void *b)&#123; return(*(char*)a-*(char*)b); &#125; int cmp3(const void * a,const void * b)&#123; if(fabs(*(double*)a-*(double *)b)&lt;1*exp(-20)) return 0; else return(((*(double*)a-*(double*)b)&gt;0)?1:-1); &#125; qsort(a,10,sizeof(int),&amp;cmp1);//对于函数指针（指向函数的指针），直接传入函数名和函数名进行&amp; //运算都是可以的，因为在调用函数时也是取的函数的地址 qsort(b,10,sizeof(char),cmp2); qsort(c,10,sizeof(double),cmp3); for(i=0;i&lt;10;i++) printf("%d ",a[i]); for(i=0;i&lt;10;i++) printf("%c ",b[i]); for(i=0;i&lt;10;i++) printf("%lf ",c[i]); return 0;&#125; Basis2.312345678910111213141516171819202122232425262728#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;int main(void)&#123; FILE *fp; char str[100]; int i = 0; if ((fp = fopen("test.dat", "wb")) == NULL) &#123; printf("Can not open the file\n"); return 1; &#125; printf("Input a string:\n"); gets(str); while (str[i] != '!') &#123; if (str[i] &gt;= 'a' &amp;&amp; str[i] &lt;= 'z') &#123; str[i] = str[i]-32; &#125; fputc(str[i], fp); i++; &#125; fclose(fp); fp = fopen("test.dat", "rb"); fgets(str, (int)(strlen(str)+1), fp); printf("%s\n",str); fclose(fp); return 0;&#125; 2.5使用qsort（）函数1234567891011121314151617181920212223242526272829#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;time.h&gt;int cmp1(const void * a,const void * b);int main(void)&#123; FILE *fp=fopen("rand.txt","w"); /*要写入的文件*/ FILE *fp2=NULL ; int i; int a[10000]; srand((unsigned int)time(NULL)); /*不可放在循环内，否则每次得到相同的“随机数”*/ for (i = 0; i&lt;10000; i++) &#123; a[i]=rand(); fprintf(fp,"%d ",a[i]); &#125; fclose(fp); qsort(a, 10000, sizeof(int), &amp;cmp1);/*排序函数，调用qsort()标准库函数进行排序*/ fp2=fopen("sort_rand.txt","w"); /*排序之后要写入的文件*/ for (i = 0; i&lt;10000; i++) &#123; fprintf(fp,"%d ",a[i]); &#125; fclose(fp2); return 0;&#125;int cmp1(const void * a,const void * b) &#123; return (*(int*)a-*(int*)b);//a&gt;b 返回正值&#125; Advanced3.61234567891011121314151617181920212223242526272829303132#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;struct information &#123; char a[15]; char b[10]; int c; double d; char e[10];&#125;;int main(void) &#123; struct information inf[5]; int i; FILE *fp; for (i = 0; i &lt; 5; i++) &#123; scanf("%s%s%d%lf%s", inf[5].a, inf[5].b, &amp;inf[5].c, &amp;inf[5].d, inf[5].e); &#125; fp = fopen("emloy.txt", "wb"); for (i = 0; i &lt; 5; i++) &#123; fwrite(&amp;inf[i], sizeof(struct information), 1, fp); &#125; fclose(fp); fp = fopen("emloy.txt", "rb"); for (i = 0; i &lt; 5; i++) &#123; fread(&amp;inf[i], sizeof(struct information), 1, fp); printf("%s\t%s\t%d\t%.2lf\t%s\n",inf[5].a,inf[5].b,inf[5].c,inf[5].d,inf[5].e); &#125; fclose(fp); return 0;&#125; 3.71234567891011121314151617181920212223242526#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;int main(void) &#123; FILE *fp; char ch1,ch2; fp = fopen("test", "r"); if (fp == NULL) &#123; printf("open file failed !\n"); return 1; &#125; ch1 = ch2 = 49; //ascii码 while (ch1 != EOF) &#123; if (ch1 == '\n')&#123; ch2++; putchar(ch1); putchar(ch2); ch1 = fgetc(fp); &#125; else &#123; putchar(ch1); ch1 = fgetc(fp); &#125; &#125; putchar('\n'); return 0;&#125; 3.91234567891011121314151617181920212223242526272829303132333435#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;int main(void) &#123; int a[18] = &#123;5,96,87,78,93,21,4,92,82,85,87,6,72,69,85,75,81,73&#125;; FILE *fp; int i,avg = 0,j,temp; fp = fopen("dat", "wb"); fwrite(a, sizeof(a), 1, fp); fclose(fp); fp = fopen("dat", "rb"); fread(&amp;j, sizeof(int), 1, fp); for (i = 0; i &lt; j; i++) &#123; fread(&amp;temp, sizeof(int), 1, fp); avg += temp; &#125; printf("%d\n",avg/j); fread(&amp;j, sizeof(int), 1, fp); avg = 0; for (i = 0; i &lt; j; i++) &#123; fread(&amp;temp, sizeof(int), 1, fp); avg += temp; &#125; printf("%d\n",avg/j); avg = 0; fread(&amp;j, sizeof(int), 1, fp); for (i = 0; i &lt; j; i++) &#123; fread(&amp;temp, sizeof(int), 1, fp); avg += temp; &#125; printf("%d\n",avg/j); fclose(fp); return 0;&#125; 3.10123456789101112131415#include &lt;stdio.h&gt;int main(void)&#123; char a; FILE *fp; if((fp=fopen("text.txt","r"))==NULL)&#123; printf("open failed"); return 1; &#125; while((a=fgetc(fp))!=EOF)&#123; printf("%c",a); fseek(fp,1,1);//偏移一位 &#125; fclose(fp); return 0;&#125; 3.131234567891011121314151617181920212223242526272829303132#include &lt;stdio.h&gt;int main(void)&#123; float sum; int i,j; FILE *fp; float a; if((fp=fopen("grades.bin","wb"))==NULL)&#123; printf("open failed"); return 1; &#125; for(i=0;i&lt;5;i++)&#123; for(j=0;j&lt;4;j++)&#123; scanf("%f",&amp;a); fwrite(&amp;a,sizeof(float),1,fp); &#125; &#125; fclose(fp); if((fp=fopen("grades.bin","rb"))==NULL)&#123; printf("¥Úø™ ß∞‹"); return 2; &#125; for(i=0;i&lt;5;i++)&#123; sum=0; for(j=0;j&lt;4;j++)&#123; fread(&amp;a,sizeof(float),1,fp); sum+=a; &#125; printf("%.2f\t",sum/4); &#125; fclose(fp); return 0;&#125; 怎样提高效率才是我们最应该想的事情，不要舍本逐末 Experiment 12Basis2.11234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#include &lt;stdio.h&gt;#include &lt;termios.h&gt;#include &lt;unistd.h&gt;#include &lt;stdlib.h&gt;#include &lt;time.h&gt;#include &lt;stdbool.h&gt;#include &lt;errno.h&gt;int min=0;int choose[5] = &#123;0&#125;;int clocks[3][3] = &#123;&#123;10,9,6&#125;,&#123;9,12,5&#125;,&#123;14,10,8&#125;&#125;;int main(void)&#123; int i,j,k,l,m; int c = 0; for(i = 0;i &lt; 3; i++)&#123; c = 0; for(j = 0;j &lt; 3; j++)&#123; c += clocks[i][j]; for(k = 0;k &lt; 3; k++)&#123; c += clocks[j][k]; for(l = 0;l &lt; 3; l++)&#123; c += clocks[k][l]; for(m = 0;m &lt; 3; m++)&#123; c += clocks[l][m]; if(i == 0)&#123; choose[0] = i; choose[1] = j; choose[2] = k; choose[3] = l; choose[4] = m; min = c; &#125; else if (min &gt; c) &#123; min = c; choose[0] = i; choose[1] = j; choose[2] = k; choose[3] = l; choose[4] = m; &#125; c -= clocks[l][m]; &#125; c -= clocks[k][l]; &#125; c -= clocks[j][k]; &#125; c -= clocks[i][j]; &#125; &#125; for(i = 0;i &lt; 5; i++)&#123; printf("%d ",choose[i]+1); &#125; putchar('\n'); printf("%d\n",min); return 0;&#125; Advanced3.1(Unix/Linux)1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162#include &lt;stdio.h&gt;#include &lt;termios.h&gt;#include &lt;unistd.h&gt;#include &lt;stdlib.h&gt;#include &lt;stdbool.h&gt;#include &lt;errno.h&gt;#define ECHOFLAGS (ECHO | ECHOE | ECHOK | ECHONL)int set_disp_mode(int fd,int option)&#123; int err; struct termios term; if(tcgetattr(fd,&amp;term)==-1)&#123; perror("Cannot get the attribution of the terminal"); return 1; &#125; if(option) term.c_lflag|=ECHOFLAGS; else term.c_lflag &amp;=~ECHOFLAGS; err=tcsetattr(fd,TCSAFLUSH,&amp;term); if(err==-1 &amp;&amp; err==EINTR)&#123; perror("Cannot set the attribution of the terminal"); return 1; &#125; return 0;&#125;int getpasswd(char* passwd, int size)&#123; int c; int n = 0; printf("Please Input password:"); do&#123; c=getchar(); if (c != '\n'|c!='\r')&#123; passwd[n++] = c; &#125; &#125; while (c != '\n' &amp;&amp; c !='\r' &amp;&amp; n &lt; (size - 1)); passwd[n] = '\0'; return n;&#125;int main(void)&#123; char *p,passwd[20],corectPass[20] = &#123;"nothingissafe"&#125;; int n = 3; set_disp_mode(STDIN_FILENO,0); while (n--) &#123; getpasswd(passwd, sizeof(passwd)); p=passwd; while(*p!='\n') &#123; p++; &#125; *p='\0'; if (strcmp(passwd,corectPass) == 0) &#123; printf("Welcome!\n"); break; &#125; printf("Wrong Password!\n"); &#125; set_disp_mode(STDIN_FILENO,1); return 0;&#125; 3.21234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#include &lt;stdio.h&gt;#include &lt;termios.h&gt;#include &lt;unistd.h&gt;#include &lt;stdlib.h&gt;#include &lt;time.h&gt;#include &lt;stdbool.h&gt;#include &lt;errno.h&gt;int randNumber(void);int main(void) &#123; srand((unsigned)time(NULL)); int a[10000],count = 0; FILE *fp1,*fp2 = NULL; if ((fp1 = fopen("data.txt", "w+")) == NULL) &#123; printf("Can't open file:%s\n", "data.txt"); exit(0); &#125; for (int i = 0; i&lt;10000; i++) &#123; a[i] = randNumber(); fprintf(fp1,"%d ",a[i]); &#125; fclose(fp1); for (int i = 0; i &lt; 10000; i++) &#123; int unitPlace = (a[i]/1)%10; int thousandPlace = (a[i]/1000)%10; if (unitPlace == thousandPlace) &#123; count++; &#125; if (a[i]%2 == 0) &#123; a[i] = a[i]*10; &#125; &#125; fp2=fopen("data.txt","w+"); for (int i = 0; i &lt; 10000; i++) &#123; fprintf(fp1,"%d ",a[i]); &#125; fclose(fp2); printf("The number of unitPlace equls to unitPlace:%d\n",count); return 0;&#125;int randNumber() &#123; return rand()%9000 + 1000;&#125; 3.5123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129#include &lt;stdio.h&gt;#include &lt;termios.h&gt;#include &lt;unistd.h&gt;#include &lt;stdlib.h&gt;#include &lt;time.h&gt;#include &lt;stdbool.h&gt;#include &lt;errno.h&gt;typedef struct TeleType&#123; char data[30]; struct TeleType *next;&#125; NODE;NODE *createList(void);//1void prn(NODE *head);//2NODE *first_insert(NODE *head);//3NODE *reverse_copy(NODE *head);//4void free_link(NODE *head);//5void countstr(NODE* head);//6int main(void) &#123; NODE *head = NULL; NODE *head1 = NULL; printf("put '0' to end\n"); head = createList(); prn(head); first_insert(head); prn(head); reverse_copy(head); prn(head1); free_link(head); return 0;&#125;NODE *createList()&#123; NODE *head = NULL,*p, *p1 = NULL; p = (NODE*)malloc(sizeof(NODE)); p-&gt;next = NULL; head = p; p1 = head; while(true)&#123; p = (NODE*)malloc(sizeof(NODE)); scanf("%s", p-&gt;data); p-&gt;next = NULL; if(strcmp(p-&gt;data , "0") == 0)&#123; free(p); break; &#125; p1-&gt;next = p; p1 = p; &#125; return head;&#125;NODE *first_insert(NODE* head)&#123; NODE *p1, *p2, *p; int index = 1,count = 0; p1 = head; p2 = p1-&gt;next; p = (NODE*)malloc(sizeof(NODE)); scanf("%s", p-&gt;data); p-&gt;next = NULL; while(p2 != NULL) &#123; count++; if(count == index)&#123; p -&gt; next = p2; p1 -&gt; next = p; break; &#125; p1 = p2; p2 = p2-&gt;next; &#125; return head;&#125;NODE *reverse_copy(NODE *head1)&#123; NODE *head = NULL,*p,*p2,*p1 = NULL; p = (NODE*)malloc(sizeof(NODE)); p-&gt;next = NULL; head = p; p1 = head; p2 = head1-&gt;next; while(p2 != NULL)&#123; p = (NODE*)malloc(sizeof(NODE)); strcpy(p-&gt;data,p2-&gt;data); p = p -&gt;next; &#125; p-&gt;next = NULL; return head;&#125;void free_link(NODE *head)&#123; NODE *p, *p1; p = head; while(p != NULL)&#123; p1 = p; p = p -&gt; next; free(p1); &#125;&#125;void prn(NODE *head)&#123; NODE *p; p = head-&gt;next; while(p != NULL)&#123; printf("data is %s\n", p-&gt;data); p = p-&gt;next; &#125;&#125;void countstr(NODE* head) &#123; char a[30]; int count = 0; printf("\nPut string which you wanna cheak:"); gets(a); NODE *p; p = head-&gt;next; while(p != NULL)&#123; if (strcmp(a, p-&gt;data) == 0) &#123; count++; &#125; p = p-&gt;next; &#125; printf("It shows %d times\n",count);&#125; DONE!XDDDDDDDDDDDDDD]]></content>
      <tags>
        <tag>C Language Homework</tag>
        <tag>C Language</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[install WebDriverAgent on the real iOS device]]></title>
    <url>%2F2018%2F01%2Finstall-WebDriverAgent-on-the-real-iOS-device%2F</url>
    <content type="text"><![CDATA[Documented problems during the installation process and be sure to use a network proxy WebDriverAgent On the last year’s ‘SeleniumConf’, Facebook introduced a new iOS mobile testing framework - WebDriverAgent Now it is able to support real device for test. README.md on Github WebDriverAgent is a WebDriver server implementation for iOS that can be used to remote control iOS devices. It allows you to launch &amp; kill applications, tap &amp; scroll views or confirm view presence on a screen. This makes it a perfect tool for application end-to-end testing or general purpose device automation. It works by linking XCTest.framework and calling Apple’s API to execute commands directly on a device. WebDriverAgent is developed and used at Facebook for end-to-end testing and is successfully adopted by Appium. Features Works with device &amp; simulator Implements most of WebDriver Spec Implements part of Mobile JSON Wire Protocol Spec USB support for devices Inspector endpoint with friendly user interface to inspect current device state Easy development cycle as it can be launched &amp; debugged directly via Xcode Unsupported yet, but works with tvOS &amp; OSX StartIf you did not install Node.js and brew, please click here The first is to install Carthage,the script file will use Carthage to download all the dependencies, and use npm package to corresponding js files. 1$ brew install carthage Try to upgrade to the latest version of Xcode, keep iOS version is greater than 9.3 Download the source code from github 1$ git clone https://github.com/facebook/WebDriverAgent Run the script 12$ cd WebDriverAgent$ ./Scripts/bootstrap.sh *error? The terminal gives the following prompt: 1$ npm WARN deprecated minimatch@2.0.10: Please update to minimatch 3.0.2 or higher to avoid a RegExp Dos issue Although it is to remind me to upgrade for ignoring the warning, and not necessarily wrong, Emm,it will really be the reason that the version is too low? So running： 123$ npm update minimatch@3.0.2$ npm update -d$ npm -v minimatch The version number has not changed? ? Tying to Reinstall： 123$ npm install -g npm@3$ npm -v minimatch3.10.10 Upgrade successfully, run again 1$ ./Scripts/bootstrap.sh Upgrade successfully！ Configure Double-click to openWebDriverAgent.xcodeproj Product Bundle identifier Change the contents of this column casually,just do not like everyone else. These three choose your own personal free development certificate，same withProduct Bundle identifier. Follow TARGETS to change the content Run and Test Connect iPhone, then choose your own device Choose Scheme -&gt; WebDriverAgentRunner The run Product -&gt; Test If the issue appears in the upper right corner, click issue, the system will help you upgrade At this point the desktop will appear such an icon, automatically open and will also automatically minimized. Check Xcode console at this time: Through the IP and port given above, plus / status to your address synthesis. For example http://192.168.2.2:8100/status, then the browser will open. If a bunch of JSON appears, WDA installation is successful. Port forwardingMany Chinese-made iPhones do not have direct access to the phone’s IP and port, the solution is to forward it to the Mac. 12$ brew install imobiledevice$ iproxy 8100 8100 Use iproxy —help to find more specific usage. At this time by visitinghttp://192.168.2.2:8100/statusto confirm WDA is running successfully or not. The inspector address is http://192.168.2.2:8100/inspector, inspector is used to view the UI layer, easy to write test scripts Terminal instead of XcodeIn general, it is better to be fully automated for continuous integration 123456789# Unlock keychain so that it can be signed normallyPASSWORD="replace-with-your-password"security unlock-keychain -p $PASSWORD ~/Library/Keychains/login.keychain# Get the device's UDIDUDID=$(idevice_id -l | head -n1)# Run to testxcodebuild -project WebDriverAgent.xcodeproj -scheme WebDriverAgentRunner -destination "id=$UDID" test OQ:There are some strange problems, for example Failed to authorize rights (0x1) with status: -60007 The bundle “WebDriverAgentRunner” couldn’t be loaded because it is damaged or missing necessary resources Find solutions in THIS official wiki. If the above methods can not solve the problem. Try these steps git pullupgrade WebDriverAgent Uninstall WebDriverAgent Updated Xcode Updated macOS Restart Mac At lastBased on the Python Automation Framework Addresshttps://github.com/NetEaseGame/ATX Reference： https://testerhome.com/topics/7220 https://github.com/facebook/WebDriverAgent/blob/master/README.md https://testerhome.com/topics/4904]]></content>
      <tags>
        <tag>iOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[认识文本文件与二进制文件]]></title>
    <url>%2F2017%2F12%2F%E8%AE%A4%E8%AF%86%E6%96%87%E6%9C%AC%E6%96%87%E4%BB%B6%E4%B8%8E%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%96%87%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[C Primer Plus第六版 417页有这样一段话：“像Unix和Linux这样只有一种文件类型的系统，带b字母的模式和不带b字母的模式相同” 不讨论最底层，因为我太菜 发现问题总所周知，fopen()的函数原型是：FILE *fopen(const char filename, const char mode) 关于char *mode在 C primer Plus(第六版) 这本书对做出了介绍 模式字符串 含义 “r” （read）以只读模式打开文件 “w” （write）以写模式打开文件，把现有的文件长度截成0，如果文件不存在，则创建对应的一个新文件 “a” （append）以写模式打开文件，在现有文件末尾添加内容，如果文件不存在，则创建对应的一个新文件 “r+” 以更新模式打开文件（即可以读写文件） “w+” 以更新模式打开文件（即读和写），如果文件存在，则将其长度截成0；如果文件不存在，则创建一个新文件 “a+” 以更新模式打开文件（即读和写），在现有文件末尾添加内容，如果文件不存在，则创建一个新文件；可以读整个文件，但是只能从末尾添加内容 “rb”、”wb”、”ab”、”rb+”、”r+b”、 “wb+”、”w+b”、”ab+”、”a+b” 与上一个模式类似，但是是以二进制模式而不是文本模式打开文件 “wx”、”wbx”、”w+x”、”wb+x”或”w+bx” （c11）类似非x模式，但是如果文件已存在或以独占模式打开文件，则打开文件失败 但下方有一段话： “像Unix和Linux这样只有一种文件类型的系统，带b字母的模式和不带b字母的模式相同” 那么，译者的意思是，Windows不只有一种文件类型的系统，而Linux只有一种？那是什么差异导致的呢？ 探索上机首先自然是在不同环境下测试啦 测试代码123456789#include &lt;stdio.h&gt;int main(void)&#123; FILE *fp = NULL; fp = fopen("test.txt", "wb+");//使用二进制格式保存 fprintf(fp, "This is testing for fprintf...\n"); fputs("This is testing for fputs...\n", fp); fclose(fp); return 0;&#125; 测试环境windows 10 -1709 -VC6++ 可以发现文本模式并不能正确识别 Kail Linux -2017.3-GCC 7.2 Linux可以识别 macOS -High Sierra-Xcode 9.3 macOS上也可以识别 实践证明fopen()函数在Linux和UNIX下的确不需要带“b”的模式 疑问一顿Google猛如虎，结果下来啥没有。任何系统本质都是二进制文件，那书上这句话究竟想表达什么呢？或者说为什么Linux不需要带“b”字母的模式呢？ 总结比较广义上的二进制文件包括文本文件，这里讨论的是狭义上的二进制文件与文本文件的比较： 能存储的数据类型不同文本文件只能存储char型字符变量。二进制文件可以存储char/int/short/long/float/……各种变量值。 每条数据的长度文本文件每条数据通常是固定长度的。以ASCII为例，每条数据(每个字符)都是1个字节。二进制文件每条数据不固定。如short占两个字节，int占四个字节，float占8个字节…… 读取的软件不同文本文件编辑器就可以读写。比如记事本、NotePad++、Vim等。二进制文件需要特别的解码器。比如bmp文件需要图像查看器，rmvb需要播放器 文件读写过程明白二者的区别，也需要知道文件的读写过程。 以读文件为例，实际上是磁盘 》》 文件缓冲区》》应用程序内存空间 这两个转化过程。我们说“文本文件和二进制文件没有区别”，实际上针对的是第一个过程；既然没有区别，那么打开方式不同，为何显示内容就不同呢？这个区别实际上是第二个过程造成的。 文件实际上包括两部分，控制信息和内容信息。纯文本文件仅仅是没有控制格式信息罢了；实际上也是一种特殊的二进制文件。所以，我们很难区分二者的不同，因为他们的概念上不是完全互斥的。 在Windows和DOS系统中，狭义的文本文件是指扩展名为txt的文件。实际上，那些没有规定格式的，由可理解的的ASCII以及其他编码文字组成的文件都是文本文件，如C源程序文件，HTML超文本，XML。除此之外的其他文件都是二进制文件，如Word文件DOCX，图象格式文件JPG。 但是，所谓使用fopen标志打开文本文件与二进制文件的说法并不准确。正确的说法应该是: 以文本方式和二进制方式打开文件。因为我们用两种方式都可以打开任意的文件。 即使这样，为什么还要区分两种方式呢? 操作差异这是因为这两种方式在读写文件时的操作是不一样的。 二进制方式很简单，读文件时，会原封不动的读出文件的全部內容，写的時候，也是把內存缓冲区的內容原封不动的写到文件中。 而文本方式就不一样了，在读文件时，会将换行符号CRLF(0x0D 0x0A)全部转换成单个的0x0A，并且当遇到结束符CTRLZ(0x1A)时，就认为文件已经结束。相应的，写文件时，会将所有的0x0A换成0x0D0x0A。 上面这一点通俗来说就是 许多MS-DOS编译器都用Ctrl+Z标记文本文件的结尾。以文本模式打开这样的文件时，C能识别作为文件结尾的标记的字符。但是，以二进制模式打开相同的文件时，Ctrl+Z字符被看作是文件中的一个字符，而实际的文件结尾符在该字符的后面，或者文件中可能用空字符填充，使得该文件大小是256的倍数。 MS-DOS用\r\n组合表示文本文件的换行。以文本模式打开相同文件时，C程序把\r\n当作\n。但是，以二进制模式打开该文件时，程序能看见这两个字符。通常，UNIX文本文件既没有Ctrl+Z，也没有\r。 所以，若使用文本方式打开二进制文件时，就很容易出现文件读不完整，或內容不对的错误。即使是用文本方式打开文本文件，也要谨慎使用，比如复制文件，就不应该使用文本方式。 系统差异要特別注意的是，上面这样的说法仅适用于DOS和Windows系统。 在Unix和其他一些系统中，沒有文本方式和二进制方式的区分，使不使用’b’标志都是一样的。这是由于不同操作系统对文本文件换行符的定义，和C语言中换行符的定义有所不同而造成的。 如上文已提到，DOS和Windows系统使用CRLF(0x0D 0x0A)双字节作为文本文件换行符，而Unix文本文件的换行符只有一个字节LF(0x0A)为。在C语言中，也是以LF即&#39;\n&#39;为换行符。 由于DOS/Windows定义的换行符和C语言的不一致，C语言的标准输入输出函数适行读写文本文件时，就适行了CRLF-&gt;LF的转换。而Unix的定义和C语言的是一样的，就不必转换了。 那么，为什么会有定义不一致的情况呢？这纯属历史原因。当初C是在Unix上创造和发展的，对换行的定义自然就一样了。其后C被引入到DOS系统，为了使原有的C程序能不加修改的读写DOS的文本文件，所以就在文件读写上做了修改。随着DOS/Windows逐渐成为主流平台，这个当初为了兼容而做的修改給众多的C语言开发者添了这样一个小小的麻烦。 *转换办法dos2unix/unix2dos一般Linux发行版中都带有这个小工具，只能把DOS转换为UNIX文件，命令如下： # dos2unix dosfile.txt 上面的命令会去掉行尾的^M符号。 vimVim是一个vi的改进版本，可以运行在Windows和Linux平台上，使用方法如下： # vimdosfile.txt DOS转UNIX：:setfileformat=unix UNIX转DOS：:setfileformat=dos :wq 如果你需要把Unix文本文件转换为DOS文本文件，输入:setfileformat=dos，你也可以使用ff来替代fileformat，此时可以输入:set ff=dos。你可以输入:help fileformat来获得跟多的关于选项信息。 注：为了能让vim可以自动识别DOS和UNIX文本文件格式，可以在.vimrc(Linux)或_vimrc（Windows）配置文件中加入如下一行设置： ​ setfileformats=dos,unix ​ 设置完成后，使用vim打开DOS文本文件就不会显示^M字符了。 tr使用tr命令拷贝标准输入到标准输出，替换或者删除掉选择的字符，只能把DOS转换为UNIX文件，命令如下： # tr -d ‘\r’&lt; dosfile.txt &gt; unixfile.txt EmacsEmacs是一个Unix下面的文本编辑工具。它会在底部的状态栏上显示文件的信息。 DOS转UNIX ：M-xset-buffer-file-coding-system Unix UNIX转DOS：M-xset-buffer-file-coding-system dos sed在DOS文件格式中使用CR/LF换行，在Unix下仅使用LF换行，sed替换命令如下： DOS转UNIX：$ sed ‘s/.$//’dosfile.txt &gt; unixfile.txt UNIX转DOS：$ sed ’s/$/\r/’unixfile.txt &gt; dosfile.txt Perl Perl是相当直接，你添加或删除掉文件每行结尾的CR字符。 DOS转UNIX：perl -p -e ‘s/\r$//’&lt; dosfile.txt &gt; unixfile.txt UNIX转DOS：perl -p -e ‘s/$/\r/’&lt; unixfile.txt &gt; dosfile.txt awkDOS转UNIX：awk ‘{sub(“\r$”,“”, $0);print $0}’ dosfile.txt &gt; unixfile.txt UNIX转DOS：awk ‘{sub(“$”,“\r”, $0);print $0}’ dosfile.txt &gt; unixfile.txt Python DOS转UNIX： python -c “importsys; map(sys.stdout.write, (l[:-2] + ‘\n’ for l in sys.stdin.readlines()))”&lt; dosfile.txt &gt; unixfile.txt UNIX转DOS： python -c “importsys; map(sys.stdout.write, (l[:-1] + ‘\r\n’ for l in sys.stdin.readlines()))”&lt; dosfile.txt &gt; unixfile.txt 欢迎补充…]]></content>
      <tags>
        <tag>C Language Homework</tag>
        <tag>C Language standard</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Primary exploration undefined behavior in C/C++]]></title>
    <url>%2F2017%2F12%2FPrimary-exploration-undefined-behavior-in-C%5CC%2B%2B%2F</url>
    <content type="text"><![CDATA[引子：C 语言中int main()和 void main() 有何区别？ 前言 文章基于官方文档汇总而成，引用地址会放在文章末尾，若有修改意见欢迎评论指出～ 渣翻译请见谅，如果翻译有定义性错误，还请评论指出，谢谢 ! 刚开始上课的时候，难免会接触到int main()和void main()，当初我只是初步认识到了void main()是一种 不标准 的写法，但是今天进一步认识到void main()算是一种Undefined behavior(未定义行为)。 main函数原型&amp;&amp;终止行为在C和C++中流传着很多版本的main函数原型，不同的书里也有不同的写法。今天我从几种标准(C89/99/11以及C++98/03/11/14)的角度来寻找一下什么是“标准行为”以及在主函数中return后发生了什么。 比较常见的是下面几种： 12345void main()main()int main()int main(void)int main(int argc,char *argv[]) void main()首先，从标准角度(所有版本)来说，void main()肯定是错的，没有任何标准(C89/99/11以及C++98/03/11/14)中允许过这种写法。 但是我在APUE里看到了一种把主函数写为void main()的原因，不知道是不是有人从这个角度说的然后就以讹传讹了。 The problem is that these compilers don’t know that an exit from main is the same as a return. One way around these warnings, which become annoying after a while, is to use return instead of exit from main. But doing this prevents us from using the UNIX System’s grep utility to locate all calls to exit from a program. Another solution is to declare main as returning void, instead of int, and continue calling exit. This gets rid of the compiler warning but doesn’t look right (especially in a programming text), and can generate other compiler warnings, since the return type of main is supposed to be a signed integer. 还有一种可能是从嵌入式来的，没有操作系统，入口点是硬件实现，返回任何东西都没意义。 main()在K&amp;R C与C89里，函数没有显式声明返回类型，则默认是int: C89对函数定义的语法(Syntax)描述如下(注意declaration-specifiers的opt下标符号)： $${declaration\textrm{-}specifiers{opt}}\hspace{2mm}{declarator\hspace{2mm}declaration\textrm{-}list{opt}}\hspace{2mm}{compound\textrm{-}statement}$$ C89中declaration-specifiers在Syntax上为： storage-class-specifier type-specifier type-qualifier 表明在C89中函数的return type可以省略。 K&amp;R C里的描述如下： Various parts may be absent; a minimal function is 1dummy() &#123;&#125; which does nothing and returns nothing. A do-nothing function like this is sometimes useful as a place holder during program development. If the return type is omitted, int is assumed. 所以说： 123func()&#123;&#125;// 等价于int func()&#123;&#125; 但是这种方式在C99之后就被废除掉了(注意declaration-specifiers没有opt下标了)： declaration-specifiers declarator declaration-list(opt) compound-statement 综上，在C89中，函数的返回类型可以省略，但默认为int，即 主函数声明main()隐式是int main()。 int main()int main()和int main(void)在C语言中是有区别的： 123int main()// 不等价于int main(void) 在C语言中参数列表为空(即不提供参数列表也不为void)，表示不提供参数数量和参数类型信息： 12345678int func()&#123; print("func()\n"); return 0;&#125;int main(void)&#123; func(1,2,3,4);// call func();&#125; The empty list in a function declarator that is not part of a definition of that function specifies that no information about the number or types of theparameters is supplied. C99/11 Standard在C99/11标准中，明确定义了对于标准的main函数的两个原型： The function called at program startup is named main. The implementation declares no prototype for this function. It shall be defined with a return type of int and with no parameters: 程序启动时调用的函数名为main，这种实现声明了这个函数没有原型。 它应该用int的返回类型来定义，并且不带参数： 1int main(void) &#123; /* ... */ &#125; or with two parameters (referred to here as argc and argv, though any names may be used, as they are local to the function in which they are declared): 或者带有两个参数（这里称为argc和argv，尽管使用任何名称，因为它们是本地声明的函数）： 1int main(int argc, char *argv[]) &#123; /* ... */ &#125; or equivalent;or in some other implementation-defined manner.If they are declared, the parameters to the main function shall obey the following constraints: 或者等价;或者以某种其他编译器相关实现的方式。 如果被声明，主函数的参数应该遵守以下约束条件： The value of argc shall be nonnegative. argv[argc] shall be a null pointer. If the value of argc is greater than zero, the array members argv[0] through argv[argc-1] inclusive shall contain pointers to strings, which are given implementation-defined values by the host environment prior to program startup. The intent is to supply to the program information determined prior to program startup from elsewhere in the hosted environment. If the host environment is not capable of supplying strings with letters in both uppercase and lowercase, the implementation shall ensure that the strings are received in lowercase. If the value of argc is greater than zero, the string pointed to by argv[0]represents the program name; argv[0][0] shall be the null character if the program name is not available from the host environment. If the value of argc is greater than one, the strings pointed to by argv[1] through argv[argc-1]represent the program parameters. The parameters argc and argv and the strings pointed to by the argv array shall be modifiable by the program, and retain their last-stored values between program startup and program termination. argc的值应该是非负的。 argv[argc] 应该是一个空指针。 如果argc的值大于零，则argv [0]至argv [argc-1]包含的数组成员应该包含指向字符串的指针，这些字符串在程序启动之前由系统环境给定已被定义的值。 其目的是向程序提供在程序启动之前从托管环境中的其他地方确定的信息。 如果系统环境不能提供大小写字母的字符串，则这类实现应确保字符串以小写形式接收。 如果argc的值大于零，则argv [0]指向的字符串代表程序名称; 如果程序名称在主机环境中不可用，那么argv [0][0]应为空字符。 如果argc的值大于1，argv [1]至argv [argc-1]指向的字符串则代表程序参数。 参数argc和argv以及argv数组所指向的字符串应该可以被程序修改，并在程序启动和程序终止之间保留它们的最后存储的值。 C++ Strandard由于C和C++中对于函数参数列表的规则并不一致(C++中参数列表为空代表不接收任何参数)。所以C++中main的原型和ISO C也并不太一样： a function of () returning int and a function of (int, pointer to pointer to char) returning int main 返回的值main必须要有返回值的原因是：在C和C++中使用return-statement都是将return的值作为参数来调用exit/std::exit来终止程序。 If status is zero or EXIT_SUCCESS, an implementation-defined form of the status successful termination is returned. ISO C99/11:If the return type of the main function is a type compatible with int, a return from the initial call to the main function is equivalent to calling the exit function with the value returned by the main function as its argument;reaching the } that terminates the main function returns a value of 0. If the return type is not compatible with int, the termination status returned to the host environment is unspecified. 如果main函数的返回类型是与int兼容的类型，则从初始调用返回到主函数相当于以main函数返回的值为参数来调用exit函数;到达终止 }主函数返回值 0.如果返回类型与int不兼容，则返回到主机环境的终止状态是未指定的。 Forward references: definition of terms (ISO/IEC 9899:201x 7.1.1), the exit function (ISO/IEC 9899:201x 7.22.4.4). 注意： ISO/IEC 9899:201x -6.9.1 #12 If the } that terminates a function is reached, and the value of the function call is used bythe caller, the behavior is undefined. 如果 }到达终止函数，并且函数调用的值被使用的行为是未定义的。 所以函数结尾不写return是undefined behavior 在Xcode9.0环境下，不写return的函数无法通过编译 ISO C++11/14:A return statement in main has the eﬀect of leaving the main function (destroying any objects with automatic storage duration) and calling std::exit with the return value as the argument. If control reaches the end of main without encountering a return statement, the eﬀect is that of executing main中的return语句具有离开main函数的功能（销毁具有自动存储持续时间的任何对象）并以返回值作为参数调用 std :: exit。 如果控制到达主函数的末尾而没有遇到return语句，那么就是执行： 1return 0; 待补充 exit12#include &lt;stdlib.h&gt;void exit(int status); The exit function causes normal program termination to occur. If more than one call to the exit function is executed by a program, the behavior is undefined. .exit 函数使正常的程序终止执行。如果一个程序执行多个对 exit 函数的调用，其行为将是不确定的。 First, all functions registered by the atexit function are called, in the reverse order of their registration,except that a function is called after any previously registered functions that had already been called at the time it was registered. If, during the call to any such function, a call to the longjmp function is made that would terminate the call to the registered function, the behavior is undefined. Next, all open streams with unwritten buffered data are ﬂushed, all open streams are closed, and all files created by the tmpfile function are removed. Finally, control is returned to the host environment. If the value of status is zero or EXIT_SUCCESS, an implementation-defined form of the status successful termination is returned. If the value of status is EXIT_FAILURE, an implementation-defined form of the status unsuccessful termination is returned. Otherwise the status returned is implementation-defined. 首先，按照相反的顺序调用 atexit 函数所注册的所有函数，除非在注册时调用了之前已经调用的任何已经注册的函数。 如果在调用任何这样的函数期间调用 longjmp 函数来终止对已注册函数的调用，则其行为是不确定的。 接下来，所有开放的未写入的缓冲区数据流被擦除，并关闭所有开放的数据流，并移除由 tmpfile 函数创建的所有文件。 最后，控制权返回到主机环境。 如果状态值为zero或EXIT_SUCCESS，则返回状态 successful termination的自定义形式。 如果状态值为EXIT_FAILURE，则返回状态不成功终止的实现定义形式。 否则，返回的状态是实现其定义的。 The exit function cannot return to its caller. _Exit12#include &lt;stdlib.h&gt;void _Exit(int status); The _Exit function causes normal program termination to occur and control to be returned to the host environment. No functions registered by the atexit function or signal handlers registered by the signal function are called. The status returned to the host environment is determined in the same way as for the exit function (7.20.4.3).Whether open streams with unwritten buffered data are ﬂushed, open streams are closed,or temporary files are removed is implementation-defined.The _Exit function cannot return to its caller. _Exit 函数使正常的程序终止发生，然后控制返回到主机环境。 没有被 atexit 函数注册的函数或者被信号函数注册的信号处理程序将会被调用。 返回到主机环境的状态的确定方式与退出函数（7.20.4.3）的方式相同。无论开放且具有未写入缓冲区的数据流是否被擦除，开放的流是否是关闭的，或者临时文件是否被移除，都是实现其定义的。 _Exit 函数不能返回给它的调用者。 Undefined behavior定义 在计算机程序设计中，未定义行为（英语：undefined behavior）是指行为不可预测的计算机代码。这是一些编程语言的一个特点，最有名的是在C语言中。在这些语言中，为了简化标准，并给予实现一定的灵活性，标准特别地规定某些操作的结果是未定义的，这意味着程序员不能预测会发生什么事。 例如，在C语言中，在任何自动对象被初始化之前，通过非字符类型的左值表达式读取这个变量存储的值会产生未定义行为，除以零或访问数组定义的界限之外的元素（参见缓冲区溢出）也会产生未定义行为。在一般情况下，之后的任何行为是不确定的；甚至只要程序的执行存在未定义行为，在引起未定义行为操作发生之前也可能不要求保证程序的行为可预测（如ISO C++）。特别地，标准从来没有要求编译器判断未定义行为，因此，如果程序调用未定义行为，可能会成功编译，甚至一开始运行时没有错误，只会在另一个系统上，甚至是在另一个日期运行失败。当一个未定义行为的实例发生时，正如语言标准所说，“什么事情都可能发生”，也许什么都没有发生。 和未指定行为(unspecified behavior)不同，未定义行为强调基于不可移植或错误的程序构造，或使用错误的数据。一个符合标准的实现可以在假定未定义行为永远不发生（除了显式使用不严格遵守标准的扩展）的基础上进行优化，可能导致原本存在未定义行为（例如有符号数溢出）的程序经过优化后显示出更加明显的错误（例如死循环）。因此，这种未定义行为一般应被视为bug。 Example in C and C++Attempting to modify a string literal causes undefined behavior 尝试修改字符串字面量会产生未定义行为： 123char * p = "wikipedia";// valid C, ill-formed in C++11, deprecated C++98/C++03 //C++11中错误，C++98/C++03不推荐使用p[0] = 'W'; // undefined behavior 未定义行为 防止这一点的方法之一是将它定义为数组而不是指针： 12char p[] = "wikipedia"; /* 正确 */p[0] = 'W'; Integer division by zero results in undefined behavior 除以零会导致未定义行为。 根据 IEEE 754，float、double和long double类型的值除以零的结果是无穷大或NaN： 1return x/0; // undefined behavior Certain pointer operations may result in undefined behavior: 某些指针操作可能导致未定义行为： 1234int arr[4] = &#123;0, 1, 2, 3&#125;;int *p = arr + 5; // undefined behavior for indexing out of boundsp = 0;int a = *p; // undefined behavior for dereferencing a null pointer In C and C++, the comparison of pointers to objects is only strictly defined if the pointers point to members of the same object, or elements of the same array. Example: 在C和C ++中，如果指针指向相同对象的成员，或者指向同一个数组的元素，那么只能严格定义指向对象的指针。样例： 123456int main(void)&#123; int a = 0; int b = 0; return &amp;a &lt; &amp;b; /* undefined behavior */&#125; Reaching the end of a value-returning function (other than main()) without a return statement results in undefined behavior if the value of the function call is used by the caller: 到达返回数值的函数（除main函数以外）的结尾，而没有一个return语句，会导致未定义行为： 12int f()&#123;&#125; /* undefined behavior if the value of the function call is used*/ Modifying an object between two sequence points more than once produces undefined behavior. It is worth mentioning that there are considerable changes in what causes undefined behavior in relation to sequence points as of C++11. The following example will however cause undefined behavior in both C++ and C. 在两个连续点之间多次修改对象会产生未定义的行为。值得一提的是，与C ++ 11相比，未定义的行为与顺序点的关系有所改变。下面的例子然而会导致C ++和C 中未定义的行为 1i = i++ + 1; // undefined behavior When modifying an object between two sequence points, reading the value of the object for any other purpose than determining the value to be stored is also undefined behavior. 在两个连续点之间修改对象时，除了确定要存储的值之外，读取对象的值也是未定义的行为。 12a[i] = i++; // undefined behaviorprintf("%d %d\n", ++n, power(2, n)); // also undefined behavior BenefitsDocumenting an operation as undefined behavior allows compilers to assume that this operation will never happen in a conforming program. This gives the compiler more information about the code and this information can lead to more optimization opportunities. 将记录为未定义的行为允许编译器假定这个行为永远不会在符合的程序中执行。这给了编译器更多关于代码的信息，这些信息可以有更多机会去优化代码。 C语言的一个例子： An example for the C language: 1234567int foo(unsigned char x)&#123; int value = 2147483600; /* assuming 32 bit int */ value += x; if (value &lt; 2147483600) bar(); return value;&#125; The value of x cannot be negative and, given that signed integer overflow is undefined behavior in C, the compiler can assume that at the line of the if check value &gt;= 2147483600. Thus the if and the call to the function bar can be ignored by the compiler since the if has no side effects and its condition will never be satisfied. The code above is therefore semantically equivalent to: x不能为负值，并且考虑到有符号整数溢出在C中是未定义的行为，编译器可以假设在if检查value &gt;= 2147483600。因此if对函数的调用bar可以被编译器忽略，因为if没有带来任何影响，它的条件永远不会被满足。上面的代码因此在语义上等同于： 12345int foo(unsigned char x)&#123; int value = 2147483600; value += x; return value;&#125; Had the compiler been forced to assume that signed integer overflow has wraparound behavior, then the transformation above would not have been legal. Such optimizations become hard to spot by humans when the code is more complex and other optimizations, like inlining, take place. Another benefit from allowing signed integer overflow to be undefined is that it makes it possible to store and manipulate a variable’s value in a processor register that is larger than the size of the variable in the source code. For example, if the type of a variable as specified in the source code is narrower than the native register width (such as “int on a 64-bit machine, a common scenario), then the compiler can safely use a signed 64-bit integer for the variable in the machine code it produces, without changing the defined behavior of the code. If the behavior of a 32-bit integer under overflow conditions was depended upon by the program, then a compiler would have to insert additional logic when compiling for a 64-bit machine, because the overflow behavior of most machine code instructions depends on the register width. A further important benefit of undefined signed integer overflow is that it enables, though does not require, such erroneous overflows to be detected at compile-time or by static program analysis, or by run-time checks such as the Clang and GCC sanitizers and valgrind; if such overflow was defined with a valid semantics such as wrap-around then compile-time checks would not be possible. 如果编译器被迫假定有符号整数溢出具有环绕行为，那么上面的转换就不合法了。 当代码更复杂时，人们难以发现这样的优化，并作出其他优化，如内联。 允许有符号整数溢出未定义的另一个好处是可以在处理器寄存器中存储和操作变量的值，该寄存器的值大于源代码中变量的大小。例如，如果源代码中指定的变量类型比本地寄存器宽度窄（例如64位机器上的“ int ” ，这是最常见的情况），那么编译器可以安全地使用带符号的 64 位寄存器 机器代码中产生的整数变量，而不会改变代码的定义行为。如果在溢出条件下32位整数的行为被程序所依赖，那么在编译64位机器时，编译器将不得不考虑额外的逻辑，因为大多数机器代码指令的溢出行为取决于寄存器宽度. 未定义的有符号整数溢出的另一个重要好处是，它可以在编译时或通过静态程序分析或通过运行时检查（如Clang和GCC sanitizers和valgrind来检测这种溢出的错误; 如果这样的溢出是用一个有效的语义来定义的，比如环绕行为，那么编译时检查是不可能的。 RisksC and C++ standards have several forms of undefined behavior throughout, which offers increased liberty in compiler implementations and compile-time checks at the expense of undefined run-time behavior if present. In particular, there is an appendix section dedicated to a non-exhaustive listing of common sources of undefined behavior in C. Moreoever, compilers are not required to diagnose code that relies on undefined behavior, due to current static analysis limitations. Hence, it is common for programmers, even experienced ones, to unintentionally rely on undefined behavior either by mistake, or simply because they are not well-versed in the rules of the language that can span over hundreds of pages. This can result in bugs that are exposed when optimizations are enabled on the compiler, or when a compiler of a different vendor or version is used. Testing or fuzzing with dynamic undefined behavior checks enabled, e.g. the Clang sanitizers, can help to catch undefined behavior not diagnosed by the compiler or static analyzers. In scenarios where security is critical, undefined behavior can lead to security vulnerabilities in software. When GCC’s developers changed their compiler in 2008 such that it omitted certain overflow checks that relied on undefined behavior, CERT issued a warning against the newer versions of the compiler. Linux Weekly News pointed out that the same behavior was observed in PathScale C, Microsoft Visual C++ 2005 and several other compilers; the warning was later amended to warn about various compilers. C和C ++标准在整个制定过程中都有几种不确定的行为，如果存在未定义的运行行为，则会增加编译器执行和编译时检查的自由度。特别是有一个附录部分，专门用于列举C中不确定行为的常见来源。不过，由于当前的静态分析限制，编译器不需要诊断依赖于未定义行为的代码。因此，甚至经验丰富的程序员通常会无意中依赖未定义的行为，或者是因为他们不熟悉可能长达数百页的语言规则。这可能会导致在编译器上启用优化时或在使用不同发行商或不同版本的编译器时公开的bug。启用动态未定义行为检查（例如Clang sanitizers）的测试或模糊测试可以帮助捕获未经编译器或静态分析器诊断的未定义行为。 在安全性至关重要的情况下，未定义的行为会导致软件中出现安全漏洞。GCC的开发人员在2008年修改了他们的编译器，忽略了某些依赖于未定义行为的溢出检查时，CERT会对新版本的编译器发出警告。 Linux Weekly News 指出，同样的行为存在于 PathScale C, Microsoft Visual C++ 2005和其他一些编译器; 警告规则在后来已经被修订，用来警告各种编译器. References ISO/IEC (1999). ISO/IEC 9899:1999(E): Programming Languages - C §6.5 Expressions para. 2 ISO/IEC (2003). ISO/IEC 14882:2003(E): Programming Languages - C++ §2.13.4 String literals [lex.string] para. 2 ISO/IEC (2003). ISO/IEC 14882:2003(E): Programming Languages - C++ §5.6 Multiplicative operators [expr.mul] para. 4 ISO/IEC (2007). ISO/IEC 9899:2007(E): Programming Languages - C §6.9 External definitions para. 1 ISO/IEC (2011) .ISO/IEC 9899:201x(E): Programming Languages - C § 5.1.2.2.1Program startup para. 1,2 ANSI X3.159-1989 Programming Language C, footnote 26 https://imzlp.me/posts/15272/ “Vulnerability Note VU#162289 — gcc silently discards some wraparound checks”. Vulnerability Notes Database. CERT. 4 April 2008. Archived from the original on 9 April 2014. “Order of evaluation - cppreference.com”. en.cppreference.com. Retrieved 2016-08-09. https://zh.wikipedia.org/wiki/%E6%9C%AA%E5%AE%9A%E4%B9%89%E8%A1%8C%E4%B8%BA https://en.wikipedia.org/wiki/Undefined_behavior#Examples_in_C_and_C++ Undefined behavior can result in time travel. 27 Jun 2014 [2015-03-09]. Lattner, Chris. What Every C Programmer Should Know About Undefined Behavior. LLVM Project Blog. LLVM.org. May 13, 2011 [May 24, 2011]. The Jargon File on “nasal demons”，未定义行为的一个可能后果。]]></content>
      <tags>
        <tag>Language Standard</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[初探 UIViewController 生命周期]]></title>
    <url>%2F2017%2F12%2F%E5%88%9D%E6%8E%A2UIViewController-%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%2F</url>
    <content type="text"><![CDATA[对象的生命周期一直是开发者所需要关心的，教授 CS193p 的老师 Paul 也详细的讲述了 UIViewController 的生命周期。 环境 日期 Swift Xcode 2017/12/25 4.0 9.2 探究ViewController 的生命周期，其实指的是它控制的视图（View）的生命周期。每当视图的状态发生变化时，视图控制器会自动调用一系列方法来响应变化。 通过这些方法，我们就可以跟踪到视图的整个生命周期。各个方法按执行顺序排列如下： InitializationStoryboard123OUTPUT:init(coder:)awakeFromNib() init(coder:) 当使用 Storyboard 时，控制器的构造器为 init(coder:) 该构造器为必需构造器，如果重写其他构造器，则必须重写该构造器。 该构造器为可失败构造器，即有可能构造失败，返回 nil。 该方法来源自 NSCoding 协议，而 UIViewController 遵从这一协议。 该方法被调用意味着控制器有可能（并非一定）在未来会显示。 在控制器生命周期中，该方法只会被调用一次。 awakeFromNib() 当使用 Storyboard 时，该方法会被调用。 当调用该方法时，将保证所有的 outlet 和 action 连接已经完成。 该方法内部必须调用父类该方法，虽然默认实现为空，但 UIKit 中许多类的该方法为非空。 由于控制器中对象的初始化顺序不能确定，所以构造器中不应该向其他对象发送消息，而应当在 awakeFromNib() 中安全地发送。 通常使用 awakeFromNib() 可以进行在设计时无法完成的必要额外设置。 Code12OUTPUT:init(nibName:bundle:) - NibName: nil, Bundle: nil init(nibName:bundle:) 当使用纯代码创建控制器，控制器的构造器为 init(nibName:bundle:) 虽然使用代码创建时调用了该构造器，但传入的参数均为 nil。 loadView() loadView() 即加载控制器管理的 view（视图初始化） 不应该直接调用该方法，而是由系统自动调用。当 view 被请求却为 nil 时，该方法加载并创建 view。 若控制器有关联的 Nib 文件，该方法会从 Nib 文件中加载 view；如果没有，则创建空白 UIView 对象。 如果使用 Interface Builder 创建 view，则务必不要重写该方法。 可以使用该方法手动创建视图，且需要将根视图分配为 view；重写 loadView 方法不应该再调用父类的该方法。 执行其他初始化操作，建议放在 viewDidLoad() 中。 viewDidLoad() view 被加载到内存后调用 viewDidLoad() 重写该方法需要首先调用父类该方法。 该方法中可以额外初始化控件，例如移除一些视图，添加子控件，添加约束，修改数据等。 该方法被调用意味着控制器有可能（并非一定）在未来会显示。 在控制器生命周期中，该方法只会被调用一次。 viewWillAppear(_:) 该方法在控制器 view 即将添加到视图层次时以及展示 view 时所有动画配置前被调用。 重写该方法需要首先调用父类该方法。 该方法中可以进行操作即将显示的 view，例如改变当前屏幕方向或状态栏的风格。 该方法被调用意味着控制器将一定会显示。 在控制器生命周期中，该方法可能会被多次调用。 注意⚠️： 如果控制器 A 被展示在另一个控制器 B 的 popover 中，那么控制器 B 不会调用该方法，直到控制器 A 清除。 viewWillLayoutSubviews() 该方法在通知控制器将要布局 view 的子控件时调用。 每当视图的 bounds 改变，view 将调整其子控件位置。 该方法可重写以在 view 布局子控件前做出改变。 该方法的默认实现为空。 该方法调用时，AutoLayout 未起作用。 在控制器生命周期中，该方法可能会被多次调用。 viewDidLayoutSubviews() 该方法在通知控制器已经布局 view 的子控件时调用。 该方法可重写以在 view 布局子控件后做出改变。 该方法的默认实现为空。 该方法调用时，AutoLayout 已经完成。 在控制器生命周期中，该方法可能会被多次调用。 viewDidAppear(_:) 该方法在控制器 view 已经添加到视图层次时被调用。 重写该方法需要首先调用父类该方法。 我们可以在这个方法中，对视图做一些关于展示效果方面的修改。 在控制器生命周期中，该方法可能会被多次调用。 viewWillDisappear(_:) 该方法在控制器 view 将要消失、被覆盖或是隐藏时调用。 类似 viewWillAppear(_:) 该方法可重写以提交变更，取消视图第一响应者状态。 viewDidDisappear(_:) 该方法在控制器 view 已经消失、被覆盖或是隐藏时调用。 类似 viewDidAppear(_:) 该方法可重写以清除或隐藏控件。 viewVillUnload&amp;&amp;viewDidUnload 自 iOS6 起，viewWillUnload 和 viewDidUnload 这两个方法被废除了。当系统发出内存警告的时候，会自动把 view 给清除掉，不用我们再特别处理。 同时系统还会调用 didReceiveMemoryWarning 方法通知视图控制器，我们可以在这里面进行一些操作，来释放一些额外的资源。（通常来说不用操作，比较最占资源的 view 已经被系统给清理了。） didReceiveMemoryWarning() 当内存预警时，该方法被调用。 不能直接手动调用该方法。 该方法可重写以释放资源、内存。 deinit 控制器销毁时（离开堆），调用该方法。 视图状态的转换在实际应用中，视图通常不会按照上面列的流程一次执行下来，可能会在可见与不可见的状态间互相转换。比如一开始视图是可见的，接着我们跳转到另一个 ViewController，这时原来视图就变成不可见的。后面我们又跳转回来，那么这个视图就又是可见的。 当视图的可见性发生变化时，视图控制器对应的方法也会随之响应。具体可见下图： Appearing 和 Disappearing 这两个状态是可以互相转化的 测试样例1.ViewController 是首页视图控制器，我们将里面所有的与生命周期有关的函数都打印出来。 2.同时 ViewController 中添加了一个“跳转”按钮，点击后跳转到另一个视图控制器AnotherViewController。3.AnotherViewController 里有个“返回”按钮，点击又会回到前一个页面。 测试代码ViewController.swift 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455import UIKit class ViewController: UIViewController &#123; //视图初始化 override func loadView() &#123; super.loadView() print("loadView") &#125; //视图加载完成 override func viewDidLoad() &#123; super.viewDidLoad() print("viewDidLoad") //创建跳转按钮 let button:UIButton = UIButton(type: .System) button.frame=CGRectMake(10, 50, 100, 30) button.setTitle("跳转", forState: .Normal) button.addTarget(self,action:#selector(jump),forControlEvents:.TouchUpInside) self.view.addSubview(button); &#125; //视图将要出现的时候执行 override func viewWillAppear(animated: Bool) &#123; print("viewWillAppear") &#125; //视图显示完成后执行 override func viewDidAppear(animated: Bool) &#123; print("viewDidAppear") &#125; //视图将要消失的时候执行 override func viewWillDisappear(animated: Bool) &#123; print("viewWillDisappear") &#125; //视图已经消失的时候执行 override func viewDidDisappear(animated: Bool) &#123; print("viewDidDisappear") &#125; //收到内存警告时执行 override func didReceiveMemoryWarning() &#123; super.didReceiveMemoryWarning() &#125; //跳转到另一个视图 func jump()&#123; print("点击按钮，开始跳转！") let anotherVC = AnotherViewController() presentViewController(anotherVC, animated: true, completion: nil) &#125;&#125; AnotherViewController.swift 12345678910111213141516171819202122232425import UIKit class AnotherViewController: UIViewController &#123; override func viewDidLoad() &#123; super.viewDidLoad() //创建返回按钮 let button:UIButton = UIButton(type: .System) button.frame=CGRectMake(10, 150, 100, 30) button.setTitle("返回", forState: .Normal) button.addTarget(self,action:#selector(back),forControlEvents:.TouchUpInside) self.view.addSubview(button); &#125; //返回之前视图 func back()&#123; print("点击按钮，开始返回！") self.dismissViewControllerAnimated(true, completion: nil) &#125; override func didReceiveMemoryWarning() &#123; super.didReceiveMemoryWarning() &#125;&#125; 运行测试从 ViewController 跳到 AnotherViewController，再从 AnotherViewController 跳回 ViewController。整个控制台打印出来的流程如下： 12345678910loadViewviewDidLoadviewWillAppearviewDidAppear点击按钮，开始跳转！viewWillDisappearviewDidDisappear点击按钮，开始返回！viewWillAppearviewDidAppear NoteRotation OUTPUT: willTransition(to:with:) viewWillLayoutSubviews() - Optional((67.5, 269.5, 240.0, 128.0)) viewDidLayoutSubviews() - Optional((213.5, 123.5, 240.0, 128.0)) viewWillLayoutSubviews() - Optional((213.5, 123.5, 240.0, 128.0)) viewDidLayoutSubviews() - Optional((213.5, 123.5, 240.0, 128.0)) viewWillLayoutSubviews() - Optional((213.5, 123.5, 240.0, 128.0)) viewDidLayoutSubviews() - Optional((213.5, 123.5, 240.0, 128.0)) 当 view 转变，会调用 willTransition(to:with:) 方法。 当屏幕旋转，view 的 bounds 改变，其内部的子控件也需要按照约束调整为新的位置，因此也调用了 viewWillLayoutSubviews() 和 viewDidLayoutSubviews() Present &amp; Dismiss OUTPUT: viewWillDisappear viewDidDisappear viewDidDisappear viewWillAppear viewDidAppear 当在一个控制器内 Present 新的控制器，原先的控制器并不会销毁，但会消失，因此调用了 viewWillDisappear 和 viewDidDisappear 方法。 如果新的控制器 Dismiss，即清除自己，原先的控制器会再一次出现，因此调用了其中的 viewWillAppear 和 viewDidAppear 方法。 Endless loop123456789class LoopViewController: UIViewController &#123; override func loadView() &#123; print(#function) &#125; override func viewDidLoad() &#123; print(#function) let _ = view &#125;&#125; OUTPUT: loadView() viewDidLoad() loadView() viewDidLoad() loadView() viewDidLoad() loadView() viewDidLoad() loadView() 若 loadView() 没有加载 view，viewDidLoad() 会一直调用 loadView() 加载 view，因此构成了死循环，程序即卡死。 Reference CS193P_2017 UIViewController 相关生命周期总结 UIViewController生命周期详解]]></content>
      <tags>
        <tag>Swift</tag>
        <tag>UIkit</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[音乐外链播放器推荐]]></title>
    <url>%2F2017%2F12%2F%E4%BC%98%E7%A7%80%E9%9F%B3%E4%B9%90%E5%A4%96%E9%93%BE%E6%92%AD%E6%94%BE%E5%99%A8%E6%8E%A8%E8%8D%90%2F</url>
    <content type="text"><![CDATA[之前寻找音乐外链，最开始选择的是网易云。但是，网易云功能也太少了，实在忍不了。 前言根据互联网定律之一，既然存在比国内优秀的服务，那么应该也被封得差不多了。（逃 正文话不多说，开始了！ 不对，先婊一下网易云的外链。 这个看起来还好，歌单视图看着像是多少年前的东西了，丑的要死。 Spotify 外链获取作为Spotify的老用户，第一个自然是要推荐它的。（五毛一条） 不过由于版权原因，非付费用户只能听30秒就要切换到下一首歌 首先打开网页播放窗口，神清气爽的界面映入我们眼帘： 搜索喜欢的歌，或者专辑，然后：Copy Playlist link 接下来去往开发者中心，粘贴之前复制的播放列表： 去下方自定义样式然后复制下面的iframe标签，放入html5即可，此方法通用，下文不会再涉及。 效果展示 Soundcloud 外链获取 Soundcloud是一家来自德国的音乐服务商，首先去Soundcloud，搜索喜欢的歌或者专辑，然后点击share 选择Embed，自己自定义喜欢的样式，然后复制code。 效果展示 mixcloud 外链获取 这是来自英国的服务商，服务也很不错，不过是用户自己创作的音乐较多。 网址在这里，同样是搜索歌曲，然后选择share，然后选择具体样式 效果展示 soundsgood 外链获取这是我最推荐的一个，不仅可以切换来源，还可以播放视频。如果你可以绕过GFW,你就会发现这是世界上最好的选择 首先还是打开Soundsgood，自己折腾注册和账号绑定。 自己创建歌单，自定义封面，然后点击EMBED获取外链 效果展示 应该有墙 结尾估计要被喜欢网易云音乐的人们萌豚打死了（逃]]></content>
      <tags>
        <tag>Music</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS降级通用教程]]></title>
    <url>%2F2017%2F12%2FiOS%E9%99%8D%E7%BA%A7%E9%80%9A%E7%94%A8%E6%95%99%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[此文只设计如何降级到可联网验证的版本，适合纯小白。想要降级到iOS10，9，8请自行SHSH 前言：此文之说明如何降级何关闭更新提示，越狱后请自行探索(ง๑ •̀_•́)ง 准备工作 一部未越狱iPhone的且系统版本高于iOS11.1.2 一台安装了iTunes且可联网的电脑（最好是你自己的） 一根可连接电脑和iTunes的数据线 一双没有瞎的眼睛 如果没有，还请准备完毕后开始教程(´_ゝ`) 开始降级查询可降级验证版本在查询iOS固件状态后 发现iOS目前可支持验证更新的最低版本是iOS11.0.1，由于每年苹果都会陆续关闭验证通道，所以推荐尽快完成降级。 备份手机资料 安全起见，手机有价，数据无价。我们首先应该进行备份。首先连接手机到电脑，打开iTunes，点击资料库左边的手机样式，在左边设置里面选择摘要—备份，然后点击立即备份到电脑。 这个时候只需等待即可，通常来讲，文件越多，备份所需时间也会越长。具体备份文件地址请访问Apple支持 下载固件 我推荐iOS11.1版本，即将在圣诞节发布的越狱工具首先就是iOS11.1测试成功，为了稳定我推荐iOS11.1版本 首先确认自己的手机版本号，在手机背后下面即可看到产品型号。 一定要确定自己的型号！！ iPhone版本 手机型号&amp;&amp;下载固件 iPhone 8 Plus A1864 iPhone 8 A1863 iPhone 7 Plus A1784， A1661,A1786 iPhone 7 A1778，A1660,A1780 iPhone SE A1723,A1724 iPhone 6s Plus A1699,A1634,A1687 iPhone 6s A1700,A1688,A1633 iPhone 6 Plus A1524,A1522,A1593 iPhone 6 A1586,A1549,A1589 iPhone 5S A1533,A1453， A1518,A1528,A1530,A1457 关闭查找我的设备 前往“设置”&gt;“[您的名字]”&gt;“iCloud”（或“设置”&gt;“iCloud”），然后关闭“查找我的 [iPhone]”。 输入iCloud账号密码，点击关闭 开始刷机降级设备连接iTunes，进入设备详情页面之后查看 如果和我一样是最新版系统，只能通过按住键盘Shift键（Mac电脑按住Control ⌃键）点击【恢复iPhone】，然后选中之前下好的固件（ipsw格式），你的手机将会重置，所以务必前往“设置”&gt;“[您的名字]”&gt;“iCloud”（或“设置”&gt;“iCloud”）查看是否开启了iCloud备份个人数据。 如果你未更新最新版本，检查更新按钮应该是更新，那么按住键盘Shift键（Mac电脑按住Control ⌃键）点击更新将会保留原本的数据，同样选择之前下载的固件进行更新（实际是降级） 静静等待奇迹发生吧，如果失败，你还有备份，还原就好。 关闭手机自动更新降级成功的第一件事就是先关闭手机的系统更新 打开safari，地址栏输入: 1https://oldcat.me/web/NOOTA9.mobileconfig 然后回车按照要求安装此描述文件即可，然后重启，点击检查更新你就会发现目前你的系统是最新版本。]]></content>
      <tags>
        <tag>iOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[I Wish you a Merry Christmas]]></title>
    <url>%2F2017%2F12%2FI-wish-you-a-Merry-Christmas%2F</url>
    <content type="text"><![CDATA[圣诞节快乐米娜桑ε٩(๑&gt; ₃ &lt;)۶з～ 又是一年圣诞季，祝大家都能开开心心的～ 有男女朋友的除外 冬が来る——嬉しくて切ない、永遠の一瞬が 年末总结今年年初过得还不错吧，经历过高考复习的紧张和压抑，枯燥但充实。反省一下高考前还一直通宵打游戏 也感受到了毕业后的放松和对大学的期待。感谢高中三年的同学友谊，无论是17班还是11班，都是我的一份记忆。前者给了我深刻的记忆，后者则给了我永久的回忆。特别感谢你，陪我度过的那些日子，尽管结局不太美好但我希望你在未来会过上你喜欢的生活。 高考成绩不好评判，总之在意料之中吧。进了大学认识了很多小伙伴，也加入了计协这个大家庭，同时也感受到了来自优秀学长们的压力。有压力才有动力，虽然一直在熬夜通宵，学到了很多东西，我也在尽力朝我喜欢的方向发展，但是高数挂了。 一切还算满意，只不过感情很不顺利，希望尽早能找到能一个陪我的人。自己确实感觉到有些孤单 喜欢我的赶紧表白啊，我永远喜欢成熟的小姐姐（发文章的时候记得删掉这一条 希望我在乎的人能开开心心的。我讨厌的人的妈年末买菜必定超级涨价。 圣诞礼物圣诞礼物就是给大家推荐一个网址人工智能图片放大，以后大家碰见喜欢的图，但是又找不到高清图，就可以用这个试试哟～ 然后再送大家几张冬季壁纸（会陆续更新 作品名/Title: ﾒﾘｸﾘ🍥🎀插画作者/Artist: ダンミルC93 🍤3日目東シ71b‏ 原始尺寸/Pic Size: 700 × 904px 放大后尺寸/After Enlarge Size: 8x倍放大 5600 × 7232px 来源链接Illustration ID: 8x倍放大 5600 × 7232 像素高清版（17.3 MB） 下载8x 4x倍放大 2800 × 3616 像素高清版（6 MB） 下载4x 作品名/Title: サンタ榛名描きました插画作者/Artist: 京極燈弥＠金曜東ヤ02ｂ 原始尺寸/Pic Size: 724 × 1023px 放大后尺寸/After Enlarge Size: 2x倍放大 1448 × 2046px 4x放大 2896 × 4092px 2x倍放大 1448 × 2046 像素高清版（0.45 MB） 下载2x 4x倍放大 2896 × 4092 像素高清版（1.2 MB） 下载4x 作品名/Title: 動く、動く插画作者/Artist: ガゥ 🐺2日目H-11a 原始尺寸/Pic Size: 1073×985px 放大后尺寸/After Enlarge Size: 8x倍放大 8584 × 7880px 来源链接/Illustration ID: 描述/Description：少女終末旅行のチト×ユーリ可愛いぃ!! 冬コミ新刊にちょこっと載ります… 8x倍放大 8584 × 7880 像素高清版（3 MB） 下载8x 4x倍放大 4292 × 3940 像素高清版（1.1 MB） 下载4x 作品名/Title: Alter插画作者/Artist: TID原始尺寸/Pic Size: 1000×1520px 放大后尺寸/After Enlarge Size: 4x倍放大 4000 × 6080px 来源链接/Illustration ID: 4x倍放大 4000 × 6080 像素高清版（14.2 MB） 下载4x 2x倍放大 2000 × 3040 像素高清版（4.9 MB） 下载2x 更新结束～算了找不到女朋友就找不到吧]]></content>
      <tags>
        <tag>Daily</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[如何给自有域名添加上https服务]]></title>
    <url>%2F2017%2F12%2F%E5%A6%82%E4%BD%95%E7%BB%99%E8%87%AA%E6%9C%89%E5%9F%9F%E5%90%8D%E6%B7%BB%E5%8A%A0%E4%B8%8Ahttps%E6%9C%8D%E5%8A%A1%2F</url>
    <content type="text"><![CDATA[从Chrome56左右开始，对于没有HTTPS的网站，都不会出现一把小绿锁。反之，有了小绿锁的网站，标志着这个网站是HTTPS安全的。 简介什么是https超文本传输安全协议（英语：Hypertext Transfer Protocol Secure，缩写：HTTPS，常称为HTTP over TLS，HTTP over SSL或HTTP Secure）是一种通过计算机网络进行安全通信的传输协议。HTTPS经由HTTP进行通信，但利用SSL/TLS来加密数据包。HTTPS开发的主要目的，是提供对网站服务器的身份认证，保护交换数据的隐私与完整性。这个协议由网景公司（Netscape）在1994年首次提出，随后扩展到互联网上。 历史上，HTTPS连接经常用于万维网上的交易支付和企业信息系统中敏感信息的传输。在2000年代晚期和2010年代早期，HTTPS开始广泛使用于保护所有类型网站上的网页真实性，保护账户和保持用户通信，身份和网络浏览的私密性。 与HTTP的差异 与HTTP的URL由“http://”起始且默认使用端口80不同，HTTPS的URL由“https://”起始且默认使用端口443。 HTTP是不安全的，且攻击者通过监听和中间人攻击等手段，可以获取网站帐户和敏感信息等。HTTPS被设计为可防止前述攻击，并在正确配置时被认为是安全的。 更多资料 步骤注册Cloudflare Cloudflare是国外非常有名的一家网络服务提供商。它提供的其中一项免费服务就是给我们自有域名加上HTTPS。正好符合我们的需求。 注册成功后添加自己的域名。会有三角形的⚠️标示，这代表Cloudflare没有检测到你域名NS的正确指向，不着急，我们解决。 更改DNS服务器地址 然后需要将我们的域名的DNS服务商的地址改成Cloudflare要求的两个DNS服务器地址。每个人分配的不一样，而且必须用分配的否则会失效。 如果域名提供商那里只有添加解析没有更改DNS服务器的选项。例：8a 清空解析，记住你的域名管理密码，然后去代理注册的域名商更改。例：新网 找到dns服务更改并保存，现在一般都是几分钟就生效了，最长也不过48小时 开启HTTPS 找到Crypto选项，这里我们需要开启Flexible的HTTPS选项。 其实Cloudflare做的事就是，当访问我们的域名的时候，实际上走的是Cloudflare的服务器，这个时候这个阶段的访问是有HTTPS的。然后Cloudflare再去请求我们实际的内容，再将内容返回给用户。这一段是没有HTTPS的。也就是实际上是半HTTPS。不过对于我们静态博客来说，这种半HTTPS实际上已经够我们使用了。 重定向 这个时候我们访问https://xxxxx.xxx自然走的是HTTPS。但是如果有人访问了http://xxxxx.xxx，那要如何跳转到HTTPS的页面呢？CloudFare另一个很棒的功能Page Rules就派上用场了。我们可以指定我们的域名强制使用HTTPS，并且当访问是HTTP的时候重定向到HTTPS。这样就能保证访问我们的页面都是通过HTTPS的了。 加入HSTS的列表我们访问自己的网站是走HTTP-&gt;304重定向-&gt;HTTPS。这个是浏览器跟服务器进行了一次通信之后才发生的跳转。我们也可以通过HSTS的Preload List使其访问的是HTTP，但是浏览器识别之后自动转成HTTPS访问，而不经过重定向那一层操作。 可以参考这篇文章对HSTS进行更深入的了解。简单来说，HSTS能够使我们的网站安全性更上一层楼。 还是CloudFare，自有的HSTS功能，开启之后就能很好的满足我们的需要。还是在Crypto选项下，开启HSTS 检查去HSTS Preload List的网站把我们的域名进行检查并收录（不能是子域名，必须是一级域名），如果没通过会给出修改建议，按照建议修改就行。如果通过了，就会放入审核列表。之后可以时不时回来看看自己的网站被收录了没有。我是等了快一周才被收录。网上的说法普遍是几天内（不过我几分钟就审核过了（逃。所以耐心等待收录。一旦被收录就会应用到主流浏览器上，这样你的网站就是更加安全的网站了。 总结因为是Cloudflare的cdn加速，所以在国外访问速度很快，在国内访问的速度会稍慢一些。 话说国内啥时候能有这样的服务啊，万恶的资本主义]]></content>
      <tags>
        <tag>Domain Name</tag>
        <tag>https</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[利用live 2d给博客添加看版娘]]></title>
    <url>%2F2017%2F12%2F%E5%88%A9%E7%94%A8live-2d%E7%BB%99%E5%8D%9A%E5%AE%A2%E6%B7%BB%E5%8A%A0%E7%9C%8B%E7%89%88%E5%A8%98%2F</url>
    <content type="text"><![CDATA[给你的网站加上女朋友 前言现实生活的你是不是没有女朋友呢？没关系，你可以给你自己网页上弄一个 live2d常常被我们用于做手机的动态壁纸增加萌点！live2dviewerex当然你也可以把她放到你的博客上！这样也很卡哇伊不是吗(/ω＼)live2d目前技术还不是很成熟 但是很适合用来做网站的看板娘 转载自@猫与向日葵和@JiuMeng，本人进行一定整合 获取模型&amp;调整：科普：Live2D是一种应用于电子游戏的绘图渲染技术，技术由日本Cybernoids公司开发。通过一系列的连续图像和人物建模来生成一种类似三维模型的二维图像，对于以动画风格为主的冒险游戏来说非常有用，缺点是Live 2D人物无法大幅度转身，开发商正设法让该技术可显示360度图像。首先既然是做live2d的看板娘怎么能少了最基础的模型呢！这里是本project的大概流程图： Live2d的模型（你喜欢的）[这里包含了声音调用以及其他的0.0]→官方或者修改的SDK（合成）→上传至网站相应目录→在相应位置插入 js css div以及其他附属→调整css→完工了！ 关于模型如何获取这里不详细讲解 以下为获取途径：1.百度贴吧 （live2d吧 live2dviewerex吧 ）这里面有很多模型 自己去看看吧！看看能不能找到你们的老婆2.在游戏里提取（注意版权问题）这些游戏都是由live2d引擎驱动的像在这些游戏里都能提取出模型 置于方法嘛（自己百度吧）说出来我怕菊花被人捅烂《樱花庄的宠物女孩》【2013/02/14】(角川游戏)PSP/PSV《某魔术和科学的群奏活剧》【2013/02/21】(NBGI)PSP《药水制作师》【2015/3/23】(Sinsiroad) 安卓/ios这里有篇讲如何提取《药水制作师》模型的文章：相关链接获取模型的格式 最好是moc的可编辑工程文件 当然lpk也行 但是lpk能不能用就看你的运气了这里讲讲如何打开模型查看模型需要使用LIVE2D官方提供的Live2D Viewer，下载和安装方法请查看 这个网页然后如果你下载（或者提取的）的是编工程文件的live2d的话 （json已经写好的）你可以吧json拖到live2d-viewer里面就可以预览模型了如果是lpk格式的文件的话 这里讲解一种（菊花被人捅烂的方法解lpk） 先下载好lpk然后用zip压缩工具查看打开这个lpk 然后解压里面的文件出来就可以得到moc 那样的模型了如果你下载的lpk是被加密过的那么这个方法就不能使用了（乖乖换老婆或者想其他办法吧） 提取 没有被加密的lpk解压出来是这样的： 红色部分为lpk配置文件这个不影响我们制作模型可以不管它 打开主题部分： 把这个拖进我们的Live2D Viewer你就会看到： 模型成功加载了！ 同样我们可以把别的模型也拖进去拖进live2d-viewer里 就可以预览模型了打开Live2D Viewer，将json或者moc （网页只调用json）拖入主窗口，可以看到模型已经加载成功，若有贴图错位、动作鬼畜等情况则为上一步的json文件配置有误，测试直到找到正确的模型、动作、贴图组合 有些模型是自带动作以及语音的这样可以测试动作： 选择要测试的动作，点击Playback播放动作以测试动作是否正常，勾选Loop可以循环播放模型测试好了之后就进入下一步吧！ 模型大概就到这里了 下面是主体部分： 准备SDK为了效率最大化，不用把有限的时间投入到与bug无限的斗争和踩坑中；为了不重复造轮子；为了爱与和平 就是因为懒，我们不使用官方的SDK，而是用@EYHN大佬封装好的库来加载并显示模型。相比较官方版本而言，仅需一条命令即可进行模型的加载，无疑方便许多。 但对于「药水制作师」这款游戏的模型来说，上面所说的库还需经过一些修改。 修改原因基于commit #fea64e4修改，修改内容：修复移动鼠标会触发点击事件的问题增加鼠标点击事件移除自带的眨眼动作增加久置动作与事件支持增加自定义HIT_AREA的方法由于原项目使用了GPL v2开源协议，修改后的代码已开源至GitHub，若想修改请参考项目hexo-helper-live2d 鉴于该项目仍在活跃开发中，@猫与向日葵修改的版本可能会随时间变化而过时 编译后的版本可以在这里下载： Download Now 以下部分内容为转载内容：提示功能（可选）这部分直接抄自之前的浮动小人，做了部分修改，非必须项，须jQuery支持若不启用此部分内容，下一步应作相应修改此处代码不可直接套用，应根据自身情况进行修改这里是为小人添加消息提示框的 此部分可以不做 当然你喜欢的话我也是不介意的少女盲目分析中 代码脚本将以下内容保存为waifu-tips.js，放至相应目录 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127function render(template, context) &#123; var tokenReg = /(\\)?\&#123;([^\&#123;\&#125;\\]+)(\\)?\&#125;/g; return template.replace(tokenReg, function (word, slash1, token, slash2) &#123; if (slash1 || slash2) &#123; return word.replace('\\', ''); &#125; var variables = token.replace(/\s/g, '').split('.'); var currentObject = context; var i, length, variable; for (i = 0, length = variables.length; i &amp;amp;amp;lt; length; ++i) &#123; variable = variables[i]; currentObject = currentObject[variable]; if (currentObject === undefined || currentObject === null) return ''; &#125; return currentObject; &#125;);&#125;String.prototype.render = function (context) &#123; return render(this, context);&#125;; var re = /x/;console.log(re);re.toString = function() &#123; showMessage('哈哈，你打开了控制台，是想要看看我的秘密吗？', 5000); return '';&#125;; $(document).on('copy', function ()&#123; showMessage('你都复制了些什么呀，转载要记得加上出处哦', 5000);&#125;); $.ajax(&#123; cache: true, url: "path/to/waifu-tips.json", dataType: "json", success: function (result)&#123; $.each(result.mouseover, function (index, tips)&#123; $(tips.selector).mouseover(function ()&#123; var text = tips.text; if(Array.isArray(tips.text)) text = tips.text[Math.floor(Math.random() * tips.text.length + 1)-1]; text = text.render(&#123;text: $(this).text()&#125;); showMessage(text, 3000); &#125;); &#125;); $.each(result.click, function (index, tips)&#123; $(tips.selector).click(function ()&#123; var text = tips.text; if(Array.isArray(tips.text)) text = tips.text[Math.floor(Math.random() * tips.text.length + 1)-1]; text = text.render(&#123;text: $(this).text()&#125;); showMessage(text, 3000); &#125;); &#125;); &#125;&#125;); (function ()&#123; var text; if(document.referrer !== '')&#123; var referrer = document.createElement('a'); referrer.href = document.referrer; text = 'Hello! 来自 &amp;amp;amp;lt;span style="color:#0099cc;"&amp;amp;amp;gt;' + referrer.hostname + '&amp;amp;amp;lt;/span&amp;amp;amp;gt; 的朋友'; var domain = referrer.hostname.split('.')[1]; if (domain == 'baidu') &#123; text = 'Hello! 来自 百度搜索 的朋友你是搜索 &amp;amp;amp;lt;span style="color:#0099cc;"&amp;amp;amp;gt;' + referrer.search.split('&amp;amp;amp;amp;wd=')[1].split('&amp;amp;amp;amp;')[0] + '&amp;amp;amp;lt;/span&amp;amp;amp;gt; 找到的我吗？'; &#125;else if (domain == 'so') &#123; text = 'Hello! 来自 360搜索 的朋友你是搜索 &amp;amp;amp;lt;span style="color:#0099cc;"&amp;amp;amp;gt;' + referrer.search.split('&amp;amp;amp;amp;q=')[1].split('&amp;amp;amp;amp;')[0] + '&amp;amp;amp;lt;/span&amp;amp;amp;gt; 找到的我吗？'; &#125;else if (domain == 'google') &#123; text = 'Hello! 来自 谷歌搜索 的朋友欢迎阅读&amp;amp;amp;lt;span style="color:#0099cc;"&amp;amp;amp;gt;『' + document.title.split(' - ')[0] + '』&amp;amp;amp;lt;/span&amp;amp;amp;gt;'; &#125; &#125;else &#123; if (window.location.href == 'https://imjad.cn/') &#123; //如果是主页 var now = (new Date()).getHours(); if (now &amp;amp;amp;gt; 23 || now &amp;amp;amp;lt;= 5) &#123; text = '你是夜猫子呀？这么晚还不睡觉，明天起的来嘛'; &#125; else if (now &amp;amp;amp;gt; 5 &amp;amp;amp;amp;&amp;amp;amp;amp; now &amp;amp;amp;lt;= 7) &#123; text = '早上好！一日之计在于晨，美好的一天就要开始了'; &#125; else if (now &amp;amp;amp;gt; 7 &amp;amp;amp;amp;&amp;amp;amp;amp; now &amp;amp;amp;lt;= 11) &#123; text = '上午好！工作顺利嘛，不要久坐，多起来走动走动哦！'; &#125; else if (now &amp;amp;amp;gt; 11 &amp;amp;amp;amp;&amp;amp;amp;amp; now &amp;amp;amp;lt;= 14) &#123; text = '中午了，工作了一个上午，现在是午餐时间！'; &#125; else if (now &amp;amp;amp;gt; 14 &amp;amp;amp;amp;&amp;amp;amp;amp; now &amp;amp;amp;lt;= 17) &#123; text = '午后很容易犯困呢，今天的运动目标完成了吗？'; &#125; else if (now &amp;amp;amp;gt; 17 &amp;amp;amp;amp;&amp;amp;amp;amp; now &amp;amp;amp;lt;= 19) &#123; text = '傍晚了！窗外夕阳的景色很美丽呢，最美不过夕阳红~'; &#125; else if (now &amp;amp;amp;gt; 19 &amp;amp;amp;amp;&amp;amp;amp;amp; now &amp;amp;amp;lt;= 21) &#123; text = '晚上好，今天过得怎么样？'; &#125; else if (now &amp;amp;amp;gt; 21 &amp;amp;amp;amp;&amp;amp;amp;amp; now &amp;amp;amp;lt;= 23) &#123; text = '已经这么晚了呀，早点休息吧，晚安~'; &#125; else &#123; text = '嗨~ 快来逗我玩吧！'; &#125; &#125;else &#123; text = '欢迎阅读&amp;amp;amp;lt;span style="color:#0099cc;"&amp;amp;amp;gt;『' + document.title.split(' - ')[0] + '』&amp;amp;amp;lt;/span&amp;amp;amp;gt;'; &#125; &#125; showMessage(text, 6000);&#125;)(); window.setInterval(showHitokoto,30000); function showHitokoto()&#123; $.getJSON('https://api.imjad.cn/hitokoto/?cat=&amp;amp;amp;amp;charset=utf-8&amp;amp;amp;amp;length=28&amp;amp;amp;amp;encode=json',function(result)&#123; showMessage(result.hitokoto, 5000); &#125;);&#125; function showMessage(text, timeout)&#123; if(Array.isArray(text)) text = text[Math.floor(Math.random() * text.length + 1)-1]; console.log(text); $('.waifu-tips').stop(); $('.waifu-tips').html(text).fadeTo(200, 1); if (timeout === null) timeout = 5000; hideMessage(timeout);&#125;function hideMessage(timeout)&#123; $('.waifu-tips').stop().css('opacity',1); if (timeout === null) timeout = 5000; $('.waifu-tips').delay(timeout).fadeTo(200, 0);&#125; 文本将以下内容保存为waifu-tips.json，放至相应目录 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110&#123; "mouseover": [ &#123; "selector": ".container a[href^='http']", "text": ["要看看 &amp;amp;amp;lt;span style=\"color:#0099cc;\"&amp;amp;amp;gt;&#123;text&#125;&amp;amp;amp;lt;/span&amp;amp;amp;gt; 么？"] &#125;, &#123; "selector": ".fui-home", "text": ["点击前往首页，想回到上一页可以使用浏览器的后退功能哦"] &#125;, &#123; "selector": "#tor_show", "text": ["翻页比较麻烦吗，点击可以显示这篇文章的目录呢"] &#125;, &#123; "selector": "#comment_go,.fui-chat", "text": ["想要去评论些什么吗？"] &#125;, &#123; "selector": "#night_mode", "text": ["深夜时要爱护眼睛呀"] &#125;, &#123; "selector": "#qrcode", "text": ["手机扫一下就能继续看，很方便呢"] &#125;, &#123; "selector": ".comment_reply", "text": ["要吐槽些什么呢"] &#125;, &#123; "selector": "#back-to-top", "text": ["回到开始的地方吧"] &#125;, &#123; "selector": "#author", "text": ["该怎么称呼你呢"] &#125;, &#123; "selector": "#mail", "text": ["留下你的邮箱，不然就是无头像人士了"] &#125;, &#123; "selector": "#url", "text": ["你的家在哪里呢，好让我去参观参观"] &#125;, &#123; "selector": "#textarea", "text": ["认真填写哦，垃圾评论是禁止事项"] &#125;, &#123; "selector": ".OwO-logo", "text": ["要插入一个表情吗"] &#125;, &#123; "selector": "#csubmit", "text": ["要提交了吗，首次评论需要审核，请耐心等待~"] &#125;, &#123; "selector": ".ImageBox", "text": ["点击图片可以放大呢"] &#125;, &#123; "selector": "input[name=s]", "text": ["找不到想看的内容？搜索看看吧"] &#125;, &#123; "selector": ".previous", "text": ["去上一页看看吧"] &#125;, &#123; "selector": ".next", "text": ["去下一页看看吧"] &#125;, &#123; "selector": ".dropdown-toggle", "text": ["这里是菜单"] &#125;, &#123; "selector": "c-player a.play-icon", "text": ["想要听点音乐吗"] &#125;, &#123; "selector": "c-player div.time", "text": ["在这里可以调整&amp;amp;amp;lt;span style=\"color:#0099cc;\"&amp;amp;amp;gt;播放进度&amp;amp;amp;lt;/span&amp;amp;amp;gt;呢"] &#125;, &#123; "selector": "c-player div.volume", "text": ["在这里可以调整&amp;amp;amp;lt;span style=\"color:#0099cc;\"&amp;amp;amp;gt;音量&amp;amp;amp;lt;/span&amp;amp;amp;gt;呢"] &#125;, &#123; "selector": "c-player div.list-button", "text": ["&amp;amp;amp;lt;span style=\"color:#0099cc;\"&amp;amp;amp;gt;播放列表&amp;amp;amp;lt;/span&amp;amp;amp;gt;里都有什么呢"] &#125;, &#123; "selector": "c-player div.lyric-button", "text": ["有&amp;amp;amp;lt;span style=\"color:#0099cc;\"&amp;amp;amp;gt;歌词&amp;amp;amp;lt;/span&amp;amp;amp;gt;的话就能跟着一起唱呢"] &#125;, &#123; "selector": ".waifu #live2d", "text": ["干嘛呢你，快把手拿开", "鼠…鼠标放错地方了！"] &#125; ], "click": [ &#123; "selector": ".waifu #live2d", "text": ["是…是不小心碰到了吧", "萝莉控是什么呀", "你看到我的小熊了吗", "再摸的话我可要报警了！⌇●﹏●⌇", "110吗，这里有个变态一直在摸我(ó﹏ò｡)"] &#125; ]&#125; 引入JS修改header.php，加入以下内容以创建画布和提示框： 1234&amp;amp;lt;div class="waifu"&amp;amp;gt;&amp;amp;lt;div class="waifu-tips"&amp;amp;gt;&amp;amp;lt;/div&amp;amp;gt;&amp;amp;lt;canvas id="live2d" width="280" height="250" class="live2d"&amp;amp;gt;&amp;amp;lt;/canvas&amp;amp;gt;&amp;amp;lt;/div&amp;amp;gt; 在footer.php中加入以下内容： 123&amp;amp;lt;img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-wp-preserve="%3Cscript%20async%20src%3D%22path%2Fto%2Fwaifu-tips.js%22%3E%3C%2Fscript%3E" data-mce-resize="false" data-mce-placeholder="1" class="mce-object" width="20" height="20" alt="&amp;amp;amp;lt;script&amp;amp;amp;gt;" title="&amp;amp;amp;lt;script&amp;amp;amp;gt;" /&amp;amp;gt;&amp;amp;lt;img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-wp-preserve="%3Cscript%20src%3D%22path%2Fto%2Flive2d.js%22%3E%3C%2Fscript%3E" data-mce-resize="false" data-mce-placeholder="1" class="mce-object" width="20" height="20" alt="&amp;amp;amp;lt;script&amp;amp;amp;gt;" title="&amp;amp;amp;lt;script&amp;amp;amp;gt;" /&amp;amp;gt;&amp;amp;lt;img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-wp-preserve="%3Cscript%20type%3D%22text%2Fjavascript%22%3E%0A%20loadlive2d(%22live2d%22%2C%20%22path%2Fto%2Fmodel.json%22)%3B%0A%3C%2Fscript%3E" data-mce-resize="false" data-mce-placeholder="1" class="mce-object" width="20" height="20" alt="&amp;amp;amp;lt;script&amp;amp;amp;gt;" title="&amp;amp;amp;lt;script&amp;amp;amp;gt;" /&amp;amp;gt; model.json修改为以下内容其中hit_areas_custom字段的head_x和body_x定义了头部和身体的HIT_AREA的左上角的坐标，head_y和body_y定义了右下角的坐标 坐标可通过启用DEBUG_MOUSE_LOG获取 源码+声音 已下是可选择内容 修改你的人物.json 这里给的只是某个贴图的格式: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899&#123; "version":"1.0.0", "model":"model.moc", "textures":[ "textures/default-costume.png" ], "layout":&#123; "center_x":0.0, "center_y":-0.05, "width":2.0 &#125;, "hit_areas_custom":&#123; "head_x":[-0.35, 0.6], "head_y":[0.19, -0.2], "body_x":[-0.3, -0.25], "body_y":[0.3, -0.9] &#125;, "motions":&#123; "idle":[ &#123;"file":"motions/WakeUp.mtn"&#125;, &#123;"file":"motions/Breath1.mtn"&#125;, &#123;"file":"motions/Breath2.mtn"&#125;, &#123;"file":"motions/Breath3.mtn"&#125;, &#123;"file":"motions/Breath5.mtn"&#125;, &#123;"file":"motions/Breath7.mtn"&#125;, &#123;"file":"motions/Breath8.mtn"&#125; ], "sleepy":[ &#123;"file":"motions/Sleeping.mtn"&#125; ], "flick_head":[ &#123;"file":"motions/Touch Dere1.mtn"&#125;, &#123;"file":"motions/Touch Dere2.mtn"&#125;, &#123;"file":"motions/Touch Dere3.mtn"&#125;, &#123;"file":"motions/Touch Dere4.mtn"&#125;, &#123;"file":"motions/Touch Dere5.mtn"&#125;, &#123;"file":"motions/Touch Dere6.mtn"&#125; ], "tap_body":[ &#123;"file":"motions/Touch1.mtn"&#125;, &#123;"file":"motions/Touch2.mtn"&#125;, &#123;"file":"motions/Touch3.mtn"&#125;, &#123;"file":"motions/Touch4.mtn"&#125;, &#123;"file":"motions/Touch5.mtn"&#125;, &#123;"file":"motions/Touch6.mtn"&#125; ], "":[ &#123;"file":"motions/Breath1.mtn"&#125;, &#123;"file":"motions/Breath2.mtn"&#125;, &#123;"file":"motions/Breath3.mtn"&#125;, &#123;"file":"motions/Breath4.mtn"&#125;, &#123;"file":"motions/Breath5.mtn"&#125;, &#123;"file":"motions/Breath6.mtn"&#125;, &#123;"file":"motions/Breath7.mtn"&#125;, &#123;"file":"motions/Breath8.mtn"&#125;, &#123;"file":"motions/Fail.mtn"&#125;, &#123;"file":"motions/Sleeping.mtn"&#125;, &#123;"file":"motions/Success.mtn"&#125;, &#123;"file":"motions/Sukebei1.mtn"&#125;, &#123;"file":"motions/Sukebei2.mtn"&#125;, &#123;"file":"motions/Sukebei3.mtn"&#125;, &#123;"file":"motions/Touch Dere1.mtn"&#125;, &#123;"file":"motions/Touch Dere2.mtn"&#125;, &#123;"file":"motions/Touch Dere3.mtn"&#125;, &#123;"file":"motions/Touch Dere4.mtn"&#125;, &#123;"file":"motions/Touch Dere5.mtn"&#125;, &#123;"file":"motions/Touch Dere6.mtn"&#125;, &#123;"file":"motions/Touch1.mtn"&#125;, &#123;"file":"motions/Touch2.mtn"&#125;, &#123;"file":"motions/Touch3.mtn"&#125;, &#123;"file":"motions/Touch4.mtn"&#125;, &#123;"file":"motions/Touch5.mtn"&#125;, &#123;"file":"motions/Touch6.mtn"&#125;, &#123;"file":"motions/WakeUp.mtn"&#125; ], "tap_body": [ &#123; "file":"motions/Touch Dere3.mtn" , "sound":"sounds/1.mp3"&#125;, &#123; "file":"motions/Touch1.mtn" , "sound":"sounds/3.mp3"&#125;, &#123; "file":"motions/Touch2.mtn" , "sound":"sounds/4.mp3"&#125; ], "pinch_in": [ &#123; "file":"motions/Breath3.mtn", "sound":"sounds/9.mp3" &#125; ], "pinch_out": [ &#123; "file":"motions/Breath5.mtn", "sound":"sounds/8.mp3" &#125; ], "shake": [ &#123; "file":"motions/Breath7.mtn", "sound":"sounds/6.mp3","fade_in":500 &#125; ], "flick_head": [ &#123; "file":"motions/Breath8.mtn", "sound":"sounds/3.mp3" &#125; ] &#125;&#125; 上面的mtn动作以及sounds可以选择添加 这样可以在人物里面添加动作同步声音 增加看板娘萌度！ 其中motions的idle组是放置时的动作，按照次序依次显示，可以在这里添加更多的动作 layout的center_x字段和center_y字段用于偏移显示模型，日后若有显示错位可以修改此处的值 增加样式:把如下源码写成css再调用或者直接插入style.css里再调用都可以 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244.waifu &#123; position: fixed; bottom: 0; left: 0; z-index: 1; font-size: 0; transition: all .3s ease-in-out; -webkit-transform: translateY(3px); transform: translateY(3px);&#125;.waifu:hover &#123; -webkit-transform: translateY(0); transform: translateY(0);&#125;@media (max-width: 768px) &#123; .waifu &#123; display: none; &#125;&#125;.waifu-tips &#123; opacity: 0; width: 200px; height: 60px; margin: -20px 20px; padding: 4px 6px; border: 1px solid rgba(224, 186, 140, 0.62); border-radius: 12px; background-color: rgba(236, 217, 188, 0.5); box-shadow: 0 3px 15px 2px rgba(191, 158, 118, 0.2); font-size: 12px; text-overflow: ellipsis; overflow: hidden; position: absolute; animation-delay: 5s; animation-duration: 50s; animation-iteration-count: infinite; animation-name: shake; animation-timing-function: ease-in-out;&#125;.waifu #live2d&#123; position: relative;&#125; @keyframes shake &#123; 2% &#123; transform: translate(0.5px, -1.5px) rotate(-0.5deg); &#125; 4% &#123; transform: translate(0.5px, 1.5px) rotate(1.5deg); &#125; 6% &#123; transform: translate(1.5px, 1.5px) rotate(1.5deg); &#125; 8% &#123; transform: translate(2.5px, 1.5px) rotate(0.5deg); &#125; 10% &#123; transform: translate(0.5px, 2.5px) rotate(0.5deg); &#125; 12% &#123; transform: translate(1.5px, 1.5px) rotate(0.5deg); &#125; 14% &#123; transform: translate(0.5px, 0.5px) rotate(0.5deg); &#125; 16% &#123; transform: translate(-1.5px, -0.5px) rotate(1.5deg); &#125; 18% &#123; transform: translate(0.5px, 0.5px) rotate(1.5deg); &#125; 20% &#123; transform: translate(2.5px, 2.5px) rotate(1.5deg); &#125; 22% &#123; transform: translate(0.5px, -1.5px) rotate(1.5deg); &#125; 24% &#123; transform: translate(-1.5px, 1.5px) rotate(-0.5deg); &#125; 26% &#123; transform: translate(1.5px, 0.5px) rotate(1.5deg); &#125; 28% &#123; transform: translate(-0.5px, -0.5px) rotate(-0.5deg); &#125; 30% &#123; transform: translate(1.5px, -0.5px) rotate(-0.5deg); &#125; 32% &#123; transform: translate(2.5px, -1.5px) rotate(1.5deg); &#125; 34% &#123; transform: translate(2.5px, 2.5px) rotate(-0.5deg); &#125; 36% &#123; transform: translate(0.5px, -1.5px) rotate(0.5deg); &#125; 38% &#123; transform: translate(2.5px, -0.5px) rotate(-0.5deg); &#125; 40% &#123; transform: translate(-0.5px, 2.5px) rotate(0.5deg); &#125; 42% &#123; transform: translate(-1.5px, 2.5px) rotate(0.5deg); &#125; 44% &#123; transform: translate(-1.5px, 1.5px) rotate(0.5deg); &#125; 46% &#123; transform: translate(1.5px, -0.5px) rotate(-0.5deg); &#125; 48% &#123; transform: translate(2.5px, -0.5px) rotate(0.5deg); &#125; 50% &#123; transform: translate(-1.5px, 1.5px) rotate(0.5deg); &#125; 52% &#123; transform: translate(-0.5px, 1.5px) rotate(0.5deg); &#125; 54% &#123; transform: translate(-1.5px, 1.5px) rotate(0.5deg); &#125; 56% &#123; transform: translate(0.5px, 2.5px) rotate(1.5deg); &#125; 58% &#123; transform: translate(2.5px, 2.5px) rotate(0.5deg); &#125; 60% &#123; transform: translate(2.5px, -1.5px) rotate(1.5deg); &#125; 62% &#123; transform: translate(-1.5px, 0.5px) rotate(1.5deg); &#125; 64% &#123; transform: translate(-1.5px, 1.5px) rotate(1.5deg); &#125; 66% &#123; transform: translate(0.5px, 2.5px) rotate(1.5deg); &#125; 68% &#123; transform: translate(2.5px, -1.5px) rotate(1.5deg); &#125; 70% &#123; transform: translate(2.5px, 2.5px) rotate(0.5deg); &#125; 72% &#123; transform: translate(-0.5px, -1.5px) rotate(1.5deg); &#125; 74% &#123; transform: translate(-1.5px, 2.5px) rotate(1.5deg); &#125; 76% &#123; transform: translate(-1.5px, 2.5px) rotate(1.5deg); &#125; 78% &#123; transform: translate(-1.5px, 2.5px) rotate(0.5deg); &#125; 80% &#123; transform: translate(-1.5px, 0.5px) rotate(-0.5deg); &#125; 82% &#123; transform: translate(-1.5px, 0.5px) rotate(-0.5deg); &#125; 84% &#123; transform: translate(-0.5px, 0.5px) rotate(1.5deg); &#125; 86% &#123; transform: translate(2.5px, 1.5px) rotate(0.5deg); &#125; 88% &#123; transform: translate(-1.5px, 0.5px) rotate(1.5deg); &#125; 90% &#123; transform: translate(-1.5px, -0.5px) rotate(-0.5deg); &#125; 92% &#123; transform: translate(-1.5px, -1.5px) rotate(1.5deg); &#125; 94% &#123; transform: translate(0.5px, 0.5px) rotate(-0.5deg); &#125; 96% &#123; transform: translate(2.5px, -0.5px) rotate(-0.5deg); &#125; 98% &#123; transform: translate(-1.5px, -1.5px) rotate(-0.5deg); &#125; 0%, 100% &#123; transform: translate(0, 0) rotate(0); &#125;&#125; 如果单独写成css的 你就在header.php里面加上 1&amp;amp;lt;link rel="stylesheet" href="https://www.ohyhello.com/live2d/live2d.css" type="text/css"/&amp;amp;gt; 调用你自己的css 如一切正常，刷新网页后，可爱的Pio就会出现在页面左下角，点击会播放不同的动作并有相应提示文字 结语：按照以上步骤的话你的博客大概已经出现了卡哇伊的看板娘了注意检查细节特别是waifu-tips.js里面有调用一个json注意别写错路径了 参考&amp;相关连接hexo-helper-live2dlive2d_src 修改模型@猫与向日葵 部分内容转载@猫与向日葵 部分内容转载@JiuMeng live2d 什么是live2d Live2D Viewer – Live2D Cubism 2 中文說明書 药水制作师Unity StudioUABE]]></content>
      <tags>
        <tag>Wesite</tag>
        <tag>HTML</tag>
        <tag>JavaScript</tag>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[给网页添加鼠标点击特效]]></title>
    <url>%2F2017%2F12%2F%E7%BB%99%E7%BD%91%E9%A1%B5%E6%B7%BB%E5%8A%A0%E9%BC%A0%E6%A0%87%E7%82%B9%E5%87%BB%E7%89%B9%E6%95%88%2F</url>
    <content type="text"><![CDATA[最近折腾网页，会陆续分享一些东西给大家 前言偶尔看见别人网页鼠标点击会有特殊效果，一般都是基于js/css实现的，这篇文章会介绍anime.js和如何添加鼠标点击效果 Anime.js 简介Github项目 anime.js是一款功能强大的Javascript动画库插件。anime.js可以和CSS3属性，SVG，DOM元素和JS对象一起工作，制作出各种高性能，平滑过渡的动画效果。 浏览器支持 Chrome Safari IE / Edge Firefox Opera 24+ 6+ 10+ 32+ 15+ 使用123$ npm install animejs# OR$ bower install animejs 1import anime from 'animejs' 或者手动 下载 然后在你的网页上链接 anime.min.js ： 1&lt;script src="anime.min.js"&gt;&lt;/script&gt; 自定义anime.js功能极其强大，具体参数设置详见官方文档，点我了解代码详情 有兴趣可以移步。 你也可以找到喜欢的样式时看看源代码，如果包含了anime.min.js/anime.js你就需要找到另外一个自定义的js文件然后保存到网站目录 添加在&lt;/body&gt;前添加 12345&lt;script type="text/javascript" src="你的文件目录/anime.js"&gt;&lt;/script&gt;&lt;script type="text/javascript" src="你的文件目录/xxxx.js"&gt;&lt;/script&gt;或者&lt;script type="text/javascript" src="你的文件目录/anime.min.js"&gt;&lt;/script&gt;&lt;script type="text/javascript" src="你的文件目录/xxxx.js"&gt;&lt;/script&gt; Download anime.js Now Download anime.min.js Now 后话碰见自己喜欢的js/css一定要保存下来。就和妹子一样]]></content>
      <tags>
        <tag>HTML</tag>
        <tag>JavaScript</tag>
        <tag>Website</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[利用Node.js解决Win-VS编译的文件到Xcode出现乱码的问题]]></title>
    <url>%2F2017%2F12%2F%E8%A7%A3%E5%86%B3WinVS%E7%BC%96%E8%AF%91%E7%9A%84%E6%96%87%E4%BB%B6%E5%88%B0Xcode%E5%87%BA%E7%8E%B0%E4%B9%B1%E7%A0%81%E7%9A%84%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[在iOS混编的时候，经常会共用跨平台文件，导入到Xcode中，有的格式就可能会识别不了，就会变成乱码，比如说GBK，GB2312（理论上有的文件xcode是可以识别的）。为了可以统一转化这些文件的编码，可以使用Node.js来完成这项工作。 今天心情相当复杂 一.Node.js简介Node.js 不是一种独立的语言,Node.js 也不是一个 JavaScript 框架。Node.js 是一个让 JavaScript 运行在服务端的开发平台。他跳过了http服务器，速度更快，性能更高！ 学习网站：点我跳转 V8引擎本身就是用于Chrome浏览器的JS解释部分，但是Ryan Dahl把V8搬到了服务器上，用于做服务器的软件。 Node.js是一个让JavaScript运行在服务器端的开发平台，它让JavaScript的触角伸到了服务器端，可以与PHP、JSP、Pythod、Ruby平起平坐。 但Node有点不同： Node.js不是一种独立的语言，与php、ASP.Net、JSP、Pythod、Perl、Ruby的既是语言，也是平台不同，Node.js的使用JavaScript进行编程，运行在chrome V8引擎上。 与php、JSP等相比（php、asp.Net、JSP、.net都需要运行在服务器上），Node.js跳过了Apache、Nginx、IIS等HTTP服务器，它自己不用建设在任何服务器软件上，Node.js的许多设计理念与经典架构（LAMP）有着很大的不同，可以提供强大的伸缩能力。 Node.js 与 JavaScript JavaScript 是由 ECMAScript、文档对象模型（DOM）和浏览器对象模型（BOM）组成的，而 Mozilla 则指出 JavaScript 由Core JavaScript 和 Client JavaScript 组成。我们可以认为，Node.js 中所谓的 JavaScript 只是 Core JavaScript，或者说是 ECMAScript 的一个实现，不包含 DOM、BOM 或者 Client JavaScript。这是因为 Node.js 不运行在浏览器中，所以不需要使用浏览器中的许多特性。 Node.js 是一个让 JavaScript 运行在浏览器之外的平台。它实现了诸如文件系统、模块、包、操作系统 API、网络通信等 Core JavaScript 没有或者不完善的功能。历史上将 JavaScript移植到浏览器外的计划不止一个，但Node.js 是最出色的一个。 Node.js 的 JavaScript 引擎是 V8，来自 Google Chrome 项目。V8 号称是目前世界上最快的 JavaScript 引擎，经历了数次引擎革命，它的 JIT（Just-in-time Compilation，即时编译）执行速度已经快到了接近本地代码的执行速度。Node.js 不运行在浏览器中，所以也就不存在 JavaScript 的浏览器兼容性问题，你可以放心地使用 JavaScript 语言的所有特性 二.Node.js配置1.安装1.NodeJS提供了一些安装程序，都可以在nodejs.org这里下载并安装。 2.通过brew安装（brew 又叫Homebrew，是Mac OSX上的软件包管理工具，能在Mac中方便的安装软件或者卸载软件， 只需要一个命令） i&gt;.首先安装brew 12&gt; /usr/bin/ruby -e "$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)"&gt; 将以上命令粘贴至终端。 脚本会在执行前暂停，并说明将它将做什么。高级安装选项在 这里。 ii&gt;.通过brew安装node brew install node Homebrew 会将软件包安装到独立目录，并将其文件软链接至 /usr/local 2.更新node.js 一行命令 版本升级 npm install -g n # 显示错误 所以用 sudo npm install -g n 来代替 如果提示错误，在打开bash的时候使用 sudo -s 回车输入密码即可。 三.iconv-lite配置输入npm install iconv-lite就可以安装了 四.完整代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950// 文件名 index.jsconst fs = require('fs'); const path = require('path'); const iconv = require('iconv-lite');console.log('爬虫程序开始运行...')var root = path.join(__dirname) readDir(path.join(root)) console.log('爬虫程序结束运行...')function readDir(subPath)&#123; fs.readdir(subPath,function(err,menu)&#123; if(!menu) return; menu.forEach(function(ele)&#123; fs.stat(subPath+"/"+ele,function(err,info)&#123; if(info.isDirectory())&#123; readDir(subPath+"/"+ele); &#125;else&#123; // 先判断后缀名 if (isContains(ele, '.h') || isContains(ele, '.hpp') || isContains(ele, '.cpp') || isContains(ele, '.c') || isContains(ele, '.m') || isContains(ele, '.mm')) &#123; transStr(subPath, ele) &#125; &#125; &#125;) &#125;) &#125;) &#125; // 判断是是否包含字符串function isContains(str, substr) &#123; return str.indexOf(substr) &gt;= 0;&#125;// 转化文件中的编码方式function transStr(fontPath, subPath) &#123; var filePath = path.resolve(fontPath, subPath); console.log("file: " + filePath) var data = fs.readFileSync(filePath); var change_data = iconv.decode(data,'gbk'); var aie = iconv.encode(change_data,'utf8'); fs.writeFileSync(filePath, aie);&#125; 有哪个文件夹中的文件需要转化，那就把这个文件（index.js命名可以随便）放在哪个文件夹或者是上一层，只要在终端中，跳转到当前的目录下，然后执行node index.js就可以了。 现在我们简单的分析一下代码的流程 1. 导入模块123const fs = require('fs'); const path = require('path'); const iconv = require('iconv-lite'); 导入需要用到的三个node的模块，fs是处理文件流的，path是处理路径的，iconv-lite是进行编码转化的。 2. 获取路径12var root = path.join(__dirname) readDir(path.join(root)) __dirname 获得当前文件所在目录的完整目录名 3. 遍历所有文件夹中的文件1234567891011121314151617181920212223function readDir(subPath)&#123; fs.readdir(subPath,function(err,menu)&#123; if(!menu) return; menu.forEach(function(ele)&#123; fs.stat(subPath+"/"+ele,function(err,info)&#123; if(info.isDirectory())&#123; readDir(subPath+"/"+ele); &#125;else&#123; // 先判断后缀名 if (isContains(ele, '.h') || isContains(ele, '.hpp') || isContains(ele, '.cpp') || isContains(ele, '.c') || isContains(ele, '.m') || isContains(ele, '.mm')) &#123; transStr(subPath, ele) &#125; &#125; &#125;) &#125;) &#125;) &#125; 这里是利用递归的方式来获取文件夹的所有目录的。 fs.readdir(path, [callback(err,files)]) 以异步的方式读取文件目录。 fs.stat(path, [callback(err, stats)]) 获取文件信息 在这里加了一个判断，如果文件的后缀名是.h .hpp .c .cpp .m .mm的的时候，才会进行编码的转化。 4. 转化文件中的编码方式12345678910function transStr(fontPath, subPath) &#123; var filePath = path.resolve(fontPath, subPath); console.log("file: " + filePath) var data = fs.readFileSync(filePath); var change_data = iconv.decode(data,'gbk'); var aie = iconv.encode(change_data,'utf8'); fs.writeFileSync(filePath, aie);&#125; 最后一部分，才是本文的重点 path.resolve([from ...], to) 将参数 to 位置的字符解析到一个绝对路径里，这里解析出文件的绝对路径。 fs.readFileSync(filename, [encoding]) 异步获取文件中的数据。 fs.writeFileSync(filename, data, [options]) 异步将数据写入到文件。 iconv.decode() iconv.encode() 解码和编码数据的格式，这里的gbk utf8只是一个例子，还可以替换成其他的格式(比如gbk ISO-8859)，这个就需要尝试精神，因为有的时候我们也不知道他到底是什么编码。记得备份，不要和我一样转过去转过来都不能还原了。。。。]]></content>
      <tags>
        <tag>Xcode</tag>
        <tag>Node.js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CocoaPods安装和使用教程]]></title>
    <url>%2F2017%2F11%2FCocoaPods%E5%AE%89%E8%A3%85%E5%92%8C%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[CocoaPods安装和使用教程CocoaPods是什么？当你开发iOS应用时，会经常使用到很多第三方开源类库，比如JSONKit，AFNetWorking等等。可能某个类库又用到其他类库，所以要使用它，必须得另外下载其他类库，而其他类库又用到其他类库，“子子孙孙无穷尽也”，这也许是比较特殊的情况。总之我的意思就是，手动一个个去下载所需类库十分麻烦。另外一种常见情况是，你项目中用到的类库有更新，你必须得重新下载新版本，重新加入到项目中，十分麻烦。如果能有什么工具能解决这些恼人的问题，那将“善莫大焉”。所以，你需要 CocoaPods。 CocoaPods应该是iOS最常用最有名的类库管理工具了，上述两个烦人的问题，通过cocoaPods，只需要一行命令就可以完全解决，当然前提是你必须正确设置它。重要的是，绝大部分有名的开源类库，都支持CocoaPods。所以，作为iOS程序员的我们，掌握CocoaPods的使用是必不可少的基本技能了。 如何下载和安装CocoaPods？在安装CocoaPods之前，首先要在本地安装好Ruby环境。至于如何在Mac中安装好Ruby环境，请google一下，本文不再涉及。 假如你在本地已经安装好Ruby环境，那么下载和安装CocoaPods将十分简单，只需要一行命令。在Terminator（也就是终端）中输入以下命令（注意，本文所有命令都是在终端中输入并运行的。什么，你不知道什么是终端？请你点击左上角谢谢。） 1sudo gem install cocoapods 但是，且慢。如果你在天朝，在终端中敲入这个命令之后，有可能会发现半天没有任何反应。原因无他，因为那堵墙阻挡了cocoapods.org。我们可以用淘宝的Ruby镜像来访问cocoapods。按照下面的顺序在终端中敲入依次敲入命令： 123$ gem sources --remove https://rubygems.org/ //等有反应之后再敲入以下命令 $ gem sources -a http://ruby.taobao.org/ 为了验证你的Ruby镜像是并且仅是taobao，可以用以下命令查看： 1$ gem sources -l 只有在终端中出现下面文字才表明你上面的命令是成功的： 123*** CURRENT SOURCES *** http://ruby.taobao.org/ 上面所有的命令完成之时,你再次在终端中运行： 1$ sudo gem install cocoapods 等上十几秒钟，CocoaPods就可以在你本地下载并且安装好了，不再需要其他设置。 ##如何使用CocoaPods？ 好了，安装好CocoPods之后，接下来就是使用它。所幸，使用CocoPods和安装它一样简单，也是通过一两行命令就可以搞定。 小编在这里用两种使用场景来具体说明如何使用CocoaPods。 场景1：利用CocoaPods，在项目中导入AFNetworking类库AFNetworking类库在GitHub地址是：https://github.com/AFNetworking/AFNetworking 为了确定AFNetworking是否支持CocoaPods，可以用CocoaPods的搜索功能验证一下。在终端中输入： 1$ pod search AFNetworking 过几秒钟之后，你会在终端中看到关于AFNetworking类库的一些信息。这说明，AFNetworking是支持CocoaPods，所以我们可以利用CocoaPods将AFNetworking导入你的项目中。 首先，我们需要在我们的项目中加入CocoaPods的支持。你看到这里也许会问，CocoaPods为什么能下载AFNetworking呢，而不是下载其他类库呢？这个问题的答案是，有个文件来控制CocoaPods该下载什么。这个文件就叫做“Podfile”（注意，一定得是这个文件名，而且没有后缀）。你创建一个Podfile文件，然后在里面添加你需要下载的类库，也就是告诉CocoaPods，“某某和某某和某某某，快到碗里来！”。每个项目只需要一个Podfile文件。 好吧，废话少说，我们先创建这个神奇的PodFile。在终端中进入（cd命令）你项目所在目录，然后在当前目录下，利用vim创建Podfile，运行： 1$ vim Podfile 然后在Podfile文件中输入以下文字： 12platform :ios, &apos;7.0&apos; pod &quot;AFNetworking&quot;, &quot;~&gt; 2.0&quot; 注意，这段文字不是凭空生成的，可以在AFNetworking的github页面找到。这两句文字的意思是，当前AFNetworking支持的iOS最高版本是iOS 7.0, 要下载的AFNetworking版本是2.0。 然后保存退出。vim环境下，保存退出命令是： 1:wq 这时候，你会发现你的项目目录中，出现一个名字为Podfile的文件，而且文件内容就是你刚刚输入的内容。注意，Podfile文件应该和你的工程文件.xcodeproj在同一个目录下。 这时候，你就可以利用CocoPods下载AFNetworking类库了。还是在终端中的当前项目目录下，运行以下命令： 1$ pod install 因为是在你的项目中导入AFNetworking，这就是为什么这个命令需要你进入你的项目所在目录中运行。 运行上述命令之后，终端出现以下信息： 12345678EricmatoMacBook-Pro:CocoaPodsDemo ericwang$ pod install Analyzing dependencies Downloading dependencies Installing AFNetworking (2.0.2) Generating Pods project Integrating client project [!] From now on use `CocoaPodsDemo.xcworkspace`. 注意最后一句话，意思是：以后打开项目就用 CocoaPodsDemo.xcworkspace 打开，而不是之前的.xcodeproj文件。 你也许会郁闷，为什么会出现.xcodeproj文件呢。这正是你刚刚运行$ pod install命令产生的新文件。除了这个文件，你会发现还多了另外一个文件“Podfile.lock”和一个文件夹“Pods”。 点击 CocoaPodsDemo.xcworkspace 打开之后工程之后你会惊喜地发现，AFNetwoking已经成功导入项目了！ 现在，你就可以开始使用AFNetworking.h啦。可以稍微测试一下，在你的项目任意代码文件中输入： 天、123#import &lt;AFNetworking.h&gt; 或者 #import "AFNetworking.h" 然后编译，看看是否出错。 至此，CocoPods的第一个应用场景讲述完毕。其实过程是十分简单的。总结一下就是： 先在项目中创建Podfile，Podfile的内容是你想导入的类库。一般类库的原作者会告诉你导入该类库应该如何写Podfile； 运行命令：`$ pod install. 下面，继续讲述第二种使用场景。 场景2：如何正确编译运行一个包含CocoPods类库的项目你也许曾经遇到过（特别是新手iOS开发者）这种情况，好不容易在GitHub上找到一份代码符合自己想需求，兴冲冲下载下来，一编译，傻眼了，发现有各种各样错误。一看，原来是缺失了各种其他第三方类库。这时候莫慌，你再仔细一看，会发现你下载的代码包含了Podfile。没错，这意味着你可以用CocoaPods很方便下载所需要的类库。 下面，以代码 UAAppReviewManager 为例来说明如何正确编译运行一个包含CocoPods类库的项目。 UAAppReviewManager是一个能够让你方便地将提醒用户评分的功能加入你的应用中。当你去UAAppReviewManager的GitHub地址下载这份代码之后，打开Example工程（UAAppReviewManagerExample），编译，你会发现Xcode报告一大堆错误，基本都是说你编译的这份代码找不到某某头文件，这就意味着你要成功编译UAAppReviewManager的Example代码，必须先导入一些第三方类库。同时你会发现在UAAppReviewManagerExample文件夹下面有三个跟CocosPods相关的文件（文件夹）：Podfile，Podfile.lock和Pods 这时候，打开终端，进入UAAppReviewManagerExample所在的目录，也就是和Podfile在同一目录下，和场景1一样，输入以下命令（由于已经有Podfile，所以不需要再创建Podfile）： 1$ pod update 过几秒（也许需要十几秒，取决于你的网络状况）之后，终端出现： 12345678Analyzing dependencies Fetching podspec for `UAAppReviewManager` from `../` Downloading dependencies Installing UAAppReviewManager (0.1.6) Generating Pods project Integrating client project [!] From now on use `UAAppReviewManagerExample.xcworkspace`. 这时候，再回到UAAppReviewManagerExample文件夹看一看，会看到多了一个文件UAAppReviewManagerExample.xcworkspace： 根据终端的信息提示，你以后就需用新产生的UAAppReviewManagerExample.xcworkspace来运行这个Example代码了。 打开UAAppReviewManagerExample.xcworkspace，编译运行，成功！ 注意，这里有个小问题，如果刚刚你不是输入$ pod update，而是输入$ pod install，会发现类库导入不成功，并且终端出现下面提示： 12[!] Required version (UAAppReviewManager (from `../`)) not found for `UAAppReviewManager`. Available versions: 0.1.6 这里的意思大概是Podfile文件过期，类库有升级，但是Podfile没有更改。$ pod install只会按照Podfile的要求来请求类库，如果类库版本号有变化，那么将获取失败。但是 $ pod update会更新所有的类库，获取最新版本的类库。而且你会发现，如果用了 $ pod update，再用 $ pod install 就成功了。 那你也许会问，什么时候用 $ pod install，什么时候用 $ pod update 呢，不知道类库有没有新版本。那你每次直接用 $ pod update 或者先用 $ pod install，如果不行，再用 $ pod update。 上述都只是CocoaPods的最基本用法。要继续研究CocoaPods其他高级用法，请点击这里CocoaPods Wiki。]]></content>
      <tags>
        <tag>Swift</tag>
        <tag>iOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Swift-自动布局SnapKit]]></title>
    <url>%2F2017%2F11%2FSwift-%E8%87%AA%E5%8A%A8%E5%B8%83%E5%B1%80SnapKit%2F</url>
    <content type="text"><![CDATA[Swift自动布局SnapKit的详细使用介绍简介SnapKit，一个经典的Swift版的第三方库，专门用于项目的自动布局，目前在github上的stars就高达11346颗星，这是一个不小的数字，亦足以证明它存在的非凡意义和作用。作者认为，在iOS开发（swift）中，它是用于项目最优秀的自动布局的必选库之一。它的作者仍然是写Objective-C的第三方库Masonry的大牛 - Robert Payne，开门见山，本文将详细介绍介绍SnapKit的详细使用和安装，相信对于初入门该库的开发者或许会有一定的帮助，当然，鉴于作者能力有限，如有不足之处，欢迎指点和批评。 Snapkit的安装环境配置要求： iOS 8.0 / Mac OS X 10.11+ Xcode 8.0+ Swift 3.0+ 安装在已经安装CocoaPods的前提下， 即可以进行下列步骤。 在你的项目工程里的Podfile文件里面添加 123456789source &apos;https://github.com/CocoaPods/Specs.git&apos;platform :ios, &apos;10.0&apos;use_frameworks!target &apos;这里是你的工程名称&apos; do pod &apos;SnapKit&apos;, &apos;~&gt; 3.0&apos;end 老生常谈，运行CocoaPods的如下命令 1pod install 到此，不出意外的话，你已经将SnapKit集成到你的项目中了。然后，就开始讲怎么使用它了。 Snapkit的布局使用1、 实现一个宽高为100，居于当前视图的中心的视图布局，示例代码如下 123456789101112131415161718import UIKitimport SnapKitclass ViewController: UIViewController &#123; override func viewDidLoad() &#123; super.viewDidLoad() let testView = UIView() testView.backgroundColor = UIColor.cyan view.addSubview(testView) testView.snp.makeConstraints &#123; (make) in make.width.equalTo(100) // 宽为100 make.height.equalTo(100) // 高为100 make.center.equalTo(view) // 位于当前视图的中心 &#125; &#125;&#125; 更简洁的写法可以 1234567891011121314151617import UIKitimport SnapKitclass ViewController: UIViewController &#123; override func viewDidLoad() &#123; super.viewDidLoad() let testView = UIView() testView.backgroundColor = UIColor.cyan view.addSubview(testView) testView.snp.makeConstraints &#123; (make) in make.width.height.equalTo(100) // 链式语法直接定义宽高 make.center.equalToSuperview() // 直接在父视图居中 &#125; &#125;&#125; 效果图 2、View2位于View1内， view2位于View1的中心， 并且距离View的边距的距离都为20 123456789101112131415161718192021222324252627import UIKitimport SnapKitclass ViewController: UIViewController &#123; override func viewDidLoad() &#123; super.viewDidLoad() // 黑色视图作为父视图 let view1 = UIView() view1.frame = CGRect(x: 0, y: 0, width: 300, height: 300) view1.center = view.center view1.backgroundColor = UIColor.black view.addSubview(view1) // 测试视图 let view2 = UIView() view2.backgroundColor = UIColor.magenta view1.addSubview(view2) view2.snp.makeConstraints &#123; (make) in make.top.equalToSuperview().offset(20) // 当前视图的顶部距离父视图的顶部：20（父视图顶部+20） make.left.equalToSuperview().offset(20) // 当前视图的左边距离父视图的左边：20（父视图左边+20） make.bottom.equalToSuperview().offset(-20) // 当前视图的底部距离父视图的底部：-20（父视图底部-20） make.right.equalToSuperview().offset(-20) // 当前视图的右边距离父视图的右边：-20（父视图右边-20） &#125; &#125;&#125; 更简洁的写法 123456789101112131415161718192021222324import UIKitimport SnapKitclass ViewController: UIViewController &#123; override func viewDidLoad() &#123; super.viewDidLoad() // 黑色视图作为父视图 let view1 = UIView() view1.frame = CGRect(x: 0, y: 0, width: 300, height: 300) view1.center = view.center view1.backgroundColor = UIColor.black view.addSubview(view1) // 测试视图 let view2 = UIView() view2.backgroundColor = UIColor.magenta view1.addSubview(view2) view2.snp.makeConstraints &#123; (make) in make.edges.equalToSuperview().inset(UIEdgeInsets(top: 20, left: 20, bottom: 20, right: 20)) &#125; &#125;&#125; 效果图 3、布局一个视图view2， 让它的水平中心线小于等于另一个视图view2的左边，可以这样布局 1234567891011121314151617181920212223242526272829import UIKitimport SnapKitclass ViewController: UIViewController &#123; override func viewDidLoad() &#123; super.viewDidLoad() // 黑色视图作为父视图 let view1 = UIView() view1.frame = CGRect(x: 0, y: 0, width: 300, height: 300) view1.center = view.center view1.backgroundColor = UIColor.black view.addSubview(view1) // 测试视图 let view2 = UIView() view2.backgroundColor = UIColor.magenta view1.addSubview(view2) view2.snp.makeConstraints &#123; (make) in // 让顶部距离view1的底部为10的距离 make.top.equalTo(view1.snp.bottom).offset(10) // 设置宽、高 make.width.height.equalTo(100) // 水平中心线&lt;=view1的左边 make.centerX.lessThanOrEqualTo(view1.snp.leading) &#125; &#125;&#125; 效果图 视图的属性说明通过上面的大致简单布局我们对SnapKit有了一个基本的了解，那么， 它的布局属性是怎么来的呢？和原生的布局类有什么关联？ 下面看一个SnapKit的布局属性表 从表中，我们知道，Snapkit的布局属性都是源自于系统的NSLayoutAttribute，那么，NSLayoutAttribute是个什么呢？其实，它在swift中是一个枚举，内部列举了很多布局属性诸如top、left、leading、centerX等，Snapkit的布局属性与它们都存在一一的对应关系。 Snapkit 的 greaterThanOrEqualTo 属性如果想让视图View2的左边&gt;=父视图View1的左边， 这时我们就可以用到greaterThanOrEqualTo 12345678910111213141516171819202122232425262728293031import UIKitimport SnapKitclass ViewController: UIViewController &#123; override func viewDidLoad() &#123; super.viewDidLoad() // 黑色视图作为父视图 let view1 = UIView() view1.frame = CGRect(x: 0, y: 0, width: 300, height: 300) view1.center = view.center view1.backgroundColor = UIColor.black view.addSubview(view1) // 测试视图 let view2 = UIView() view2.backgroundColor = UIColor.magenta view1.addSubview(view2) view2.snp.makeConstraints &#123; (make) in // 让顶部距离view1的底部为10的距离 make.top.equalTo(view1.snp.bottom).offset(10) // 设置宽、高 make.width.height.equalTo(100) // 水平中心线&lt;=view1的左边 make.left.greaterThanOrEqualTo(view1) // 或者, 和上面一行代码一样的效果// make.left.greaterThanOrEqualTo(view1.snp.left) &#125; &#125;&#125; 效果图 其实，greaterThanOrEqualTo这个属性有点多余，比如上面这行代码 make.left.greaterThanOrEqualTo(view1) ， 我们可以换成 make.left.equalToSuperview()或make.left.equalTo(view1.snp.left)， 效果是一样的，也就是说，一般情况下 &gt;= 或 &lt;= 我们都可以直接用equalTo来代替！ SnapKit的greaterThanOrEqualTo和lessThanOrEqualTo联合使用当我们想要让某个视图的width或height大于等于某个特定的值，小于等于某个特定的值的时候，一般而言，Snapkit会以greaterThanOrEqualTo为准，这里举一个width的例子，为了方便，这里指贴出了viewDidLoad中的代码（其他没必要） 1234567891011121314151617// 黑色视图作为父视图let view1 = UIView()view1.frame = CGRect(x: 0, y: 0, width: 300, height: 300)view1.center = view.centerview1.backgroundColor = UIColor.blackview.addSubview(view1)// 测试视图let view2 = UIView()view2.backgroundColor = UIColor.magentaview1.addSubview(view2)view2.snp.makeConstraints &#123; (make) in make.width.lessThanOrEqualTo(300) make.width.greaterThanOrEqualTo(200) make.height.equalTo(100) make.center.equalToSuperview()&#125; 接着，我们来看一下效果图 很明显，最后的宽度是以make.width.greaterThanOrEqualTo(200)为标准的，也可以这样的，在同时使用两者的情况下，greaterThanOrEqualTo的优先级略比lessThanOrEqualTo的优先级高。值得一提的是， 在上面的例子中，如果我们只设置make.width.lessThanOrEqualTo(300)，那么view2是不会显示出来的，因为view2不知道你要表达的是要显示多少，小于等于300，到底是100还是200呢？(这里指针对width和height）所以它不能确定这个约束的值，但是，如果我们单独设置make.width.greaterThanOrEqualTo(200)，那么就和上面的效果一样，因为它会以200为标准布局约束！ lessThanOrEqualTo的用于上、下、左、右如果我们想要视图view2的左边 &lt;= view1.left + 10, 那么就可以直接用到lessThanOrEqualTo布局了，看下面这个例子 1234567891011121314151617// 黑色视图作为父视图let view1 = UIView()view1.frame = CGRect(x: 0, y: 0, width: 300, height: 300)view1.center = view.centerview1.backgroundColor = UIColor.blackview.addSubview(view1)// 测试视图let view2 = UIView()view2.backgroundColor = UIColor.magentaview1.addSubview(view2)view2.snp.makeConstraints &#123; (make) in make.left.lessThanOrEqualTo(20) // &lt;= 父视图的左边+20 make.right.equalTo(-40) // = 父视图的右边-40 make.height.equalTo(100) make.center.equalToSuperview()&#125; 效果图 Snapkit布局的灵活性 Snapkit布局灵活性很强， 我们看下面的例子, 他们的效果是一样的 123make.left.equalToSuperview().offset(10)make.left.equalTo(10)make.left.equalTo(view1.snp.left).offset(10) 设置视图的大小（width，height）,他们效果是一样的 123456make.width.height.equalTo(100)或make.width.equalTo(100)make.height.equalTo(100)或make.size.equalTo(CGSize(width: 100, height: 100)) 优先级(priority) 我们来看一下Snapkit的优先级设置， 优先级都是附加在约束链的末尾处，看下面的使用方法 1234567891011121314151617// 黑色视图作为父视图let view1 = UIView()view1.frame = CGRect(x: 0, y: 0, width: 300, height: 300)view1.center = view.centerview1.backgroundColor = UIColor.blackview.addSubview(view1)// 测试视图let view2 = UIView()view2.backgroundColor = UIColor.magentaview1.addSubview(view2)view2.snp.makeConstraints &#123; (make) in make.width.equalTo(100).priority(666) make.width.equalTo(250).priority(999) make.height.equalTo(111) make.center.equalToSuperview()&#125; 效果图 从上面我们可以知道, 我们设置了两个优先级：make.width.equalTo(100).priority(666) 和 make.width.equalTo(250).priority(999)， 那运行结果是一个哪个为准呢？显然是以优先级为 999的为准，因为 priority(999)&gt;priotity(666)， 所以在使用Snapkit的过程中，有时我们可以使用优先级priority来设置我们的约束， 另外，值得一提的是，SnapKit的优先级最大值只能是 1000， 如果优先级的数值超过1000，则运行时就会Crash！这里要尤其注意。 更新约束（引用约束） 我们可以通过保存某一个约束布局来更新相应的约束，或者保存一组约束布局到一个数组中更新约束， 具体看下面代码 12345678910111213141516171819202122232425262728293031323334// 保存约束（引用约束）var updateConstraint: Constraint?override func viewDidLoad() &#123; super.viewDidLoad() // 黑色视图作为父视图 let view1 = UIView() view1.frame = CGRect(x: 0, y: 0, width: 300, height: 300) view1.center = view.center view1.backgroundColor = UIColor.black view.addSubview(view1) // 测试视图 let view2 = UIView() view2.backgroundColor = UIColor.magenta view1.addSubview(view2) view2.snp.makeConstraints &#123; (make) in make.width.height.equalTo(100) // 宽高为100 self.updateConstraint = make.top.left.equalTo(10).constraint // 距离父视图上、左为10 &#125; let updateButton = UIButton(type: .custom) updateButton.backgroundColor = UIColor.brown updateButton.frame = CGRect(x: 100, y: 80, width: 50, height: 30) updateButton.setTitle("更新", for: .normal) updateButton.addTarget(self, action: #selector(updateConstraintMethod), for: .touchUpInside) view.addSubview(updateButton)&#125;// 更新约束func updateConstraintMethod() &#123; self.updateConstraint?.update(offset: 50) // 更新距离父视图上、左为50&#125; 更新约束(snp.updateConstraints) 说起这个updateConstraints, 我也懵逼过，那么它到底有何作用呢？又怎么用呢？它和一开始就使用的makeConstraints又有什么明确的区别呢？请继续往下看 说明1：如果你这是更新某个约束或某几个约束的常量值，你就可以使用updateConstraints而不是makeConstraints。 说明2：这个也是苹果推荐用来添加或更新约束的方式 说明3：这个方法可以调用多次，会相应setNeedsUpdateConstraints, 在控制器中，可以写在override func updateViewConstraints()方法里面（当然也可以写在你想要什么时候更新的点击事件里面） 12345678910111213141516171819202122232425262728293031323334import UIKitimport SnapKitclass ViewController: UIViewController &#123; lazy var blackView = UIView() override func viewDidLoad() &#123; super.viewDidLoad() blackView.backgroundColor = UIColor.black view.addSubview(blackView) blackView.snp.makeConstraints &#123; (make) in // 四个约束确定位置和大小 make.width.equalTo(100) make.height.equalTo(150) make.top.equalTo(10) make.centerX.equalToSuperview() &#125; &#125; override func updateViewConstraints() &#123; blackView.snp.updateConstraints &#123; (make) in // 更新距离父视图顶部的约束（从 10 ---&gt; 300 ） make.top.equalTo(300) &#125; // 根据苹果，调用父类应该放在末尾 super.updateViewConstraints() &#125;&#125; 注意: 从上面的代码中我们很明确地知道， blackView通过width、height、top、centerX确定了它本身的大小和位置， 但是， 在 run 出来之后，它的top改变了距离， 从 10 变成了 300，其他三个约束保持不变， 见下图效果： 显而易见， 除了top约束， 其他都没有改变！ 也就是说，约束被更新（相当于系统升级一样，是一个道理） 现在，我们通过UIButton的点击事件来证明一下制作约束makeConstraints和updateConstraints具体的区别在哪里？ 1234567891011121314151617181920212223242526272829303132lazy var blackView = UIView()override func viewDidLoad() &#123; super.viewDidLoad() blackView.backgroundColor = UIColor.black view.addSubview(blackView) blackView.snp.makeConstraints &#123; (make) in make.width.equalTo(100) make.height.equalTo(150) make.top.equalTo(50) make.centerX.equalToSuperview() &#125; let btn = UIButton(type: .custom) btn.backgroundColor = UIColor.brown btn.frame = CGRect(x: 100, y: 200, width: 60, height: 30) btn.addTarget(self, action: #selector(buttonAction), for: .touchUpInside) view.addSubview(btn)&#125;// 点击更新/制作约束func buttonAction() &#123; blackView.snp.makeConstraints &#123; (make) in make.width.height.equalTo(20) make.top.equalTo(300) &#125;&#125; 先看效果图 点击事件发生前(图1）： 点击事件发生后（图2） 图3 图4 上面，我们知道，视图 blackView一开始是由四个约束确定位置和大小，在点击事情响应后，我们又给 blackView 制作（记住，是制作，而不是重做，两者有明确的区别）了3个约束，分别是 width、height、top, 那么这样做问题出现在哪里呢？ 第一， 点击事情发生前（图1）， 在点击事件发生后（见图2）， 我们发现，blackView的width、height约束改变了，但是 top却没有改变，还是原来的距离父视图顶部 50 的距离， 原因在于，我们在原来的约束基础上又添加了多余的约束， 也就是说，约束从4个变成了7个（见图3左边constraints）， 这样就产生了约束不明确，进而导致snapkit的警告（见图4）， 这样布局显然是不可取的，在项目中这样做极其危险，甚至可能会导致异常奔溃！！！！ 现在， 我们该将点击事件中的约束布局从makeConstraints改变成updateConstraints来试试两者有什么区别(下面只添加了点击事件的代码，其他事重复的就不多此一举了） 12345678func buttonAction() &#123; // 注意这里是updateConstraints， 而不是makeConstraints blackView.snp.updateConstraints &#123; (make) in make.width.height.equalTo(20) make.top.equalTo(300) &#125; print(&quot;这里试试snapkit有没有报警告&quot;)&#125; 接着看点击事件后的效果图 图5 图6 图7 发现没有，在将makeConstraints改变成updateConstraints之后，约束还是4个，snapkit没有报警告，点击事件中的width、height、top全部起了作用，而这就是两者的本质区别：makeConstraints是制作约束，在原来的基础上再添加另外的约束，也就是画蛇添足，约束增加，视图布局就有不确定性，从而有些约束起作用，有些不起作用（如上面的top），snapkit报警告！！！而updateConstraints是更新约束，改变原有约束，约束不会增加，没经过updateConstraints处理的保持原有约束，经过处理就更新约束，约束不会减少，snapkit不会产生警告，这是正常标准的更新约束的正确方式！！！ 重做约束（remakeConstraints） 重做约束的本质就是：去掉已有的所有约束， 重新做约束，记住，是做约束， 也就是说， 使用了remakeConstraints后，重做的约束必须要能确定相应视图的大小和位置, 之前makeConstraints的约束已经不会存在了，完全销毁！！！ 1234567891011// 点击更新/制作约束func buttonAction() &#123; // 注意这里是 remakeConstraints blackView.snp.remakeConstraints &#123; (make) in make.width.height.equalTo(20) make.top.equalTo(300) &#125; print("这里试试snapkit有没有报警告")&#125; 效果图 图（1） 图（2） 图（3） 我们看到， blackView重做了约束， 之前的约束不起任何作用，由于它在重做约束后只有 3 个约束分别是 width、height、top, 但是这里有一个问题，就是这 3 个约束只能确定大小，无法确定视图的位置， 所以在水平方向上或者左右缺少一个布局条件， 故 blackView整体视图的x紧靠左边（默认）！ 另外我们发现， 在图（3）中，右上角出现了一个感叹号“！”, 那是因为告诉你缺少了一个约束条件：x-xcode-debug-views://7f81fcbc7900: runtime: Layout Issues: Horizontal position is ambiguous for UIView. 小结通过以上学习，我们或深或浅地学习了布局三方库SnapKit的使用， 我相信，只要将上述布局会使用，并且懂得布局的原则和道理，基本上就可以“高枕无忧”了，至于涉及动态布局、动画布局等知识，后续有时间会更新文档。]]></content>
      <tags>
        <tag>Swift library</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[为什么 Kotlin 比你们用的那些垃圾语言都好]]></title>
    <url>%2F2017%2F11%2F%E4%B8%BA%E4%BB%80%E4%B9%88Kotlin-%E6%AF%94%E4%BD%A0%E4%BB%AC%E7%94%A8%E7%9A%84%E9%82%A3%E4%BA%9B%E5%9E%83%E5%9C%BE%E8%AF%AD%E8%A8%80%E9%83%BD%E5%A5%BD%2F</url>
    <content type="text"><![CDATA[5月18日，安卓团队在谷歌 I/O 2017 大会上宣布 Kotlin 成为官方头等支持语言。这条爆炸性资讯在当天就是 Hacker News 首页热门讨论，与此同时，谷歌技术大牛 Steve Yegge 也写了一篇关于 Kotlin 的使用体会总结文章，同样也在首页热门，并引发大量讨论（点击进入原文） ​ （Steve Yegge ） 为什么说 Kotlin 比你们用的那些垃圾语言都好哈，这个标题党的题目让你点进来看了吧。不要奇怪，现在标题党在网上很普遍的。而且这篇文章给出的回答，肯定能震撼到你。 说真的，其实我不想去攻击你们的语言信仰……至少不会“大大地”想。毕竟你喜欢的语言大放异彩的时期，可能要追溯到冰川时代了，对不？如果你喜欢的语言到今天还没有死，那只能说明这门语言在逐渐地改进和更新，保持与时俱进。 但改进的速度呢？好吧……假设你现在用的语言碰巧是 Java，并且你也沉溺于 Java 曾经是一门非常优秀的语言的想法，那么你就完蛋了。而且是早就完蛋了。尽管人类都不太喜欢思考终极命运问题，但是相比于在 20 多年前刚刚问世，Java 8 仅仅是做了部分语言特性的替换，对此你禁不住要想：“我真的要和这种语言来共度过的余生么？还是说 Java 也就只能这样了？” 因为终于要开始做 Android 开发了，我把各种老旧的语言问题又过了一遍。我写过一个老游戏 Wyvern，这个游戏已经有一个 iOS 版本了，最近我决定再搞一个 Android 版本。我从来没料到计算机语言会折腾到让我“思考人生”（例如“我这是他娘的在浪费生命么？”）如果你写过 Android 程序的话，你就知道在 Android 领域，语言的问题是会让你相当难熬的。 我第一次尝试写 Android 程序是在去年夏天，我的个老天爷，那感觉简直糟透了。其实是有人警告过我的。他们都说：“那些 API 可是很难搞啊。”而我却不听劝。一意孤行。 我想：这些玩意儿能糟糕到哪儿去呢？反正不就是 Java 么？ 历史代码的灾难真是很不走运——因为很复杂的历史原因，并且也没人在意——造成 Android 的核心 API 实在是糟糕透顶。我是说：真的很糟，真的很糟，真的很糟。你只能关掉参考书，深呼吸，然后出去猛喝咖啡来压压惊。人们之前给我的告诫看来是完全正确的。 Android API 库就是一个百宝箱。很多 API 真的是非常好用。我可以说，很多在 iOS 开发里非常难搞的事情在 Android 里面却很容易。Product flavors、Downloads 服务、findViewById() 方法、Preferences activity 等等，这些都是很好的例子。有太多 Android 里面有的东西在 iOS 里面是诶有的，所以在 iOS 里面你总能看到：开发者自己实现的恶心的和优雅的应用库并存。 但是！注意左边是一个大写加粗的但是！在写 Android 程序的时候，人们只关注那些不好的 API，就像你开车时候只会数路上遇到了几个红灯一样，绿灯的数量是没人关心的。因为人们只会通过红灯的数量来评价路途是否通顺。 Android 确实有几个很糟糕的“红灯”API。例如 Fragments，这就是在 Andoird “红灯” API 中的招牌 API。这个 API 的整个生命周期的糟糕程度达到了令人发指的地步，好吧其实 Activities 和 Fragments 都是如此。说句不中听的，iOS 反而却没有这么糟糕的API。去年夏天我试了试这些API，它们是如此之糟糕以至于我当时就放弃了。我算是彻底服了。去它的，我还是以后找个人来帮我写这些程序吧。 接下来的一年半，我就没再碰过 Android 编程。 来自俄罗斯的救星我一直听说，有一种新语言叫做 Kotlin，可以用来写基于 JVM 或者 Android 程序。发明这种语言的不是别国，正是战斗的民族俄罗斯。更具体一点儿，它是由 JetBrains 开发。JetBrains 可是世界知名的 IDE 开发商，代表作是 Intellij IDEA，还有他们那可爱而且大名鼎鼎的橘色，绿色，紫色和黑色混合的暗色“Darcula”主题。 图：一个千年老妖按捺不住对 Java 8 的兴奋 那么为什么要给这种语言起名叫 Kotlin 呢？好吧，有一种说法是因为 Java 的第一个字母是“J”，而 Kotlin 则用了Java 的下一个字母“K”作为开头。除此之外，有人还猜想（这种猜想可能来自加州大学伯克利分校），“Kotlin”这个名字的灵感还来源于“克里姆林宫”，“赫鲁晓夫”以及“克格勃”。这些都是前苏联的骄傲，所以他们就用了一个前苏联军事基地的名字“Kotlin”来命名这种语言。总之这个名字不错，而且你会习惯它的。 伯乐在线补充：Steve Yegge 在前文关于 Kotlin 的名字来源，应该错了。在他自己原文评论中，也有网友指出了。 正确的应该是：① JetBrains 是一家注册地在捷克布拉格的公司，在全球共有 6 个办公点：布拉格、圣彼得堡、莫斯科、波士顿、慕尼黑和新西伯利亚。但主要管理层和开发者是在圣彼得堡。② 芬兰湾中有个岛就是「Kotlin/科特林」，在圣彼得堡以西 32 公里。 我发现去年业界关于 Kotlin 只是有不少“嘀咕（buzz）”。注意，只是“嘀咕”，不是天花乱坠地吹牛宣传。人们只是低调地“嘀咕”着。好吧，总之，我当时看了一下，然后就觉得这个语言和我过去 15 年看过的 50 ~ 100 种计算机语言一样，这也是一门可以替代 Java 的语言，当然，我认为任何理性的语言都能替代 Java。 对 Kotlin 的第一印象我第一次看到 Kotlin 的时候，真心觉得这种语言不可能在现实生活中用到，真的是一点可能性都没有。其实我也就是走马观花。我的第一印象？这个语言也没什么大问题。它很简洁，也具有先进的特性。如果说它时髦也行，因为它几乎囊括了计算机语言设计上的所有最新潮流。不过这也没什么大不了，因为很多语言也都满足这一点。比如，Rust。Rust 也是一门健壮的，名字起得很好的，但是没什么人用的语言。 Kotlin 给我的一种奇怪的感觉是“似曾相识”，后来我才反应过来，原来这是因为它和 Swift 很像。我之所以没有马上反应过来，是因为我的 iOS 程序因为历史代码的原因不得不用 Objective-C 而不是 Swift 来写。当然现在我也弄明白了：其实 Kotlin 的历史比 Swift 要悠久几年，所以正确的说法应该是：Swift 和 Kotlin 很像。 不过即便如此我当时也没准备用这种语言干活。Kotlin 对我来说确实是一种语法优雅的语言，但是我觉得我对这门语言还没有掌握到足够的程度，以至于让我可以用它来应付残酷的现实工作。 从 Java 叛逃到 Kotlin我不太记得我是具体怎么爱上 Kotlin 的了。但是我敢肯定的是这绝对不是有意为之。 我努力回忆了一下，事情是这样的，我做的那个游戏的玩家跟我说了好久，让我开发一个 Android 版本。这个游戏是 12 月份在 Apple Store 上架的，然后几周之内，大量粉丝就跟我说，他们是 Andorid 用户，所以没法玩到这个游戏。所以，尽管我已经“发誓”再也不碰Android 编程了，但是用户就是上帝，所以我又开始尝试了。不过这一次要换个玩儿法——不能再把胃口坏在 Android 的 Java 语言上了。我需要有个现成的框架，或者什么类似的东西，来让工作变得简单一点儿。 在 1 月中旬，我做了一个粗略评估，然后就决定用 Kotlin 来开发了，Kotlin 当时可同时支持 Dalvik 和 Art 两种 Android 虚拟机。我觉得我的评估是基于以下几个原因： \1. Kotlin 已经小有名气； \2. 当时我写 iOS 版的时候就想用 Swift（但是没用成）； \3. Kotlin有一种挺不错的 Android DSL 叫做 Anko，这勾起了我的兴趣，虽然最后我并没有真的用到它。 所以我就用 Kotlin 开始做了。在接下来的 4-5 周内，我用 Kotlin 重写了游戏的服务平台。要知道这个平台之前已经有 20 多年历史了。用了一个月的 Kotlin，我就被完全征服了。我不是要说 Scala 或者其他语言的坏话，但是对我这种普通码农来说，Koltin 是完美的。我的要求不高，给口饭吃就行，知道不？Scala 固然很好，但是它好得过头了，就像牛蛙\牛脑\松露蜗牛这些高档菜那么好。要知道我就是个蓝领，Clojure、Scala 这类的语言对我来说太高大上了。 我大约花了 3 天时间来学习 Kotlin 的各种语法，然后就开始正式编程了，虽然我还是很不熟练，但是我知道这种语言和 IDE 工具足以让我解决各种麻烦。 当我对这种语言稍微熟悉了一些以后，我就知道，我应该不会再去爱上另外一种语言了，因为 Kotlin 实在是太迷人了。你在代码写出来的东西让你觉得很酷。当然我以前用其他的语言编程的时候也体验过类似的感觉，但是那些语言的学习曲线一般都非常陡峭。Kotlin呢，它就是大救星：当 Java 程序员为了 Java 8 弄出来的一大堆新概念挠头的时候，Kotlin 出现了。Kotlin 能实现 Java 8 的各种新特性，并且通过对 coroutines 的支持，其实能实现更强大的功能，而且语法表现力更简洁。Java 8 确实也能表达很有意思的逻辑，但是很繁琐，感觉就像让你说话之前要先给你嘴里塞沙子。 我想 Kotlin 上手很容易的原因太显而易见了，要归功于它的 IDE 支持。现在几乎所有的 JVM 语言或者 Android 语言的 IDE 支持都是由社区的几个志愿者在维护（当然 Java 除外）。而 Kotlin 则是来自世界级的 IDE 厂商（Jetbrains），所以 Kotlin 打一开始就是自带 IDE 支持的。有多少语言能做到从发明伊始就能有 IDE 支持呢？编程语言的进化历程一般做不到这一点。况且有的编程语言从一开始就是要避开 IDE 这个因素的（Hi！Rob）另外一个能一开始就做到 IDE 支持的语言就是 C#，当然 C# 毫无疑问是全世界最好的编程语言之一。 伯乐在线译注：上面这段中的 Rob，应该是指 Go 语言的发明者 Rob Pike，作者在这里也许是暗讽 Go 语言从发明到现在都没有一个靠谱的 IDE 支持吧。 作为一个自带 IDE 支持的语言，你在 Kotlin buffer 敲代码的时候，打字基本对就可以了。IDE 会帮你补全你没写完的部分。你知道吗，你甚至可以把Java代码复制到IDE里面，然后 IDE 会帮你自动转换成Kotlin代码。如果你觉得 Java 的 IDE 都还不错，那么我可以很荣幸地告诉你，Kotlin IDE 会把这种“不错”推进到前所未有的地步。甚至有一个前微软工程师跟我说：“我本以为微软的 Visual Studio 是 IDE 界的标杆，是不可超越的。但是我觉得 IntelliJ IDEA 的确要更好。”在我看来，因为我对 Visual Studio 不熟悉，所以我在这里只是引用他说的话。不过我认为 IntelliJ IDEA 至少和 VS 是同等水平。 诚然，在现实工作中我还是要经常切换到 Emacs 的。IntelliJ 在你打字很快的时候还是有点儿反应不过来。如果你打字总是只打一半儿的话，那么自动补全动能的运行压力还是很大。况且对纯文本的处理也很糟糕，这是所有 IDE 的通病。所以 IDE 和 Emacs 你都是需要用到的。不幸的是，目前 Emcacs 对 Kotlin 的支持现在也就那么回事儿，不过相信以后会越来越好。我现在反正就是在 Emacs 和 IntelliJ 之间来回切换。目前还算是 OK。 就是这样了。我曾经花了大约 10 年的时间，来找一种语言来取代 Java。我真的找得很努力很辛苦。讽刺的是，在我放弃了以后，这种东西居然出来了。去看看吧。Kudos 对 JetBrains 来说，是一个惊艳的成就。 Android：Kotlin 的杀手锏这年头新生编程语言几乎很难产生什么巨大影响力。不是说现在没有新语言产生了，相反是每年都有质量不错的新语言产生，但是然并卵，没人用！要给“不可能”划定界限很难。但是计算机语言的市场已经非常饱和了。如果要让一个新的语言能够大火（而且这个规律在过去 10 到 20 年都成立），那么这个语言就必须有一个“杀手级”的应用。这门语言需要绑定一个平台，让大家都非常迫切地区使用这个平台，这才能促进大家学习这门语言以便在这个平台上编程。 就目前看来，我们上面所说的杀手级应用——也就是我们上面扯了这么多的东西——却是 Android 恶心的 API。每当你顺着 Android 路线往下走，一遇到 API 就会卡壳，这只会让你去诅咒 Android 这个平台。Android 不论有多少优秀的 API 都不管用，重要的是，Android 糟糕的 API 太多了，所以你不得不停下来去找”现成”的办法（solution）。 不过兄弟，Android 里面解决问题的“现成办法”可是不少。对于新手来说，有一大堆 Java annotation processors可用，这就为语言的问题埋下伏笔。更不要提一堆迷你的框架（比如 Lyft 的 Scoop）。还有那些和 Android（Java）完全独立的框架：React Native、Cordova、Xamarin、Flutter等等。 如果以上说的技术你都不喜欢，那么你还可以从语言的角度来解决问题。当然，那些完全独立的框架是基于特定语言的，而并不是Java。 Kotlin 的竞争优势在于它并不是完全隔离于 Java 语言。它基本上是 100% 可与 Java 相互翻译转换的。这很像C++ 与 C 的关系一样（但它们做不到 100% ）。Kotlin 也是在不断进化的。所以你可以直接把你写的 Kotlin 代码扔到 Android 工程中，连目录都不用改，然后程序就能正常运行了，方便得眼睛都不用眨一下。 其他种类的 Android 平台都倾向于迫使你去学习一种全新的语言以及对应的平台，其编程范式，理念和特性都各不相同。Kotlin 则是让你直接写出 Android 可运行的类，就跟其他 Android 程序员用 Java 写出来的一样。其实其底层的 API 都是一样的，但是 Kotlin 组织得要好很多。 还记得我去年夏天把 Android 编程书扔了然后再也不打算看了么。现在 Kotlin 则让我感觉：Android 编程是快乐的？我甚至觉得可能 Android 那些糟糕的 API 很可能并不是那么糟，只是 Java 把它搞得太恶心了而已。 Kotlin 致力于让大家绕过 Android API 那些恶心的东西，并且能让你充分发挥你的经验，这一点甚至比 iOS 做得还要好。好吧，至少来说比 Objective-C 做得好，因为我觉得 Swift 肯定也不会差。知道为什么吗？因为 Swift 和 Kotlin 很像啊。 我特别喜欢 Kotlin 的地方有哪些？嗯，这个话题其实要细说就很大了，我觉得我最好再开一篇文章来写这个。这里我就提一下那些高级（high-level）且共性的点。 Kotlin 很像 Java。它长得不像 Clojure 或者 Scala 那么奇怪（承认现实把，这两种语言就是挺奇怪的）。所以你学 Kotlin 应该很快。这门语言显然就是写给 Java 开发者来用的。 它比 Java 更安全。Java 很多需要 annotation processors 来做的事情在 Kotlin 里则是内置的，例如 overriding，nullability等等。而且 Kotlin 对数值转换的规则也更安全，虽然我不太喜欢 Kotlin 的处理方式，但是我还是很感谢这门语言强制我去思考我的数值表现形式。 Kotlin 和 Java 是可以互译的。真的是指无缝互译。我见过很多 JVM 语言最后挂掉，就是因为其不支持子类继承机制。我不知道什么时候就会用到静态内部类，非静态内部类，或者什么破玩意儿类。Kotlin 在设计时就把和Java互译的属性放在第一位，也就是说，把 Java 翻译到 Kotlin 可以逐渐进行，一次可以直接转换一个文件。 Kotlin 很简洁。你要知道我也算是个高尔夫球手，所以我实话实说。如果在一切都相同的情况下，我更喜欢短的程序，只要它写的逻辑清楚。Kotlin 对我来说就像是打了一轮好局。平均下来我发现 Kotlin 的代码长度比相同逻辑的 Jython 代码短了 5%-10%（这可是我用某种“黄金标准”测出来的），而且还能保证程序的可读性和类型安全。 Kotlin 更贴近实际。Kotlin 支持在一个文件里定义多个类，支持一等方法，操作符重载，扩展方法，类型别名，字符串模板，还有一堆看上去没什么新意的语言特性它都支持。而我就是不明白为什么 Java 什么都不支持，连人们需要的语言特性它都不做。 Kotlin 进化很快。例如刚刚宣布启动的对 coroutine 的支持，将会成为提供 asyn/await， geneator 以及所有其他无锁并发特性的基础设施。 Kotlin 很擅长“拿来主义”。Kotlin 经常从其他的计算机语言设计中抄点子，并且也毫不避讳。他们说：“我们很喜欢 C# 的处理方式，所以我们就自己照着撸了一个。” Kotlin 支持 DSL。DSL 不到深思熟虑万不得已的话千万不要引入，但是不得不承认 DSL 威力巨大。例如你看 Gradle 的 DSL 和 Maven 比，在典型的 Maven 项目里，配置代码肯定要超过上千行。所以 Kotlin 是来给你降工作压力的。 Kotlin 的 IDE 是在是太棒了。刚才不久我才在 Emacs 里写程序文件，结果 Emacs 报了一对错。而我把同样的代码拷贝到 IntelliJ 里面，然后按 Alt-Enter 逐一自动修复了 50 多条，然后所有的错误就都搞定了。这真是帮了大忙啊。 ​ Kotlin 很有趣。我跟你们说，Kotlin 就是有趣。也许这是我发自潜意识地在做广告。Kolint 的关键字和方法名都很有意思。Kotlin 把我从一个只会死编程的码农转变为了一个计算机语言的爱好者。 总之，你就这么想：我收拾东西搬家，然后碰到了邻居 Kotlin。我之前也算见过的一堆计算机语言，但是只有 Kotlin，能够让我在那么短的时间内重写我的游戏服务器代码。而我现在则是在用 Kotlin 重写我之前写过的一切。 我也知道还有好多其他的程序员也对 Kotlin 感觉非常好，打算成为 Kotlin 程序员。其中大部分的人应该在 1-2 年之内水平就能超过我了。我们私下里谈论过，互相都说“Kotlin 让编程感觉美好的感觉又回来了。”还不错，再我们尚未对编程全部失去兴趣之前，Kotlin 来了。就仿佛你只要把语言的语法学会了。这回把你带回到那种第一次学编程的感觉，无论写什么都觉得自己很牛逼。 再一次，向 JetBrains 致敬。他们对计算机语言做出了巨大的贡献！我脱帽致敬。 那么 Kotlin 比你用的任何其他编程语言都好吗？我想对我来说是的。因为，如果你碰巧是在用 Java 的话。如果你一整天就是泡在椅子面前写 Java，那么你会发现 Kotlin 简直就是一股清流。所以也让我知道你们是怎么想的吧。 免责声明：本文只是阐述Steve Yegge对 Android 开发的观点，并不代表Google或者 JetBrains 的观点。]]></content>
      <tags>
        <tag>Kotlin</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C89标准和C99标准C11标准的区别（简单总结版&&较为完整版）]]></title>
    <url>%2F2017%2F11%2FC89%E6%A0%87%E5%87%86%E5%92%8CC99%E6%A0%87%E5%87%86C11%E6%A0%87%E5%87%86%E7%9A%84%E5%8C%BA%E5%88%AB%2F</url>
    <content type="text"><![CDATA[较详细的阐述了c89/c99/c11的一些变化 ###较简单的总结 （1）对数组的增强 ​ 可变长数组 C99中,程序员声明数组时,数组的维数可以由任一有效的整型表达式确定,包括只在运行时才能确定其值的表达式,这类数组就叫做可变长数组,但是只有局部数组才可以是变长的.可变长数组的维数在数组生存期内是不变的,也就是说,可变长数组不是动态的.可以变化的只是数组的大小.可以使用*来定义不确定长的可变长数组。 ​ 数组声明中的类型修饰符 在C99中，如果需要使用数组作为函数变元，可以在数组声明的方括号内使用static关键字，这相当于告诉编译程序，变元所指向的数组将至少包含指定的元素个数。也可以在数组声明的方括号内使用restrict,volatile,const关键字，但只用于函数变元。如果使用restrict，指针是初始访问该对象的惟一途径。如果使用const，指针始终指向同一个数组。使用volatile没有任何意义。 （2）单行注释 引入了单行注释标记 “//“ , 可以象C++一样使用这种注释了。 （3）分散代码与声明 预处理程序的修改 （4）for语句内的变量声明 C99中，程序员可以在for语句的初始化部分定义一个或多个变量，这些变量的作用域仅于本for语句所控制的循环体内。比如：代码:for(int i=0; i&lt;10; i++){ // do someting …} （5）复合赋值 C99中，复合赋值中，可以指定对象类型的数组、结构或联合表达式。当使用复合赋值时，应在括弧内指定类型，后跟由花括号围起来的初始化列表；若类型为数组，则不能指定数组的大小。建成的对象是未命名的。 例： double *fp = (double[]) {1.1, 2.2, 3.3}; 该语句用于建立一个指向double的指针fp，且该指针指向这个3元素数组的第一个元素。 在文件域内建立的复合赋值只在程序的整个生存期内有效。在模块内建立的复合赋值是局部对象，在退出模块后不再存在。 (6)指定的初始化符 C99中，该特性对经常使用稀疏数组的程序员十分有用。指定的初始化符通常有两种用法：用于数组，以及用于结构和联合。用于数组的格式：[index] = vol; 其中，index表示数组的下标，vol表示本数组元素的初始化值。 例如： int x[10] = {[0] = 10, [5] = 30}; 其中只有x[0]和x[5]得到了初始化．用于结构或联合的格式如下： member-name(成员名称) 对结构进行指定的初始化时，允许采用简单的方法对结构中的指定成员进行初始化。 例如： struct example{ int k, m, n; } object = {m = 10,n = 200}; 其中，没有初始化k。对结构成员进行初始化的顺序没有限制 (7)printf()和scanf()函数系列的增强 C99中printf()和scanf()函数系列引进了处理long long int和unsigned long long int数据类型的特性。long long int 类型的格式修饰符是ll。在printf()和scanf()函数中，ll适用于d, i, o, u 和x格式说明符。另外，C99还引进了hh修饰符。当使用d, i, o, u和x格式说明符时，hh用于指定char型变元。ll和hh修饰符均可以用于n说明符。 格式修饰符a和A用在printf()函数中时，结果将会输出十六进制的浮点数。 格式如下：[-]0xh, hhhhp + d 使用A格式修饰符时，x和p必须是大写。A和a格式修饰符也可以用在scanf()函数中，用于读取浮点数。调用printf()函数时，允许在%f说明符前加上l修饰符，即%lf，但不起作用。 (8)C99新增的库 C89中标准的头文件 定义宏assert() 字符处理 错误报告 定义与实现相关的浮点值勤 定义与实现相关的各种极限值 支持函数setlocale() 数学函数库使用的各种定义 支持非局部跳转 定义信号值 支持可变长度的变元列表 定义常用常数 支持文件输入和输出 其他各种声明 支持串函数 支持系统时间函数 C99新增的头文件和库 支持复数算法 给出对浮点状态标记和浮点环境的其他方面的访问 定义标准的、可移植的整型类型集合。也支持处理最大宽度整数的函数 首先在此1995年第一次修订时引进，用于定义对应各种运算符的宏 支持布尔数据类型类型。定义宏bool，以便兼容于C++ 定义标准的、可移植的整型类型集合。该文件包含在中 定义一般类型的浮点宏 首先在1995年第一次修订时引进，用于支持多字节和宽字节函数 首先在1995年第一次修订时引进，用于支持多字节和宽字节分类函数** (10)func预定义标识符 用于指出func所存放的函数名，类似于字符串赋值。** (11) 其它特性的改动 放宽的转换限制 限制 C89标准 C99标准 数据块的嵌套层数 15 127 条件语句的嵌套层数 8 63 内部标识符中的有效字符个数 31 63 外部标识符中的有效字符个数 6 31 结构或联合中的成员个数 127 1023 函数调用中的参数个数 31 127 不再支持隐含式的int规则 删除了隐含式函数声明 对返回值的约束 C99中,非空类型函数必须使用带返回值的return语句. 扩展的整数类型 扩展类型 含义 int16_t 整数长度为精确16位 int_least16_t 整数长度为至少16位 int_fast32_t 最稳固的整数类型,其长度为至少32位 intmax_t 最大整数类型 uintmax_t 最大无符号整数类型 对整数类型提升规则的改进 C89中,表达式中类型为char,short int或int的值可以提升为int或unsigned int类型. C99中,每种整数类型都有一个级别.例如:long long int 的级别高于int, int的级别高于char等.在表达式中,其级别低于int或unsigned int的任何整数类型均可被替换成int或unsigned int类型. (12)新增数据类型 _Bool 值是0或1。C99中增加了用来定义bool、true以及false宏的头文件夹，以便程序员能够编写同时兼容于C与C++的应用程序。在编写新的应用程序时，应该使用头文件中的bool宏。 _Complex and _Imaginary C99标准中定义的复数类型如下：float_Complex; float_Imaginary; double_Complex; double_Imaginary; long double_Complex; long double_Imaginary.头文件中定义了complex和imaginary宏,并将它们扩展为_Complex和_Imaginary,因此在编写新的应用程序时,应该使用头文件中的complex和imaginary宏。 long long int C99标准中引进了long long int（-(2e63 - 1)至2e63 - 1）和unsigned long long int（0 - 2e64 - 1）。long long int能够支持的整数长度为64位。 较完整的阐述C99对C89的改变 1、增加restrict指针 C99中增加了公适用于指针的restrict类型修饰符，它是初始访问指针所指对象的惟一途径，因此只有借助restrict指针表达式才能访问对象。restrict指针指针主要用做函数变元，或者指向由malloc()函数所分配的内存变量。restrict数据类型不改变程序的语义。 如果某个函数定义了两个restrict指针变元，编译程序就假定它们指向两个不同的对象，memcpy()函数就是restrict指针的一个典型应用示例。C89中memcpy()函数原型如下： 代码: void memcpy (void s1, const void *s2, size_t size); 如果s1和s2所指向的对象重叠，其操作就是未定义的。memcpy()函数只能用于不重叠的对象。C99中memcpy()函数原型如下： 代码: void memcpy(void restrict s1, const void *restrict s2,size_t size); 通过使用restrict修饰s1和s2 变元，可确保它们在该原型中指向不同的对象。 2、inline（内联）关键字 内联函数除了保持结构化和函数式的定义方式外,还能使程序员写出高效率的代码.函数的每次调用与返回都会消耗相当大的系统资源,尤其是当函数调用发生在重复次数很多的循环语句中时.一般情况下,当发生一次函数调用时,变元需要进栈,各种寄存器内存需要保存.当函数返回时,寄存器的内容需要恢复。如果该函数在代码内进行联机扩展，当代码执行时，这些保存和恢复操作旅游活动会再发生，而且函数调用的执行速度也会大大加快。函数的联机扩展会产生较长的代码，所以只应该内联对应用程序性能有显著影响的函数以及长度较短的函数。 3、新增数据类型 _Bool 值是0或1。C99中增加了用来定义bool、true以及false宏的头文件夹，以便程序员能够编写同时兼容于C与C++的应用程序。在编写新的应用程序时，应该使用 头文件中的bool宏。 _Complex and _Imaginary C99标准中定义的复数类型如下：float_Complex; float_Imaginary; double_Complex;double_Imaginary; long double_Complex; long double_Imaginary. 头文件中定义了complex和imaginary宏,并将它们扩展为_Complex和_Imaginary,因此在编写新的应用程序时,应该使用头文件中的complex和imaginary宏。 long long int C99标准中引进了long long int（-(2e63 - 1)至2e63 - 1）和unsigned long long int（0 - 2e64- 1）。long long int能够支持的整数长度为64位。 4、对数组的增强 可变长数组 C99中,程序员声明数组时,数组的维数可以由任一有效的整型表达式确定,包括只在运行时才能确定其值的表达式,这类数组就叫做可变长数组,但是只有局部数组才可以是变长的.可变长数组的维数在数组生存期内是不变的,也就是说,可变长数组不是动态的.可以变化的只是数组的大小.可以使用*来定义不确定长的可变长数组。 数组声明中的类型修饰符 在C99中，如果需要使用数组作为函数变元，可以在数组声明的方括号内使用static关键字，这相当于告诉编译程序，变元所指向的数组将至少包含指定的元素个数。也可以在数组声明的方括号内使用restrict,volatile,const关键字，但只用于函数变元。如果使用restrict，指针是初始访问该对象的惟一途径。如果使用const，指针始终指向同一个数组。使用volatile没有任何意义。 5、单行注释 引入了单行注释标记 “//“ , 可以象C++一样使用这种注释了。 6、分散代码与声明 7、预处理程序的修改 ａ、变元列表 宏可以带变元，在宏定义中用省略号（…）表示。内部预处理标识符VA_ARGS决定变元将在何处得到替换。例：#define MySum(…) sum(VA_ARGS) 语句MySum(k,m,n);将被转换成：sum(k, m, n); 变元还可以包含变元。例： #define compare(compf, …)compf(VA_ARGS) 其中的compare(strcmp,”small”, “large”); 将替换成：strcmp(“small”,”large”); ｂ、_Pragma运算符 C99引入了在程序中定义编译指令的另外一种方法：_Pragma运算符。格式如下： _Pragma(“directive”) 其中directive是要满打满算的编译指令。_Pragma运算符允许编译指令参与宏替换。 ｃ、内部编译指令 STDCFP_CONTRACT ON/OFF/DEFAULT 若为ON，浮点表达式被当做基于硬件方式处理的独立单元。默认值是定义的工具。 STDCFEVN_ACCESS ON/OFF/DEFAULT 告诉编译程序可以访问浮点环境。默认值是定义的工具。 STDC CX_LIMITED_RANGE ON/OFF/DEFAULT 若值为ON，相当于告诉编译程序某程序某些含有复数的公式是可靠的。默认是OFF。 ｄ、新增的内部宏 STDC_HOSTED 若操作系统存在，则为1 STDC_VERSION 199991L或更高。代表C的版本 STDC_IEC_599 若支持IEC 60559浮点运算，则为1 STDC_IEC_599_COMPLEX 若支持IEC 60599复数运算，则为1 STDC_ISO_10646 由编译程序支持，用于说明ISO/IEC 10646标准的年和月格式：yyymmmL 8、for语句内的变量声明 C99中，程序员可以在for语句的初始化部分定义一个或多个变量，这些变量的作用域仅于本for语句所控制的循环体内。比如： 代码:for(int i=0; i&lt;10; i++){​ // do someting …} 9、复合赋值 C99中，复合赋值中，可以指定对象类型的数组、结构或联合表达式。当使用复合赋值时，应在括弧内指定类型，后跟由花括号围起来的初始化列表；若类型为数组，则不能指定数组的大小。建成的对象是未命名的。 例： double *fp = (double[]) {1.1, 2.2, 3.3}; 该语句用于建立一个指向double的指针fp，且该指针指向这个3元素数组的第一个元素。 在文件域内建立的复合赋值只在程序的整个生存期内有效。在模块内建立的复合赋值是局部对象，在退出模块后不再存在。 10、柔性数组结构成员 C99中，结构中的最后一个元素允许是未知大小的数组，这就叫做柔性数组成员，但结构中的柔性数组成员前面必须至少一个其他成员。柔性数组成员允许结构中包含一个大小可变的数组。sizeof返回的这种结构大小不包括柔性数组的内存。包含柔性数组成员的结构用malloc()函数进行内存的动态分配，并且分配的内存应该大于结构的大小，以适应柔性数组的预期大小。 11、指定的初始化符 C99中，该特性对经常使用稀疏数组的程序员十分有用。指定的初始化符通常有两种用法：用于数组，以及用于结构和联合。用于数组的格式：[index] = vol; 其中，index表示数组的下标，vol表示本数组元素的初始化值。 例如： int x[10] = {[0] = 10, [5] = 30}; 其中只有x[0]和x[5]得到了初始化．用于结构或联合的格式如下： member-name(成员名称) 对结构进行指定的初始化时，允许采用简单的方法对结构中的指定成员进行初始化。 例如： struct example{ int k, m, n; } object = {m = 10,n = 200}; 其中，没有初始化k。对结构成员进行初始化的顺序没有限制。 12、printf()和scanf()函数系列的增强 C99中printf()和scanf()函数系列引进了处理long long int和unsigned long long int数据类型的特性。long long int 类型的格式修饰符是ll。在printf()和scanf()函数中，ll适用于d, i, o, u 和x格式说明符。另外，C99还引进了hh修饰符。当使用d, i, o, u和x格式说明符时，hh用于指定char型变元。ll和hh修饰符均可以用于n说明符。 格式修饰符a和A用在printf()函数中时，结果将会输出十六进制的浮点数。格式如下：[-]0xh, hhhhp+ d 使用A格式修饰符时，x和p必须是大写。A和a格式修饰符也可以用在scanf()函数中，用于读取浮点数。调用printf()函数时，允许在%f说明符前加上l修饰符，即%lf，但不起作用。 13、C99新增的库 C89中标准的头文件 定义宏assert() 字符处理 错误报告 定义与实现相关的浮点值勤 定义与实现相关的各种极限值 支持函数setlocale() 数学函数库使用的各种定义 支持非局部跳转 定义信号值 支持可变长度的变元列表 定义常用常数 支持文件输入和输出 其他各种声明 支持串函数 支持系统时间函数 C99新增的头文件和库 支持复数算法 给出对浮点状态标记和浮点环境的其他方面的访问 定义标准的、可移植的整型类型集合。也支持处理最大宽度整数的函数（常见） 首先在此1995年第一次修订时引进，用于定义对应各种运算符的宏 支持布尔数据类型类型。定义宏bool，以便兼容于C++ 定义标准的、可移植的整型类型集合。该文件包含在中（常见） 定义一般类型的浮点宏 首先在1995年第一次修订时引进，用于支持多字节和宽字节函数 首先在1995年第一次修订时引进，用于支持多字节和宽字节分类函数 14、func预定义标识符 用于指出func所存放的函数名，类似于字符串赋值。 15、其它特性的改动 放宽的转换限制 限制 C89标准 C99标准 数据块的嵌套层数 15 127 条件语句的嵌套层数 8 63 内部标识符中的有效字符个数 31 63 外部标识符中的有效字符个数 6 31 结构或联合中的成员个数 127 1023 函数调用中的参数个数 31 127 不再支持隐含式的int规则 删除了隐含式函数声明 对返回值的约束 C99中,非空类型函数必须使用带返回值的return语句. 扩展的整数类型 扩展类型 含义 int16_t 整数长度为精确16位 int_least16_t 整数长度为至少16位 int_fast32_t 最稳固的整数类型,其长度为至少32位 intmax_t 最大整数类型 uintmax_t 最大无符号整数类型 对整数类型提升规则的改进 C89中,表达式中类型为char,short int或int的值可以提升为int或unsigned int类型. C99中,每种整数类型都有一个级别.例如:long long int 的级别高于int, int的级别高于char等.在表达式中,其级别低于int或unsigned int的任何整数类型均可被替换成int或unsigned int类型. C11相比C99的变化编辑 对齐处理操作符 alignof，函数 aligned_alloc()，以及 头文件 。见 7.15 节。 _Noreturn 函数标记，类似于 gcc 的 attribute((noreturn))。例子： _Noreturn void thrd_exit(int res); _Generic 关键词，有点儿类似于 gcc 的 typeof。示例代码： 123456789101112131415#include&lt;stdio.h&gt;#defineGENERAL_ABS(x)_Generic((x),int:abs,float:fabsf,double:fabs)(x)int main(void)&#123;printf("intabs:%d\n",GENERAL_ABS(-12));printf("floatabs:%f\n",GENERAL_ABS(-12.04f));printf("doubleabs:%f\n",GENERAL_ABS(-13.09876));inta=10;intb=0,c=0;_Generic(a+0.1f,int:b,float:c,default:b)++;printf("b=%d,c=%d\n",b,c);_Generic(a+=1.1f,int:b,float:c,default:b)++;printf("a=%d,b=%d,c=%d\n",a,b,c);&#125; 静态断言（ static assertions），_Static_assert()，在解释 #if 和 #error 之后被处理。例子： _Static_assert(FOO &gt; 0, “FOO has a wrong value”); 删除了 gets() 函数，C99中已经将此函数被标记为过时，推荐新的替代函数 gets_s()。 新的 fopen() 模式，(“…x”)。类似 POSIX 中的 O_CREAT|O_EXCL，在文件锁中比较常用。 匿名结构体/联合体，这个早已经在 gcc 中了，我们并不陌生，定义在 6.7.2.1 p13。 多线程支持，包括：_Thread_local，头文件 ，里面包含线程的创建和管理函数（比如 thrd_create()，thrd_exit()），mutex （比如 mtx_lock()，mtx_unlock()）等等，更多内容清参考 7.26 节。 _Atomic类型修饰符和 头文件 ，见 7.17 节。 带边界检查（Bounds-checking）的函数接口，定义了新的安全的函数，例如 fopen_s()，strcat_s() 等等。更多参考 Annex K。 改进的 Unicode 支持，新的头文件 等。实例代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include&lt;stdio.h&gt;#include&lt;uchar.h&gt;size_tUTF16StrLen(constchar16_t*utf16String)&#123;if(utf16String==NULL)return0;size_tindex;for(index=0;utf16String[index]!=u'\0';index++);returnindex;&#125; size_tUTF16ToUTF8(char*mbBuffer,constchar16_t*utf16String)&#123;if(mbBuffer==NULL||utf16String==NULL)return0;mbstate_tstate=&#123;&#125;;size_tmbIndex=0;for(intutf16Index=0;utf16String[utf16Index]!=u'\0';utf16Index++)&#123;constsize_tlength=c16rtomb(&amp;mbBuffer[mbIndex],utf16String[utf16Index],&amp;state);mbIndex+=length;&#125;mbBuffer[mbIndex]='\0';returnmbIndex;&#125;intmain(intargc,char*argv[])&#123;char16_tch=u'好'; charchBuffer[64]; mbstate_tstate=&#123;&#125;; size_tlength=c16rtomb(chBuffer,ch,&amp;state); chBuffer[length]='\0'; printf("TheUTF-8characterlengthis:%zu,andthecharacteris:%s\n",length,chBuffer); constchar*utf8Str=u8"你好，世界。"; printf("TheUTF-8stringis:%s\n",utf8Str); constchar16_t*utf16Str=u"你好，世界。"; printf("Theutf16stringlengthis:%zu\n",UTF16StrLen(utf16Str)); length=UTF16ToUTF8(chBuffer,utf16Str); printf("TheUTF-8stringlengthis:%zu,andthecontentis:%s\n",length,chBuffer); printf("IftheconvertedUTF-8stringisequaltotheoriginalone?%s\n",strcmp(chBuffer,utf8Str)==0?"YES":"NO");&#125; 新增 quick_exit() 函数，作为第三种终止程序的方式，当 exit() 失败时可以做最少的清理工作（deinitializition），具体见 7.22.4.7。 创建复数的宏， CMPLX()，见 7.3.9.3。 更多浮点数处理的宏 （More macros for querying the characteristics of floating point types, concerning subnormal floating point numbers and the number of decimal digits the type is able to store）。 struct timespec 成为 time.h 的一部分，以及宏 TIME_UTC，函数 timespec_get()。]]></content>
      <tags>
        <tag>C Language Homework</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Swift iOS 菜单和圆形布局库 FanMenu]]></title>
    <url>%2F2017%2F11%2FSwift-iOS-%E8%8F%9C%E5%8D%95%E5%92%8C%E5%9C%86%E5%BD%A2%E5%B8%83%E5%B1%80%E5%BA%93-FanMenu%2F</url>
    <content type="text"><![CDATA[FanMenu 是一个菜单和 圆形布局类库，基于 Macaw，用Swift编写。介绍在我上一篇文章中有讲。 用法** 在您的故事板或程序中创建UIView。 将FanMenu设置为UIView类 设置按钮 12345fanMenu.button = FanMenuButton(id: "main",image: "plus",color: Color(val: 0x7C93FE)) 4. 设置菜单项 12345678910111213fanMenu.items = [FanMenuButton(id: "exchange_id",image: "exchange",color: Color(val: 0x9F85FF)), ...FanMenuButton(id: "visa_id",image: "visa",color: Color(val: 0xF55B58))] 5. 添加事件处理程序 123456789//call before animationfanMenu.onItemDidClick = &#123; button inprint("ItemDidClick: \(button.id)")&#125;// call after animationfanMenu.onItemWillClick = &#123; button inprint("ItemWillClick: \(button.id)")&#125;]]></content>
      <tags>
        <tag>Swift library</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Swift 强大且易用的矢量图形库 Macaw]]></title>
    <url>%2F2017%2F11%2FSwift-%E5%BC%BA%E5%A4%A7%E4%B8%94%E6%98%93%E7%94%A8%E7%9A%84%E7%9F%A2%E9%87%8F%E5%9B%BE%E5%BD%A2%E5%BA%93-Macaw%2F</url>
    <content type="text"><![CDATA[此文介绍了Macaw这一强大的矢量图形库……. Macaw是一个功能强大、易于使用的矢量图形库，支持 SVG图片， 用Swift编写。动机现代设计包含大量的插图和复杂的动画。 移动开发人员必须花费大量时间将设计转换为本机视图，这些视图可以针对不同的屏幕进行调整。 使用Macaw，您可以将开发时间缩短到最低限度，并描绘高级场景元素中的所有图形。 甚至可以使用Macaw中的事件和动画支持从设计工具中渲染SVG图形。示例Activity Monitor应用程序显示步数，跑步级别和每日摘要。 动画菜单 你喜欢化学吗？这个iPad应用程序显示了Macaw的全部功能：仿射变换，用户事件，动画和各种效果。 [点击查看更多示例] [开源代码主页]]]></content>
      <tags>
        <tag>Swift Library</tag>
      </tags>
  </entry>
</search>
